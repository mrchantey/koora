{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","src-as/math/constants.ts","src-as/glMatrix/_common.ts","~lib/util/math.ts","~lib/math.ts","src-as/glMatrix/_mat2d.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/util/sort.ts","~lib/shared/runtime.ts","~lib/typedarray.ts","~lib/util/error.ts","src-as/glMatrix/_vec3.ts","src-as/glMatrix/maths.ts","src-as/glMatrix/_vec4.ts","~lib/arraybuffer.ts","~lib/rt.ts","src-as/glMatrix/_quat.ts","src-as/glMatrix/_mat3.ts","src-as/glMatrix/_quat2.ts","src-as/glMatrix/_mat4.ts","~lib/string.ts","~lib/number.ts","src-as/glMatrix/_vec2.ts","src-as/glMatrix/_mat2.ts","src-as/math/Quaternion.ts","src-as/math/Matrix.ts","src-as/math/Vector3.ts","src-as/math/Color8.ts","src-as/math/Color.ts","src-as/math/Texture.ts","src-as/utility/_ArrayUtils.ts","~lib/staticarray.ts","src-as/base/SystemPriority.ts","src-as/rendering/constants/_uniforms.ts","src-as/rendering/constants/_attributes.ts","src-as/rendering/constants/_varyings.ts","src-as/rendering/constants/_ubos/camera.ts","src-as/rendering/material/UniformBufferObject.ts","~lib/array.ts","~lib/util/hash.ts","~lib/map.ts","src-as/rendering/material/Uniform.ts","src-as/rendering/constants/_ubos/mesh.ts","src-as/rendering/constants/_ubos/directionalLight.ts","src-as/WebGL2/imports/_constants.ts","src-as/core/systems/RenderSystem.ts","src-as/rendering/geometry/CubeGeometry.ts","src-as/rendering/geometry/Geometry.ts","src-as/rendering/geometry/Attribute.ts","src-as/utility/_normalUtils.ts","src-as/rendering/geometry/QuadGeometry.ts","src-as/rendering/geometry/TransformGeometry.ts","src-as/rendering/shader/debugNormals.ts","src-as/rendering/shader/Shader.ts","src-as/rendering/shader/glsl/utility.ts","src-as/rendering/shader/lit/litShader.ts","src-as/rendering/shader/particleShader.ts","src-as/rendering/shader/transformFeedback.ts","src-as/rendering/shader/transformFeedbackSimple.ts","src-as/rendering/shader/unlit/unlit.ts","src-as/rendering/shader/unlit/unlitVertexColors.ts","src-as/rendering/shader/uvDebug.ts","src-as/core/systems/InputSystem.ts","src-as/core/systems/TransformSystem.ts","src-as/math/SharedBuffer.ts","src-as/core/components/DirectionalLight.ts","src-as/exports/camera.ts","src-as/base/World.ts","src-as/base/QueryManager.ts","src-as/base/ListenerSystemManager.ts","src-as/base/Entity.ts","src-as/base/Component.ts","src-as/core/components/Transform.ts","~lib/set.ts","src-as/base/Query.ts","src-as/base/System.ts","src-as/core/components/MouseKeyboardController.ts","src-as/core/components/Camera.ts","src-as/utility/Viewport.ts","src-as/rendering/material/Material.ts","src-as/exports/debug.ts","src-as/core/components/Mesh.ts","src-as/rendering/geometry/GridGeometry.ts","src-as/exports/defaultWorld.ts","src-as/core/systems/TimeSystem.ts","~lib/builtins.ts","src-as/math/Vector2.ts","src-as/core/systems/RotatorSystem.ts","src-as/WebGL2/systems/WebGLUniformBufferObjectSystem.ts","src-as/WebGL2/systems/WebGLRenderSystem.ts","src-as/WebGL2/systems/WebGLMaterialSystem.ts","src-as/WebGL2/systems/WebGLMeshSystem.ts","src-as/WebGL2/systems/WebGLGeometrySystem.ts","src-as/WebGL2/systems/WebGLShaderSystem.ts","src-as/core/systems/MouseKeyboardControllerSystem.ts","src-as/exports/light.ts","src-as/math/Vector1.ts","src-as/exports/demos.ts","src-as/core/components/Rotator.ts","src-as/exports/input.ts","src-as/exports/render.ts","src-as/utility/stringUtils.ts","src-as/WebGL2/systems/utility.ts","src-as/WebGL2/components/material.ts","src-as/math/PolarCoords.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./debug","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n//  Memory manager block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -4\n// >ptr\n//                               ...                              \n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n//  Garbage collector object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                      Memory manager block                       -20\n// \n//                             GC info                             -16\n// \n//                             GC info                             -12\n// \n//                             RT id                               -8\n// \n//                             RT size                             -4\n// >ptr\n//                               ...                              \n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//             \n//                           size                             LF  info   overhead\n// >ptr           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                   >= 0\n//    \n//                         if free: back                          \n//  >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's gc, see: https://github.com/bullno1/ugc\n\n//  Colors \n//  Color        Meaning                                         \n// \n//  WHITE*       Unprocessed                                     \n//  BLACK*       Processed                                       \n//  GRAY         Processed with unprocessed children             \n//  TRANSPARENT  Manually pinned (always reachable)              \n// \n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n//  Managed object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                       Memory manager block                     \n// \n//                               next                          C  = nextWithColor\n// \n//                               prev                             \n// \n//                               rtId                             \n// \n//                               rtSize                           \n// >ptr\n//                                ...                             \n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\" GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\" GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","\n\n\nexport const QUARTER_TAU: f32 = 1.57079632679\nexport const HALF_TAU: f32 = 3.141592653589793\nexport const THREE_QUARTER_TAU: f32 = 4.71238898038\nexport const TAU: f32 = 6.28318530718\n\nexport const PI: f32 = HALF_TAU\nexport const EPSILON: f32 = 0.0001\n\nexport const deg2rad: f32 =  PI / 180\nexport const rad2deg: f32  = 180 / PI\nexport const millis2Secs: f32 = 0.001\nexport const secs2Millis: f32 = 1000\n","import { Maths } from './maths'\n\n/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport const EPSILON = 0.000001\nexport enum ArrayTypeEnum {\n  Float32ArrayT = idof<Float32Array>(),\n  ArrayF32T = idof<Array<f32>>(),\n}\nexport let ARRAY_TYPE = ArrayTypeEnum.Float32ArrayT\nexport const RANDOM = Mathf.random\nexport const ANGLE_ORDER = 'zyx'\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Number} id Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(id: i32): void {\n\tARRAY_TYPE = id\n}\n\nconst degree: f32 = Mathf.PI / 180\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a: f32): f32 {\n\treturn a * degree\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a: f32, b: f32): bool {\n\treturn Mathf.abs(a - b) <= EPSILON * Maths.max(1.0, Mathf.abs(a), Mathf.abs(b))\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of /2 * |x|\n *\n * y = /4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of /4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 /  with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2)\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\n  var big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy var random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy var random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    var e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31)    return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += <i32>(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = <i32>(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = <i32>(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = <u32>(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = <u32>(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    let roundUp = builtin_ceil<f64>(x);\n    return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return <bool>(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var a = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) {  // |x| ~<= /4\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); //  * 0x1p-65 = 8.51530395021638647334e-20\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { //  * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  var i = reinterpret<i64>(x);\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  var xx = x * x;\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  var n = nearest(x);\n  x -= n;\n  var xx = x * x;\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5/4\n        if (ix > 0x4016CBE3) { // |x|  ~> 3/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9/4\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign_) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      if (u < 0x00800000 || <bool>(u >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (u >> 31) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += <u32>(<i32>u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) {\n      return x;\n    } else if (ix == 0x3F800000) {\n      return 0;\n    }\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ix = reinterpret<u32>(x);\n      let k: i32 = 0;\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\n        if (ix << 1 == 0) return -1 / (x * x);\n        if (ix >> 31) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ix = reinterpret<u32>(x);\n      } else if (ix >= 0x7F800000) {\n        return x;\n      } else if (ix == 0x3F800000) {\n        return 0;\n      }\n      ix += 0x3F800000 - 0x3F3504F3;\n      k += <i32>(ix >> 23) - 0x7F;\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ix);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = uy >> 31 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = uy >> 31 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    let roundUp = builtin_ceil<f32>(x);\n    return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var a = reinterpret<f32>(u);\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // argument reduction\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sm = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyVec2 } from './_vec2'\n\nexport type mat2d = IndexedCollection;\n\nexport type ReadonlyMat2d = IndexedCollection;\n\n/**\n * 2x3 Matrix\n * @module mat2d\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b,\n *  c, d,\n *  tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nexport function create(): mat2d {\n\tconst out = new Float32Array(6)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t\tout[4] = 0\n\t\tout[5] = 0\n\t}\n\tout[0] = 1\n\tout[3] = 1\n\treturn out\n}\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nexport function clone(a: ReadonlyMat2d): mat2d {\n\tconst out = new Float32Array(6)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\treturn out\n}\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\nexport function copy(out: mat2d, a: ReadonlyMat2d): mat2d {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\treturn out\n}\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nexport function identity(out: mat2d): mat2d {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\tout[4] = 0\n\tout[5] = 0\n\treturn out\n}\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nexport function fromValues(a: f32, b: f32, c: f32, d: f32, tx: f32, ty: f32): mat2d {\n\tconst out = new Float32Array(6)\n\tout[0] = a\n\tout[1] = b\n\tout[2] = c\n\tout[3] = d\n\tout[4] = tx\n\tout[5] = ty\n\treturn out\n}\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nexport function set(out: mat2d, a: f32, b: f32, c: f32, d: f32, tx: f32, ty: f32): mat2d {\n\tout[0] = a\n\tout[1] = b\n\tout[2] = c\n\tout[3] = d\n\tout[4] = tx\n\tout[5] = ty\n\treturn out\n}\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {mat2d} out\n */\nexport function invert(out: mat2d, a: ReadonlyMat2d): mat2d | null {\n\tconst aa = a[0],\n\t\tab = a[1],\n\t\tac = a[2],\n\t\tad = a[3]\n\tconst atx = a[4],\n\t\taty = a[5]\n\n\tlet det = aa * ad - ab * ac\n\tif (!det) {\n\t\treturn null\n\t}\n\tdet = 1.0 / det\n\n\tout[0] = ad * det\n\tout[1] = -ab * det\n\tout[2] = -ac * det\n\tout[3] = aa * det\n\tout[4] = (ac * aty - ad * atx) * det\n\tout[5] = (ab * atx - aa * aty) * det\n\treturn out\n}\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {ReadonlyMat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a: ReadonlyMat2d): f32 {\n\treturn a[0] * a[3] - a[1] * a[2]\n}\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\nexport function multiply(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3],\n\t\tb4 = b[4],\n\t\tb5 = b[5]\n\tout[0] = a0 * b0 + a2 * b1\n\tout[1] = a1 * b0 + a3 * b1\n\tout[2] = a0 * b2 + a2 * b3\n\tout[3] = a1 * b2 + a3 * b3\n\tout[4] = a0 * b4 + a2 * b5 + a4\n\tout[5] = a1 * b4 + a3 * b5 + a5\n\treturn out\n}\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nexport function rotate(out: mat2d, a: ReadonlyMat2d, rad: f32): mat2d {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5]\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tout[0] = a0 * c + a2 * s\n\tout[1] = a1 * c + a3 * s\n\tout[2] = a0 * -s + a2 * c\n\tout[3] = a1 * -s + a3 * c\n\tout[4] = a4\n\tout[5] = a5\n\treturn out\n}\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nexport function scale(out: mat2d, a: ReadonlyMat2d, v: ReadonlyVec2): mat2d {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5]\n\tconst v0 = v[0],\n\t\tv1 = v[1]\n\tout[0] = a0 * v0\n\tout[1] = a1 * v0\n\tout[2] = a2 * v1\n\tout[3] = a3 * v1\n\tout[4] = a4\n\tout[5] = a5\n\treturn out\n}\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to translate\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nexport function translate(out: mat2d, a: ReadonlyMat2d, v: ReadonlyVec2): mat2d {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5]\n\tconst v0 = v[0],\n\t\tv1 = v[1]\n\tout[0] = a0\n\tout[1] = a1\n\tout[2] = a2\n\tout[3] = a3\n\tout[4] = a0 * v0 + a2 * v1 + a4\n\tout[5] = a1 * v0 + a3 * v1 + a5\n\treturn out\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nexport function fromRotation(out: mat2d, rad: f32): mat2d {\n\tconst s = Mathf.sin(rad),\n\t\tc = Mathf.cos(rad)\n\tout[0] = c\n\tout[1] = s\n\tout[2] = -s\n\tout[3] = c\n\tout[4] = 0\n\tout[5] = 0\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2d} out\n */\nexport function fromScaling(out: mat2d, v: ReadonlyVec2): mat2d {\n\tout[0] = v[0]\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = v[1]\n\tout[4] = 0\n\tout[5] = 0\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat2d} out\n */\nexport function fromTranslation(out: mat2d, v: ReadonlyVec2): mat2d {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\tout[4] = v[0]\n\tout[5] = v[1]\n\treturn out\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {ReadonlyMat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a: ReadonlyMat2d): string {\n\treturn (\n\t\t'mat2d(' +\n    a[0].toString() +\n    ', ' +\n    a[1].toString() +\n    ', ' +\n    a[2].toString() +\n    ', ' +\n    a[3].toString() +\n    ', ' +\n    a[4].toString() +\n    ', ' +\n    a[5].toString() +\n    ')'\n\t)\n}\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a: ReadonlyMat2d): f32 {\n\treturn Maths.hypot7(a[0], a[1], a[2], a[3], a[4], a[5], 1)\n}\n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\nexport function add(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\tout[4] = a[4] + b[4]\n\tout[5] = a[5] + b[5]\n\treturn out\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @returns {mat2d} out\n */\nexport function subtract(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\tout[3] = a[3] - b[3]\n\tout[4] = a[4] - b[4]\n\tout[5] = a[5] - b[5]\n\treturn out\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nexport function multiplyScalar(out: mat2d, a: ReadonlyMat2d, b: f32): mat2d {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\tout[4] = a[4] * b\n\tout[5] = a[5] * b\n\treturn out\n}\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {ReadonlyMat2d} a the first operand\n * @param {ReadonlyMat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nexport function multiplyScalarAndAdd(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d, scale: f32): mat2d {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\tout[3] = a[3] + b[3] * scale\n\tout[4] = a[4] + b[4] * scale\n\tout[5] = a[5] + b[5] * scale\n\treturn out\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyMat2d, b: ReadonlyMat2d): bool {\n\treturn (\n\t\ta[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5]\n\t)\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2d} a The first matrix.\n * @param {ReadonlyMat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a: ReadonlyMat2d, b: ReadonlyMat2d): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3],\n\t\tb4 = b[4],\n\t\tb5 = b[5]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3)) &&\n    Mathf.abs(a4 - b4) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a4), Mathf.abs(b4)) &&\n    Mathf.abs(a5 - b5) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a5), Mathf.abs(b5))\n\t)\n}\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nexport const sub = subtract\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  var initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (changetype<usize>(a) == changetype<usize>(b) || changetype<usize>(a) == 0 || changetype<usize>(b) == 0) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  var lgPlus2         = log2u(len) + 2;\n  var lgPlus2Size     = lgPlus2 << alignof<u32>();\n  var leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  var leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  var buffer = __alloc(len << alignof<T>());\n\n  var hi   = len - 1;\n  var endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  var lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  var top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  var n: u64 = right - left + 1;\n  var s = startB - (left << 1);\n  var l = startA + s;\n  var r = endB   + s + 1;\n  var a = (<u64>l << 30) / n;\n  var b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  var j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  var i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    var len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    var len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    var len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    var len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    var len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    var len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    var len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    var len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var ptr = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(ptr + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  var dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyMat3 } from './_mat3'\nimport { ReadonlyMat4 } from './_mat4'\nimport { ReadonlyQuat } from './_quat'\n\nexport type vec3 = IndexedCollection;\n\nexport type ReadonlyVec3 = IndexedCollection;\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nexport function create(): vec3 {\n\tconst out = new Float32Array(3)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[0] = 0\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t}\n\treturn out\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nexport function clone(a: ReadonlyVec3): vec3 {\n\tconst out = new Float32Array(3)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\treturn out\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a: ReadonlyVec3): f32 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\treturn Maths.hypot3(x, y, z)\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nexport function fromValues(x: f32, y: f32, z: f32): vec3 {\n\tconst out = new Float32Array(3)\n\tout[0] = x\n\tout[1] = y\n\tout[2] = z\n\treturn out\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\treturn out\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out: vec3, x: f32, y: f32, z: f32): vec3 {\n\tout[0] = x\n\tout[1] = y\n\tout[2] = z\n\treturn out\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\treturn out\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\treturn out\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = a[0] * b[0]\n\tout[1] = a[1] * b[1]\n\tout[2] = a[2] * b[2]\n\treturn out\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = a[0] / b[0]\n\tout[1] = a[1] / b[1]\n\tout[2] = a[2] / b[2]\n\treturn out\n}\n\n/**\n * Mathf.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\nexport function ceil(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = Mathf.ceil(a[0])\n\tout[1] = Mathf.ceil(a[1])\n\tout[2] = Mathf.ceil(a[2])\n\treturn out\n}\n\n/**\n * Mathf.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\nexport function floor(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = Mathf.floor(a[0])\n\tout[1] = Mathf.floor(a[1])\n\tout[2] = Mathf.floor(a[2])\n\treturn out\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function min(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = Mathf.min(a[0], b[0])\n\tout[1] = Mathf.min(a[1], b[1])\n\tout[2] = Mathf.min(a[2], b[2])\n\treturn out\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function max(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tout[0] = Mathf.max(a[0], b[0])\n\tout[1] = Mathf.max(a[1], b[1])\n\tout[2] = Mathf.max(a[2], b[2])\n\treturn out\n}\n\n/**\n * Mathf.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\nexport function round(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = Mathf.round(a[0])\n\tout[1] = Mathf.round(a[1])\n\tout[2] = Mathf.round(a[2])\n\treturn out\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out: vec3, a: ReadonlyVec3, b: f32): vec3 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\treturn out\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nexport function scaleAndAdd(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, scale: f32): vec3 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\treturn out\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a: ReadonlyVec3, b: ReadonlyVec3): f32 {\n\tconst x = b[0] - a[0]\n\tconst y = b[1] - a[1]\n\tconst z = b[2] - a[2]\n\treturn Maths.hypot3(x, y, z)\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a: ReadonlyVec3, b: ReadonlyVec3): f32 {\n\tconst x = b[0] - a[0]\n\tconst y = b[1] - a[1]\n\tconst z = b[2] - a[2]\n\treturn x * x + y * y + z * z\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a: ReadonlyVec3): f32 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\treturn x * x + y * y + z * z\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = -a[0]\n\tout[1] = -a[1]\n\tout[2] = -a[2]\n\treturn out\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out: vec3, a: ReadonlyVec3): vec3 {\n\tout[0] = 1.0 / a[0]\n\tout[1] = 1.0 / a[1]\n\tout[2] = 1.0 / a[2]\n\treturn out\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out: vec3, a: ReadonlyVec3): vec3 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\tlet len = x * x + y * y + z * z\n\tif (len > 0) {\n\t\t//TODO: evaluate use of glm_invsqrt here?\n\t\tlen = 1 / Mathf.sqrt(len)\n\t}\n\tout[0] = a[0] * len\n\tout[1] = a[1] * len\n\tout[2] = a[2] * len\n\treturn out\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a: ReadonlyVec3, b: ReadonlyVec3): f32 {\n\treturn a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3 {\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2]\n\tconst bx = b[0],\n\t\tby = b[1],\n\t\tbz = b[2]\n\n\tout[0] = ay * bz - az * by\n\tout[1] = az * bx - ax * bz\n\tout[2] = ax * by - ay * bx\n\treturn out\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, t: f32): vec3 {\n\tconst ax = a[0]\n\tconst ay = a[1]\n\tconst az = a[2]\n\tout[0] = ax + t * (b[0] - ax)\n\tout[1] = ay + t * (b[1] - ay)\n\tout[2] = az + t * (b[2] - az)\n\treturn out\n}\n\n/**\n * Performs a spherical linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function slerp(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, t: f32): vec3 {\n\tconst angle = Mathf.acos(Mathf.min(Mathf.max(dot(a, b), -1), 1))\n\tconst sinTotal = Mathf.sin(angle)\n\n\tconst ratioA = Mathf.sin((1 - t) * angle) / sinTotal\n\tconst ratioB = Mathf.sin(t * angle) / sinTotal\n\tout[0] = ratioA * a[0] + ratioB * b[0]\n\tout[1] = ratioA * a[1] + ratioB * b[1]\n\tout[2] = ratioA * a[2] + ratioB * b[2]\n\n\treturn out\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function hermite(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: f32): vec3 {\n\tconst factorTimes2 = t * t\n\tconst factor1 = factorTimes2 * (2 * t - 3) + 1\n\tconst factor2 = factorTimes2 * (t - 2) + t\n\tconst factor3 = factorTimes2 * (t - 1)\n\tconst factor4 = factorTimes2 * (3 - 2 * t)\n\n\tout[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4\n\tout[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4\n\tout[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4\n\n\treturn out\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function bezier(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: f32): vec3 {\n\tconst inverseFactor = <f32>1 - t\n\tconst inverseFactorTimesTwo = inverseFactor * inverseFactor\n\tconst factorTimes2 = t * t\n\tconst factor1 = inverseFactorTimesTwo * inverseFactor\n\tconst factor2 = <f32>3 * t * inverseFactorTimesTwo\n\tconst factor3 = <f32>3 * factorTimes2 * inverseFactor\n\tconst factor4 = factorTimes2 * t\n\n\tout[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4\n\tout[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4\n\tout[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4\n\n\treturn out\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec3} out\n */\nexport function random(out: vec3, scale: f32): vec3 {\n\tscale = scale || <f32>1.0\n\n\tconst r = glMatrix.RANDOM() * <f32>2.0 * Mathf.PI\n\tconst z = glMatrix.RANDOM() * <f32>2.0 - <f32>1.0\n\tconst zScale = Mathf.sqrt(<f32>1.0 - z * z) * scale\n\n\tout[0] = Mathf.cos(r) * zScale\n\tout[1] = Mathf.sin(r) * zScale\n\tout[2] = z * scale\n\treturn out\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out: vec3, a: ReadonlyVec3, m: ReadonlyMat4): vec3 {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2]\n\tlet w = m[3] * x + m[7] * y + m[11] * z + m[15]\n\tw = w || 1.0\n\tout[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n\tout[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n\tout[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n\treturn out\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out: vec3, a: ReadonlyVec3, m: ReadonlyMat3): vec3 {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2]\n\tout[0] = x * m[0] + y * m[3] + z * m[6]\n\tout[1] = x * m[1] + y * m[4] + z * m[7]\n\tout[2] = x * m[2] + y * m[5] + z * m[8]\n\treturn out\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out: vec3, a: ReadonlyVec3, q: ReadonlyQuat): vec3 {\n\t// benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n\tconst qx = q[0],\n\t\tqy = q[1],\n\t\tqz = q[2],\n\t\tqw = q[3]\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2]\n\t// var qvec = [qx, qy, qz];\n\t// var uv = vec3.cross([], qvec, a);\n\tlet uvx = qy * z - qz * y,\n\t\tuvy = qz * x - qx * z,\n\t\tuvz = qx * y - qy * x\n\t// var uuv = vec3.cross([], qvec, uv);\n\tlet uuvx = qy * uvz - qz * uvy,\n\t\tuuvy = qz * uvx - qx * uvz,\n\t\tuuvz = qx * uvy - qy * uvx\n\t// vec3.scale(uv, uv, 2 * w);\n\tconst w2 = qw * 2\n\tuvx *= w2\n\tuvy *= w2\n\tuvz *= w2\n\t// vec3.scale(uuv, uuv, 2);\n\tuuvx *= 2\n\tuuvy *= 2\n\tuuvz *= 2\n\t// return vec3.add(out, a, vec3.add(out, uv, uuv));\n\tout[0] = x + uvx + uuvx\n\tout[1] = y + uvy + uuvy\n\tout[2] = z + uvz + uuvz\n\treturn out\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateX(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: f32): vec3 {\n\tconst p: f32[] = [],\n\t\tr: f32[] = []\n\t//Translate point to the origin\n\tp[0] = a[0] - b[0]\n\tp[1] = a[1] - b[1]\n\tp[2] = a[2] - b[2]\n\n\t//perform rotation\n\tr[0] = p[0]\n\tr[1] = p[1] * Mathf.cos(rad) - p[2] * Mathf.sin(rad)\n\tr[2] = p[1] * Mathf.sin(rad) + p[2] * Mathf.cos(rad)\n\n\t//translate to correct position\n\tout[0] = r[0] + b[0]\n\tout[1] = r[1] + b[1]\n\tout[2] = r[2] + b[2]\n\n\treturn out\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateY(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: f32): vec3 {\n\tconst p: f32[] = [],\n\t\tr: f32[] = []\n\t//Translate point to the origin\n\tp[0] = a[0] - b[0]\n\tp[1] = a[1] - b[1]\n\tp[2] = a[2] - b[2]\n\n\t//perform rotation\n\tr[0] = p[2] * Mathf.sin(rad) + p[0] * Mathf.cos(rad)\n\tr[1] = p[1]\n\tr[2] = p[2] * Mathf.cos(rad) - p[0] * Mathf.sin(rad)\n\n\t//translate to correct position\n\tout[0] = r[0] + b[0]\n\tout[1] = r[1] + b[1]\n\tout[2] = r[2] + b[2]\n\n\treturn out\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateZ(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: f32): vec3 {\n\tconst p: f32[] = [],\n\t\tr: f32[] = []\n\t//Translate point to the origin\n\tp[0] = a[0] - b[0]\n\tp[1] = a[1] - b[1]\n\tp[2] = a[2] - b[2]\n\n\t//perform rotation\n\tr[0] = p[0] * Mathf.cos(rad) - p[1] * Mathf.sin(rad)\n\tr[1] = p[0] * Mathf.sin(rad) + p[1] * Mathf.cos(rad)\n\tr[2] = p[2]\n\n\t//translate to correct position\n\tout[0] = r[0] + b[0]\n\tout[1] = r[1] + b[1]\n\tout[2] = r[2] + b[2]\n\n\treturn out\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a: ReadonlyVec3, b: ReadonlyVec3): f32 {\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\tbx = b[0],\n\t\tby = b[1],\n\t\tbz = b[2],\n\t\tmag1 = Mathf.sqrt(ax * ax + ay * ay + az * az),\n\t\tmag2 = Mathf.sqrt(bx * bx + by * by + bz * bz),\n\t\tmag = mag1 * mag2,\n\t\tcosine = mag && dot(a, b) / mag\n\treturn Mathf.acos(Mathf.min(Mathf.max(cosine, -1), 1))\n}\n\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\nexport function zero(out: vec3): vec3 {\n\tout[0] = 0.0\n\tout[1] = 0.0\n\tout[2] = 0.0\n\treturn out\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a: ReadonlyVec3): string {\n\treturn 'vec3(' + a[0].toString() + ', ' + a[1].toString() + ', ' + a[2].toString() + ')'\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyVec3, b: ReadonlyVec3): bool {\n\treturn a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a: ReadonlyVec3, b: ReadonlyVec3): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2))\n\t)\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nexport const sub = subtract\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nexport const div = divide\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nexport const dist = distance\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nexport const len = length\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n","/* eslint-disable*/\n/**\n * Extended Math functions\n */\n\nexport namespace Maths {\n  /**\n   * Returns the square root of the sum of squares of its arguments.\n   * @param a a\n   * @param b b\n   * @param c c \n   */\n  export function hypot3(a: f32, b: f32, c: f32): f32 {\n  \ta = Mathf.abs(a)\n  \tb = Mathf.abs(b)\n  \tc = Mathf.abs(c)\n  \tMathf.hypot\n  \n  \tconst s = max(a, b, c)\n  \tif (s == 0) return 0\n  \tconst invs = <f32>1 / s\n  \ta *= invs\n  \tb *= invs\n  \tc *= invs\n  \treturn s * Mathf.sqrt(a * a + b * b + c * c)\n  }\n\n  /**\n   * Returns the square root of the sum of squares of its arguments.\n   * @param a a\n   * @param b b\n   * @param c c\n   * @param d d \n   */\n  export function hypot4(a: f32, b: f32, c: f32, d: f32): f32 {\n  \ta = Mathf.abs(a)\n  \tb = Mathf.abs(b)\n  \tc = Mathf.abs(c)\n  \td = Mathf.abs(d)\n  \n  \tconst s = Mathf.max(a, max(b, c, d))\n  \tif (s == 0) return 0\n  \tconst invs = <f32>1 / s\n  \ta *= invs\n  \tb *= invs\n  \tc *= invs\n  \td *= invs\n  \treturn s * Mathf.sqrt(a * a + b * b + c * c + d * d)\n  }\n\n  /**\n   * Returns the square root of the sum of squares of its arguments.\n   * @param a a\n   * @param b b\n   * @param c c\n   * @param d d\n   * @param e e\n   * @param f f\n   * @param g g \n   */\n  export function hypot7(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32): f32 {\n  \ta = Mathf.abs(a)\n  \tb = Mathf.abs(b)\n  \tc = Mathf.abs(c)\n  \td = Mathf.abs(d)\n  \te = Mathf.abs(e)\n  \tf = Mathf.abs(f)\n  \tg = Mathf.abs(g)\n  \n  \tconst s = max(a, max(b, c, d), max(e, f, g))\n  \tif (s == 0) return 0\n  \tconst invs = <f32>1.0 / s\n  \ta *= invs\n  \tb *= invs\n  \tc *= invs\n  \td *= invs\n  \te *= invs\n  \tf *= invs\n  \tg *= invs\n  \treturn s * Mathf.sqrt(a * a + b * b + c * c + d * d + e * e + f * f + g * g)\n  }\n\n  /**\n   * Returns the square root of the sum of squares of its arguments.\n   * @param a a\n   * @param b b\n   * @param c c\n   * @param d d\n   * @param e e\n   * @param f f\n   * @param g g\n   * @param h h\n   * @param i i \n   */\n  export function hypot9(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32, i: f32): f32 {\n  \ta = Mathf.abs(a)\n  \tb = Mathf.abs(b)\n  \tc = Mathf.abs(c)\n  \td = Mathf.abs(d)\n  \te = Mathf.abs(e)\n  \tf = Mathf.abs(f)\n  \tg = Mathf.abs(g)\n  \th = Mathf.abs(h)\n  \ti = Mathf.abs(i)\n  \n  \tconst s = max(max(a, max(b, c, d), max(e, f, g)), h, i)\n  \tif (s == 0) return 0\n  \tconst invs = <f32>1.0 / s\n  \ta *= invs\n  \tb *= invs\n  \tc *= invs\n  \td *= invs\n  \te *= invs\n  \tf *= invs\n  \tg *= invs\n  \th *= invs\n  \ti *= invs\n  \treturn s * Mathf.sqrt(a * a + b * b + c * c + d * d + e * e + f * f + g * g + h * h + i * i)\n  }\n\n  /**\n   * Returns the square root of the sum of squares of its arguments.\n   * @param a a\n   * @param b b\n   * @param c c\n   * @param d d\n   * @param e e\n   * @param f f\n   * @param g g\n   * @param h h\n   * @param i i\n   * @param j j\n   * @param k k\n   * @param l l\n   * @param m m\n   * @param n n\n   * @param o o\n   * @param p p \n   */\n  export function hypot16(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32, i: f32, j: f32, k: f32, l: f32, m: f32, n: f32, o: f32, p: f32): f32 {\n  \ta = Mathf.abs(a)\n  \tb = Mathf.abs(b)\n  \tc = Mathf.abs(c)\n  \td = Mathf.abs(d)\n  \te = Mathf.abs(e)\n  \tf = Mathf.abs(f)\n  \tg = Mathf.abs(g)\n  \th = Mathf.abs(h)\n  \ti = Mathf.abs(i)\n  \tj = Mathf.abs(j)\n  \tk = Mathf.abs(k)\n  \tl = Mathf.abs(l)\n  \tm = Mathf.abs(m)\n  \tn = Mathf.abs(n)\n  \to = Mathf.abs(o)\n  \tp = Mathf.abs(p)\n  \n  \tconst s = Mathf.max(max(a, max(b, c, d), max(e, f, g)), max(max(h, i, j), max(k, l, m), max(n, o, p)))\n  \tif (s == 0) return 0\n  \tconst invs = <f32>1.0 / s\n  \ta *= invs\n  \tb *= invs\n  \tc *= invs\n  \td *= invs\n  \te *= invs\n  \tf *= invs\n  \tg *= invs\n  \th *= invs\n  \tj *= invs\n  \tk *= invs\n  \tl *= invs\n  \tm *= invs\n  \tn *= invs\n  \to *= invs\n  \tp *= invs\n  \treturn s * Mathf.sqrt(a * a + b * b + c * c + d * d + e * e + f * f + g * g + h * h + i * i + j * j + k * k + m * m + n * n + o * o + p * p)\n  }\n\n  /**\n   * Returns the larger of a set of supplied numeric expressions.\n   * @param a a\n   * @param b b\n   * @param c c\n   */\n  export function max(a: f32, b: f32, c: f32): f32 {\n  \tconst q = Mathf.max(b, c)\n  \treturn Mathf.max(a, q)\n  }\n}","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyQuat } from './_quat'\n\nexport type vec4 = IndexedCollection;\n\nexport type ReadonlyVec4 = IndexedCollection;\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nexport function create(): vec4 {\n\tconst out = new Float32Array(4)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[0] = 0\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t\tout[3] = 0\n\t}\n\treturn out\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nexport function clone(a: ReadonlyVec4): vec4 {\n\tconst out = new Float32Array(4)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nexport function fromValues(x: f32, y: f32, z: f32, w: f32): vec4 {\n\tconst out = new Float32Array(4)\n\tout[0] = x\n\tout[1] = y\n\tout[2] = z\n\tout[3] = w\n\treturn out\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out: vec4, x: f32, y: f32, z: f32, w: f32): vec4 {\n\tout[0] = x\n\tout[1] = y\n\tout[2] = z\n\tout[3] = w\n\treturn out\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\treturn out\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function subtract(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\tout[3] = a[3] - b[3]\n\treturn out\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function multiply(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = a[0] * b[0]\n\tout[1] = a[1] * b[1]\n\tout[2] = a[2] * b[2]\n\tout[3] = a[3] * b[3]\n\treturn out\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function divide(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = a[0] / b[0]\n\tout[1] = a[1] / b[1]\n\tout[2] = a[2] / b[2]\n\tout[3] = a[3] / b[3]\n\treturn out\n}\n\n/**\n * Mathf.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\nexport function ceil(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = Mathf.ceil(a[0])\n\tout[1] = Mathf.ceil(a[1])\n\tout[2] = Mathf.ceil(a[2])\n\tout[3] = Mathf.ceil(a[3])\n\treturn out\n}\n\n/**\n * Mathf.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\nexport function floor(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = Mathf.floor(a[0])\n\tout[1] = Mathf.floor(a[1])\n\tout[2] = Mathf.floor(a[2])\n\tout[3] = Mathf.floor(a[3])\n\treturn out\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function min(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = Mathf.min(a[0], b[0])\n\tout[1] = Mathf.min(a[1], b[1])\n\tout[2] = Mathf.min(a[2], b[2])\n\tout[3] = Mathf.min(a[3], b[3])\n\treturn out\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function max(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4 {\n\tout[0] = Mathf.max(a[0], b[0])\n\tout[1] = Mathf.max(a[1], b[1])\n\tout[2] = Mathf.max(a[2], b[2])\n\tout[3] = Mathf.max(a[3], b[3])\n\treturn out\n}\n\n/**\n * Mathf.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\nexport function round(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = Mathf.round(a[0])\n\tout[1] = Mathf.round(a[1])\n\tout[2] = Mathf.round(a[2])\n\tout[3] = Mathf.round(a[3])\n\treturn out\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out: vec4, a: ReadonlyVec4, b: f32): vec4 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\treturn out\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nexport function scaleAndAdd(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4, scale: f32): vec4 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\tout[3] = a[3] + b[3] * scale\n\treturn out\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a: ReadonlyVec4, b: ReadonlyVec4): f32 {\n\tconst x = b[0] - a[0]\n\tconst y = b[1] - a[1]\n\tconst z = b[2] - a[2]\n\tconst w = b[3] - a[3]\n\treturn Maths.hypot4(x, y, z, w)\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a: ReadonlyVec4, b: ReadonlyVec4): f32 {\n\tconst x = b[0] - a[0]\n\tconst y = b[1] - a[1]\n\tconst z = b[2] - a[2]\n\tconst w = b[3] - a[3]\n\treturn x * x + y * y + z * z + w * w\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a: ReadonlyVec4): f32 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\tconst w = a[3]\n\treturn Maths.hypot4(x, y, z, w)\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a: ReadonlyVec4): f32 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\tconst w = a[3]\n\treturn x * x + y * y + z * z + w * w\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\nexport function negate(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = -a[0]\n\tout[1] = -a[1]\n\tout[2] = -a[2]\n\tout[3] = -a[3]\n\treturn out\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\nexport function inverse(out: vec4, a: ReadonlyVec4): vec4 {\n\tout[0] = 1.0 / a[0]\n\tout[1] = 1.0 / a[1]\n\tout[2] = 1.0 / a[2]\n\tout[3] = 1.0 / a[3]\n\treturn out\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out: vec4, a: ReadonlyVec4): vec4 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tconst z = a[2]\n\tconst w = a[3]\n\tlet len = x * x + y * y + z * z + w * w\n\tif (len > 0) {\n\t\tlen = 1 / Mathf.sqrt(len)\n\t}\n\tout[0] = x * len\n\tout[1] = y * len\n\tout[2] = z * len\n\tout[3] = w * len\n\treturn out\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a: ReadonlyVec4, b: ReadonlyVec4): f32 {\n\treturn a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} u the first vector\n * @param {ReadonlyVec4} v the second vector\n * @param {ReadonlyVec4} w the third vector\n * @returns {vec4} out\n */\nexport function cross(out: vec4, u: ReadonlyVec4, v: ReadonlyVec4, w: ReadonlyVec4): vec4 {\n\tconst A = v[0] * w[1] - v[1] * w[0],\n\t\tB = v[0] * w[2] - v[2] * w[0],\n\t\tC = v[0] * w[3] - v[3] * w[0],\n\t\tD = v[1] * w[2] - v[2] * w[1],\n\t\tE = v[1] * w[3] - v[3] * w[1],\n\t\tF = v[2] * w[3] - v[3] * w[2]\n\tconst G = u[0]\n\tconst H = u[1]\n\tconst I = u[2]\n\tconst J = u[3]\n\n\tout[0] = H * F - I * E + J * D\n\tout[1] = -(G * F) + I * C - J * B\n\tout[2] = G * E - H * C + J * A\n\tout[3] = -(G * D) + H * B - I * A\n\n\treturn out\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4, t: f32): vec4 {\n\tconst ax = a[0]\n\tconst ay = a[1]\n\tconst az = a[2]\n\tconst aw = a[3]\n\tout[0] = ax + t * (b[0] - ax)\n\tout[1] = ay + t * (b[1] - ay)\n\tout[2] = az + t * (b[2] - az)\n\tout[3] = aw + t * (b[3] - aw)\n\treturn out\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec4} out\n */\nexport function random(out: vec4, scale: f32): vec4 {\n\tscale = scale || 1.0\n\n\t// Marsaglia, George. Choosing a Point from the Surface of a\n\t// Sphere. Ann. Mathf. Statist. 43 (1972), no. 2, 645--646.\n\t// http://projecteuclid.org/euclid.aoms/1177692644;\n\tlet v1: f32, v2: f32, v3: f32, v4: f32\n\tlet s1: f32, s2: f32\n\tdo {\n\t\tv1 = glMatrix.RANDOM() * 2 - 1\n\t\tv2 = glMatrix.RANDOM() * 2 - 1\n\t\ts1 = v1 * v1 + v2 * v2\n\t} while (s1 >= 1)\n\tdo {\n\t\tv3 = glMatrix.RANDOM() * 2 - 1\n\t\tv4 = glMatrix.RANDOM() * 2 - 1\n\t\ts2 = v3 * v3 + v4 * v4\n\t} while (s2 >= 1)\n\n\tconst d = Mathf.sqrt((1 - s1) / s2)\n\tout[0] = scale * v1\n\tout[1] = scale * v2\n\tout[2] = scale * v3 * d\n\tout[3] = scale * v4 * d\n\treturn out\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\nexport function transformMat4(out: vec4, a: ReadonlyVec4, m: ReadonlyVec4): vec4 {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2],\n\t\tw = a[3]\n\tout[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w\n\tout[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w\n\tout[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w\n\tout[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w\n\treturn out\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\nexport function transformQuat(out: vec4, a: ReadonlyVec4, q: ReadonlyQuat): vec4 {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2]\n\tconst qx = q[0],\n\t\tqy = q[1],\n\t\tqz = q[2],\n\t\tqw = q[3]\n\n\t// calculate quat * vec\n\tconst ix = qw * x + qy * z - qz * y\n\tconst iy = qw * y + qz * x - qx * z\n\tconst iz = qw * z + qx * y - qy * x\n\tconst iw = -qx * x - qy * y - qz * z\n\n\t// calculate result * inverse quat\n\tout[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n\tout[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n\tout[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nexport function zero(out: vec4): vec4 {\n\tout[0] = 0.0\n\tout[1] = 0.0\n\tout[2] = 0.0\n\tout[3] = 0.0\n\treturn out\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a: ReadonlyVec4): string {\n\treturn 'vec4(' + a[0].toString() + ', ' + a[1].toString() + ', ' + a[2].toString() + ', ' + a[3].toString() + ')'\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyVec4, b: ReadonlyVec4): bool {\n\treturn a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a: ReadonlyVec4, b: ReadonlyVec4): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3))\n\t)\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nexport const sub = subtract\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nexport const div = divide\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nexport const dist = distance\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nexport const len = length\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport * as mat3 from './_mat3'\nimport * as vec3 from './_vec3'\nimport * as vec4 from './_vec4'\n\nexport type quat = IndexedCollection;\n\nexport type ReadonlyQuat = IndexedCollection;\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create(): quat {\n\tconst out = new Float32Array(4)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[0] = 0\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t}\n\tout[3] = 1\n\treturn out\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out: quat): quat {\n\tout[0] = 0\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\treturn out\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out: quat, axis: vec3.ReadonlyVec3, rad: f32): quat {\n\trad = rad * 0.5\n\tconst s = Mathf.sin(rad)\n\tout[0] = s * axis[0]\n\tout[1] = s * axis[1]\n\tout[2] = s * axis[2]\n\tout[3] = Mathf.cos(rad)\n\treturn out\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis: vec3.vec3, q: ReadonlyQuat): f32 {\n\tconst rad = Mathf.acos(q[3]) * 2.0\n\tconst s = Mathf.sin(rad / 2.0)\n\tif (s > glMatrix.EPSILON) {\n\t\tout_axis[0] = q[0] / s\n\t\tout_axis[1] = q[1] / s\n\t\tout_axis[2] = q[2] / s\n\t} else {\n\t\t// If s is zero, return any axis (no rotation - axis does not matter)\n\t\tout_axis[0] = 1\n\t\tout_axis[1] = 0\n\t\tout_axis[2] = 0\n\t}\n\treturn rad\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a: ReadonlyQuat, b: ReadonlyQuat): f32 {\n\tconst dotproduct = dot(a, b)\n\n\treturn Mathf.acos(2 * dotproduct * dotproduct - 1)\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out: quat, a: ReadonlyQuat, b: ReadonlyQuat): quat {\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\tconst bx = b[0],\n\t\tby = b[1],\n\t\tbz = b[2],\n\t\tbw = b[3]\n\n\tout[0] = ax * bw + aw * bx + ay * bz - az * by\n\tout[1] = ay * bw + aw * by + az * bx - ax * bz\n\tout[2] = az * bw + aw * bz + ax * by - ay * bx\n\tout[3] = aw * bw - ax * bx - ay * by - az * bz\n\treturn out\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out: quat, a: ReadonlyQuat, rad: f32): quat {\n\trad *= 0.5\n\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\tconst bx = Mathf.sin(rad),\n\t\tbw = Mathf.cos(rad)\n\n\tout[0] = ax * bw + aw * bx\n\tout[1] = ay * bw + az * bx\n\tout[2] = az * bw - ay * bx\n\tout[3] = aw * bw - ax * bx\n\treturn out\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out: quat, a: ReadonlyQuat, rad: f32): quat {\n\trad *= 0.5\n\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\tconst by = Mathf.sin(rad),\n\t\tbw = Mathf.cos(rad)\n\n\tout[0] = ax * bw - az * by\n\tout[1] = ay * bw + aw * by\n\tout[2] = az * bw + ax * by\n\tout[3] = aw * bw - ay * by\n\treturn out\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out: quat, a: ReadonlyQuat, rad: f32): quat {\n\trad *= 0.5\n\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\tconst bz = Mathf.sin(rad),\n\t\tbw = Mathf.cos(rad)\n\n\tout[0] = ax * bw + ay * bz\n\tout[1] = ay * bw - ax * bz\n\tout[2] = az * bw + aw * bz\n\tout[3] = aw * bw - az * bz\n\treturn out\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out: quat, a: ReadonlyQuat): quat {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2]\n\n\tout[0] = x\n\tout[1] = y\n\tout[2] = z\n\tout[3] = Mathf.sqrt(Mathf.abs(1.0 - x * x - y * y - z * z))\n\treturn out\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out: quat, a: ReadonlyQuat): quat {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2],\n\t\tw = a[3]\n\n\tconst r = Mathf.sqrt(x * x + y * y + z * z)\n\tconst et = Mathf.exp(w)\n\tconst s = r > 0 ? (et * Mathf.sin(r)) / r : 0\n\n\tout[0] = x * s\n\tout[1] = y * s\n\tout[2] = z * s\n\tout[3] = et * Mathf.cos(r)\n\n\treturn out\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out: quat, a: ReadonlyQuat): quat {\n\tconst x = a[0],\n\t\ty = a[1],\n\t\tz = a[2],\n\t\tw = a[3]\n\n\tconst r = Mathf.sqrt(x * x + y * y + z * z)\n\tconst t = r > 0 ? Mathf.atan2(r, w) / r : 0\n\n\tout[0] = x * t\n\tout[1] = y * t\n\tout[2] = z * t\n\tout[3] = 0.5 * Mathf.log(x * x + y * y + z * z + w * w)\n\n\treturn out\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out: quat, a: ReadonlyQuat, b: f32): quat {\n\tln(out, a)\n\tscale(out, out, b)\n\texp(out, out)\n\treturn out\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out: quat, a: ReadonlyQuat, b: ReadonlyQuat, t: f32): quat {\n\t// benchmarks:\n\t//    http://jsperf.com/quaternion-slerp-implementations\n\tconst ax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\tlet bx = b[0],\n\t\tby = b[1],\n\t\tbz = b[2],\n\t\tbw = b[3]\n\n\tlet omega: f32, cosom: f32, sinom: f32, scale0: f32, scale1: f32\n\n\t// calc cosine\n\tcosom = ax * bx + ay * by + az * bz + aw * bw\n\t// adjust signs (if necessary)\n\tif (cosom < 0.0) {\n\t\tcosom = -cosom\n\t\tbx = -bx\n\t\tby = -by\n\t\tbz = -bz\n\t\tbw = -bw\n\t}\n\t// calculate coefficients\n\tif (1.0 - cosom > glMatrix.EPSILON) {\n\t\t// standard case (slerp)\n\t\tomega = Mathf.acos(cosom)\n\t\tsinom = Mathf.sin(omega)\n\t\tscale0 = Mathf.sin((1.0 - t) * omega) / sinom\n\t\tscale1 = Mathf.sin(t * omega) / sinom\n\t} else {\n\t\t// \"from\" and \"to\" quaternions are very close\n\t\t//  ... so we can do a linear interpolation\n\t\tscale0 = 1.0 - t\n\t\tscale1 = t\n\t}\n\t// calculate final values\n\tout[0] = scale0 * ax + scale1 * bx\n\tout[1] = scale0 * ay + scale1 * by\n\tout[2] = scale0 * az + scale1 * bz\n\tout[3] = scale0 * aw + scale1 * bw\n\n\treturn out\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out: quat): quat {\n\t// Implementation of http://planning.cs.uiuc.edu/node198.html\n\t// TODO: Calling random 3 times is probably not the fastest solution\n\tconst u1 = glMatrix.RANDOM()\n\tconst u2 = glMatrix.RANDOM()\n\tconst u3 = glMatrix.RANDOM()\n\n\tconst sqrt1MinusU1 = Mathf.sqrt(1 - u1)\n\tconst sqrtU1 = Mathf.sqrt(u1)\n\n\tout[0] = sqrt1MinusU1 * Mathf.sin(2.0 * Mathf.PI * u2)\n\tout[1] = sqrt1MinusU1 * Mathf.cos(2.0 * Mathf.PI * u2)\n\tout[2] = sqrtU1 * Mathf.sin(2.0 * Mathf.PI * u3)\n\tout[3] = sqrtU1 * Mathf.cos(2.0 * Mathf.PI * u3)\n\treturn out\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out: quat, a: ReadonlyQuat): quat {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3\n\tconst invDot = dot ? <f32>1.0 / dot : <f32>0\n\n\t// TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n\tout[0] = -a0 * invDot\n\tout[1] = -a1 * invDot\n\tout[2] = -a2 * invDot\n\tout[3] = a3 * invDot\n\treturn out\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out: quat, a: ReadonlyQuat): quat {\n\tout[0] = -a[0]\n\tout[1] = -a[1]\n\tout[2] = -a[2]\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out: quat, m: mat3.ReadonlyMat3): quat {\n\t// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n\t// article \"Quaternion Calculus and Fast Animation\".\n\tconst fTrace = m[0] + m[4] + m[8]\n\tlet fRoot: f32\n\n\tif (fTrace > 0.0) {\n\t\t// |w| > 1/2, may as well choose w > 1/2\n\t\tfRoot = Mathf.sqrt(fTrace + 1.0) // 2w\n\t\tout[3] = 0.5 * fRoot\n\t\tfRoot = 0.5 / fRoot // 1/(4w)\n\t\tout[0] = (m[5] - m[7]) * fRoot\n\t\tout[1] = (m[6] - m[2]) * fRoot\n\t\tout[2] = (m[1] - m[3]) * fRoot\n\t} else {\n\t\t// |w| <= 1/2\n\t\tlet i = 0\n\t\tif (m[4] > m[0]) i = 1\n\t\tif (m[8] > m[i * 3 + i]) i = 2\n\t\tconst j = (i + 1) % 3\n\t\tconst k = (i + 2) % 3\n\n\t\tfRoot = Mathf.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0)\n\t\tout[i] = 0.5 * fRoot\n\t\tfRoot = 0.5 / fRoot\n\t\tout[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot\n\t\tout[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot\n\t\tout[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot\n\t}\n\n\treturn out\n}\n\ntype x = f32;\ntype y = f32;\ntype z = f32;\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} x Angle to rotate around X axis in degrees.\n * @param {y} y Angle to rotate around Y axis in degrees.\n * @param {z} z Angle to rotate around Z axis in degrees.\n * @param {'zyx'|'xyz'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out: quat, x: x, y: y, z: z, order: string = glMatrix.ANGLE_ORDER): quat {\n\tconst halfToRad = Mathf.PI / 360\n\tx *= halfToRad\n\tz *= halfToRad\n\ty *= halfToRad\n\n\tconst sx = Mathf.sin(x)\n\tconst cx = Mathf.cos(x)\n\tconst sy = Mathf.sin(y)\n\tconst cy = Mathf.cos(y)\n\tconst sz = Mathf.sin(z)\n\tconst cz = Mathf.cos(z)\n\n\tif (order === 'xyz') {\n\t\tout[0] = sx * cy * cz + cx * sy * sz\n\t\tout[1] = cx * sy * cz - sx * cy * sz\n\t\tout[2] = cx * cy * sz + sx * sy * cz\n\t\tout[3] = cx * cy * cz - sx * sy * sz\n\t} else if (order === 'xzy') {\n\t\tout[0] = sx * cy * cz - cx * sy * sz\n\t\tout[1] = cx * sy * cz - sx * cy * sz\n\t\tout[2] = cx * cy * sz + sx * sy * cz\n\t\tout[3] = cx * cy * cz + sx * sy * sz\n\t} else if (order === 'yxz') {\n\t\tout[0] = sx * cy * cz + cx * sy * sz\n\t\tout[1] = cx * sy * cz - sx * cy * sz\n\t\tout[2] = cx * cy * sz - sx * sy * cz\n\t\tout[3] = cx * cy * cz + sx * sy * sz\n\t} else if (order === 'yzx') {\n\t\tout[0] = sx * cy * cz + cx * sy * sz\n\t\tout[1] = cx * sy * cz + sx * cy * sz\n\t\tout[2] = cx * cy * sz - sx * sy * cz\n\t\tout[3] = cx * cy * cz - sx * sy * sz\n\t} else if (order === 'zxy') {\n\t\tout[0] = sx * cy * cz - cx * sy * sz\n\t\tout[1] = cx * sy * cz + sx * cy * sz\n\t\tout[2] = cx * cy * sz + sx * sy * cz\n\t\tout[3] = cx * cy * cz - sx * sy * sz\n\t} else if (order === 'zyx') {\n\t\tout[0] = sx * cy * cz - cx * sy * sz\n\t\tout[1] = cx * sy * cz + sx * cy * sz\n\t\tout[2] = cx * cy * sz - sx * sy * cz\n\t\tout[3] = cx * cy * cz + sx * sy * sz\n\t} else throw new Error('Unknown angle order ' + order)\n\n\treturn out\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a: ReadonlyQuat): string {\n\treturn 'quat(' + a[0].toString() + ', ' + a[1].toString() + ', ' + a[2].toString() + ', ' + a[3].toString() + ')'\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport const clone = vec4.clone\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport const fromValues = vec4.fromValues\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport const len = length\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport const squaredLength = vec4.squaredLength\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport const exactEquals = vec4.exactEquals\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a: ReadonlyQuat, b: ReadonlyQuat): bool {\n\treturn Mathf.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nconst tmpvec3 = vec3.create()\nconst xUnitVec3 = vec3.fromValues(1, 0, 0)\nconst yUnitVec3 = vec3.fromValues(0, 1, 0)\nexport const rotationTo = ((): (out: quat, a: ReadonlyQuat, b: ReadonlyQuat) => quat => {\n\n\treturn function (out: quat, a: ReadonlyQuat, b: ReadonlyQuat) {\n\t\tconst dot = vec3.dot(a, b)\n\t\tif (dot < -0.999999) {\n\t\t\tvec3.cross(tmpvec3, xUnitVec3, a)\n\t\t\tif (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a)\n\t\t\tvec3.normalize(tmpvec3, tmpvec3)\n\t\t\tsetAxisAngle(out, tmpvec3, Mathf.PI)\n\t\t\treturn out\n\t\t} else if (dot > 0.999999) {\n\t\t\tout[0] = 0\n\t\t\tout[1] = 0\n\t\t\tout[2] = 0\n\t\t\tout[3] = 1\n\t\t\treturn out\n\t\t} else {\n\t\t\tvec3.cross(tmpvec3, a, b)\n\t\t\tout[0] = tmpvec3[0]\n\t\t\tout[1] = tmpvec3[1]\n\t\t\tout[2] = tmpvec3[2]\n\t\t\tout[3] = 1 + dot\n\t\t\treturn normalize(out, out)\n\t\t}\n\t}\n})()\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nconst temp1 = create()\nconst temp2 = create()\nexport const sqlerp = ((): (out: quat, a: ReadonlyQuat, b: ReadonlyQuat, c: ReadonlyQuat, d: ReadonlyQuat, t: f32) => quat => {\n\n\treturn function (out: quat, a: ReadonlyQuat, b: ReadonlyQuat, c: ReadonlyQuat, d: ReadonlyQuat, t: f32) {\n\t\tslerp(temp1, a, d, t)\n\t\tslerp(temp2, b, c, t)\n\t\tslerp(out, temp1, temp2, 2 * t * (1 - t))\n\n\t\treturn out\n\t}\n})()\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nconst matr = mat3.create()\nexport const setAxes = ((): (out: quat, view: vec3.ReadonlyVec3, right: vec3.ReadonlyVec3, up: vec3.ReadonlyVec3) => quat => {\n\n\treturn function (out: quat, view: vec3.ReadonlyVec3, right: vec3.ReadonlyVec3, up: vec3.ReadonlyVec3) {\n\t\tmatr[0] = right[0]\n\t\tmatr[3] = right[1]\n\t\tmatr[6] = right[2]\n\n\t\tmatr[1] = up[0]\n\t\tmatr[4] = up[1]\n\t\tmatr[7] = up[2]\n\n\t\tmatr[2] = -view[0]\n\t\tmatr[5] = -view[1]\n\t\tmatr[8] = -view[2]\n\n\t\treturn normalize(out, fromMat3(out, matr))\n\t}\n})()\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyMat2 } from './_mat2'\nimport { ReadonlyMat4 } from './_mat4'\nimport { ReadonlyVec2 } from './_vec2'\n\nexport type ReadonlyQuat = IndexedCollection;\n\nexport type mat3 = IndexedCollection;\n\nexport type ReadonlyMat3 = IndexedCollection;\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nexport function create(): mat3 {\n\tconst out = new Float32Array(9)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t\tout[3] = 0\n\t\tout[5] = 0\n\t\tout[6] = 0\n\t\tout[7] = 0\n\t}\n\tout[0] = 1\n\tout[4] = 1\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out: mat3, a: ReadonlyMat4): mat3 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[4]\n\tout[4] = a[5]\n\tout[5] = a[6]\n\tout[6] = a[8]\n\tout[7] = a[9]\n\tout[8] = a[10]\n\treturn out\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nexport function clone(a: ReadonlyMat3): mat3 {\n\tconst out = new Float32Array(9)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\tout[6] = a[6]\n\tout[7] = a[7]\n\tout[8] = a[8]\n\treturn out\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out: mat3, a: ReadonlyMat3): mat3 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\tout[6] = a[6]\n\tout[7] = a[7]\n\tout[8] = a[8]\n\treturn out\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nexport function fromValues(m00: f32, m01: f32, m02: f32, m10: f32, m11: f32, m12: f32, m20: f32, m21: f32, m22: f32): mat3 {\n\tconst out = new Float32Array(9)\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m02\n\tout[3] = m10\n\tout[4] = m11\n\tout[5] = m12\n\tout[6] = m20\n\tout[7] = m21\n\tout[8] = m22\n\treturn out\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nexport function set(out: mat3, m00: f32, m01: f32, m02: f32, m10: f32, m11: f32, m12: f32, m20: f32, m21: f32, m22: f32): mat3 {\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m02\n\tout[3] = m10\n\tout[4] = m11\n\tout[5] = m12\n\tout[6] = m20\n\tout[7] = m21\n\tout[8] = m22\n\treturn out\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out: mat3): mat3 {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 1\n\tout[5] = 0\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out: mat3, a: ReadonlyMat3): mat3 {\n\t// If we are transposing ourselves we can skip a few steps but have to cache some values\n\tif (out === a) {\n\t\tconst a01 = a[1],\n\t\t\ta02 = a[2],\n\t\t\ta12 = a[5]\n\t\tout[1] = a[3]\n\t\tout[2] = a[6]\n\t\tout[3] = a01\n\t\tout[5] = a[7]\n\t\tout[6] = a02\n\t\tout[7] = a12\n\t} else {\n\t\tout[0] = a[0]\n\t\tout[1] = a[3]\n\t\tout[2] = a[6]\n\t\tout[3] = a[1]\n\t\tout[4] = a[4]\n\t\tout[5] = a[7]\n\t\tout[6] = a[2]\n\t\tout[7] = a[5]\n\t\tout[8] = a[8]\n\t}\n\n\treturn out\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out: mat3, a: ReadonlyMat3): mat3 | null {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2]\n\tconst a10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5]\n\tconst a20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8]\n\n\tconst b01 = a22 * a11 - a12 * a21\n\tconst b11 = -a22 * a10 + a12 * a20\n\tconst b21 = a21 * a10 - a11 * a20\n\n\t// Calculate the determinant\n\tlet det = a00 * b01 + a01 * b11 + a02 * b21\n\n\tif (!det) {\n\t\treturn null\n\t}\n\tdet = 1.0 / det\n\n\tout[0] = b01 * det\n\tout[1] = (-a22 * a01 + a02 * a21) * det\n\tout[2] = (a12 * a01 - a02 * a11) * det\n\tout[3] = b11 * det\n\tout[4] = (a22 * a00 - a02 * a20) * det\n\tout[5] = (-a12 * a00 + a02 * a10) * det\n\tout[6] = b21 * det\n\tout[7] = (-a21 * a00 + a01 * a20) * det\n\tout[8] = (a11 * a00 - a01 * a10) * det\n\treturn out\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function adjoint(out: mat3, a: ReadonlyMat3): mat3 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2]\n\tconst a10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5]\n\tconst a20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8]\n\n\tout[0] = a11 * a22 - a12 * a21\n\tout[1] = a02 * a21 - a01 * a22\n\tout[2] = a01 * a12 - a02 * a11\n\tout[3] = a12 * a20 - a10 * a22\n\tout[4] = a00 * a22 - a02 * a20\n\tout[5] = a02 * a10 - a00 * a12\n\tout[6] = a10 * a21 - a11 * a20\n\tout[7] = a01 * a20 - a00 * a21\n\tout[8] = a00 * a11 - a01 * a10\n\treturn out\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a: ReadonlyMat3): f32 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2]\n\tconst a10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5]\n\tconst a20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8]\n\n\treturn (\n\t\ta00 * (a22 * a11 - a12 * a21) +\n    a01 * (-a22 * a10 + a12 * a20) +\n    a02 * (a21 * a10 - a11 * a20)\n\t)\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2]\n\tconst a10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5]\n\tconst a20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8]\n\n\tconst b00 = b[0],\n\t\tb01 = b[1],\n\t\tb02 = b[2]\n\tconst b10 = b[3],\n\t\tb11 = b[4],\n\t\tb12 = b[5]\n\tconst b20 = b[6],\n\t\tb21 = b[7],\n\t\tb22 = b[8]\n\n\tout[0] = b00 * a00 + b01 * a10 + b02 * a20\n\tout[1] = b00 * a01 + b01 * a11 + b02 * a21\n\tout[2] = b00 * a02 + b01 * a12 + b02 * a22\n\n\tout[3] = b10 * a00 + b11 * a10 + b12 * a20\n\tout[4] = b10 * a01 + b11 * a11 + b12 * a21\n\tout[5] = b10 * a02 + b11 * a12 + b12 * a22\n\n\tout[6] = b20 * a00 + b21 * a10 + b22 * a20\n\tout[7] = b20 * a01 + b21 * a11 + b22 * a21\n\tout[8] = b20 * a02 + b21 * a12 + b22 * a22\n\treturn out\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out: mat3, a: ReadonlyMat3, v: ReadonlyVec2): mat3 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5],\n\t\ta20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8],\n\t\tx = v[0],\n\t\ty = v[1]\n\n\tout[0] = a00\n\tout[1] = a01\n\tout[2] = a02\n\n\tout[3] = a10\n\tout[4] = a11\n\tout[5] = a12\n\n\tout[6] = x * a00 + y * a10 + a20\n\tout[7] = x * a01 + y * a11 + a21\n\tout[8] = x * a02 + y * a12 + a22\n\treturn out\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out: mat3, a: ReadonlyMat3, rad: f32): mat3 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta10 = a[3],\n\t\ta11 = a[4],\n\t\ta12 = a[5],\n\t\ta20 = a[6],\n\t\ta21 = a[7],\n\t\ta22 = a[8],\n\t\ts = Mathf.sin(rad),\n\t\tc = Mathf.cos(rad)\n\n\tout[0] = c * a00 + s * a10\n\tout[1] = c * a01 + s * a11\n\tout[2] = c * a02 + s * a12\n\n\tout[3] = c * a10 - s * a00\n\tout[4] = c * a11 - s * a01\n\tout[5] = c * a12 - s * a02\n\n\tout[6] = a20\n\tout[7] = a21\n\tout[8] = a22\n\treturn out\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out: mat3, a: ReadonlyMat3, v: ReadonlyVec2): mat3 {\n\tconst x = v[0],\n\t\ty = v[1]\n\n\tout[0] = x * a[0]\n\tout[1] = x * a[1]\n\tout[2] = x * a[2]\n\n\tout[3] = y * a[3]\n\tout[4] = y * a[4]\n\tout[5] = y * a[5]\n\n\tout[6] = a[6]\n\tout[7] = a[7]\n\tout[8] = a[8]\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\nexport function fromTranslation(out: mat3, v: ReadonlyVec2): mat3 {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 1\n\tout[5] = 0\n\tout[6] = v[0]\n\tout[7] = v[1]\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function fromRotation(out: mat3, rad: f32): mat3 {\n\tconst s = Mathf.sin(rad),\n\t\tc = Mathf.cos(rad)\n\n\tout[0] = c\n\tout[1] = s\n\tout[2] = 0\n\n\tout[3] = -s\n\tout[4] = c\n\tout[5] = 0\n\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\nexport function fromScaling(out: mat3, v: ReadonlyMat3): mat3 {\n\tout[0] = v[0]\n\tout[1] = 0\n\tout[2] = 0\n\n\tout[3] = 0\n\tout[4] = v[1]\n\tout[5] = 0\n\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nexport function fromMat2d(out: mat3, a: ReadonlyMat2): mat3 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = 0\n\n\tout[3] = a[2]\n\tout[4] = a[3]\n\tout[5] = 0\n\n\tout[6] = a[4]\n\tout[7] = a[5]\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out: mat3, q: ReadonlyQuat): mat3 {\n\tconst x = q[0],\n\t\ty = q[1],\n\t\tz = q[2],\n\t\tw = q[3]\n\tconst x2 = x + x\n\tconst y2 = y + y\n\tconst z2 = z + z\n\n\tconst xx = x * x2\n\tconst yx = y * x2\n\tconst yy = y * y2\n\tconst zx = z * x2\n\tconst zy = z * y2\n\tconst zz = z * z2\n\tconst wx = w * x2\n\tconst wy = w * y2\n\tconst wz = w * z2\n\n\tout[0] = 1 - yy - zz\n\tout[3] = yx - wz\n\tout[6] = zx + wy\n\n\tout[1] = yx + wz\n\tout[4] = 1 - xx - zz\n\tout[7] = zy - wx\n\n\tout[2] = zx - wy\n\tout[5] = zy + wx\n\tout[8] = 1 - xx - yy\n\n\treturn out\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out: mat3, a: ReadonlyMat4): mat3 | null {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta03 = a[3]\n\tconst a10 = a[4],\n\t\ta11 = a[5],\n\t\ta12 = a[6],\n\t\ta13 = a[7]\n\tconst a20 = a[8],\n\t\ta21 = a[9],\n\t\ta22 = a[10],\n\t\ta23 = a[11]\n\tconst a30 = a[12],\n\t\ta31 = a[13],\n\t\ta32 = a[14],\n\t\ta33 = a[15]\n\n\tconst b00 = a00 * a11 - a01 * a10\n\tconst b01 = a00 * a12 - a02 * a10\n\tconst b02 = a00 * a13 - a03 * a10\n\tconst b03 = a01 * a12 - a02 * a11\n\tconst b04 = a01 * a13 - a03 * a11\n\tconst b05 = a02 * a13 - a03 * a12\n\tconst b06 = a20 * a31 - a21 * a30\n\tconst b07 = a20 * a32 - a22 * a30\n\tconst b08 = a20 * a33 - a23 * a30\n\tconst b09 = a21 * a32 - a22 * a31\n\tconst b10 = a21 * a33 - a23 * a31\n\tconst b11 = a22 * a33 - a23 * a32\n\n\t// Calculate the determinant\n\tlet det =\n    b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06\n\n\tif (!det) {\n\t\treturn null\n\t}\n\tdet = 1.0 / det\n\n\tout[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det\n\tout[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det\n\tout[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det\n\n\tout[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det\n\tout[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det\n\tout[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det\n\n\tout[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det\n\tout[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det\n\tout[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det\n\n\treturn out\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out: mat3, width: f32, height: f32): mat3 {\n\tout[0] = 2 / width\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = -2 / height\n\tout[5] = 0\n\tout[6] = -1\n\tout[7] = 1\n\tout[8] = 1\n\treturn out\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a: ReadonlyMat3): string {\n\treturn (\n\t\t'mat3(' +\n    a[0].toString() +\n    ', ' +\n    a[1].toString() +\n    ', ' +\n    a[2].toString() +\n    ', ' +\n    a[3].toString() +\n    ', ' +\n    a[4].toString() +\n    ', ' +\n    a[5].toString() +\n    ', ' +\n    a[6].toString() +\n    ', ' +\n    a[7].toString() +\n    ', ' +\n    a[8].toString() +\n    ')'\n\t)\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a: ReadonlyMat3): f32 {\n\treturn Maths.hypot9(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\tout[4] = a[4] + b[4]\n\tout[5] = a[5] + b[5]\n\tout[6] = a[6] + b[6]\n\tout[7] = a[7] + b[7]\n\tout[8] = a[8] + b[8]\n\treturn out\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\tout[3] = a[3] - b[3]\n\tout[4] = a[4] - b[4]\n\tout[5] = a[5] - b[5]\n\tout[6] = a[6] - b[6]\n\tout[7] = a[7] - b[7]\n\tout[8] = a[8] - b[8]\n\treturn out\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out: mat3, a: ReadonlyMat3, b: f32): mat3 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\tout[4] = a[4] * b\n\tout[5] = a[5] * b\n\tout[6] = a[6] * b\n\tout[7] = a[7] * b\n\tout[8] = a[8] * b\n\treturn out\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nexport function multiplyScalarAndAdd(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3, scale: f32): mat3 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\tout[3] = a[3] + b[3] * scale\n\tout[4] = a[4] + b[4] * scale\n\tout[5] = a[5] + b[5] * scale\n\tout[6] = a[6] + b[6] * scale\n\tout[7] = a[7] + b[7] * scale\n\tout[8] = a[8] + b[8] * scale\n\treturn out\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyMat3, b: ReadonlyMat3): bool {\n\treturn (\n\t\ta[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5] &&\n    a[6] === b[6] &&\n    a[7] === b[7] &&\n    a[8] === b[8]\n\t)\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a: ReadonlyMat3, b: ReadonlyMat3): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5],\n\t\ta6 = a[6],\n\t\ta7 = a[7],\n\t\ta8 = a[8]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3],\n\t\tb4 = b[4],\n\t\tb5 = b[5],\n\t\tb6 = b[6],\n\t\tb7 = b[7],\n\t\tb8 = b[8]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3)) &&\n    Mathf.abs(a4 - b4) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a4), Mathf.abs(b4)) &&\n    Mathf.abs(a5 - b5) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a5), Mathf.abs(b5)) &&\n    Mathf.abs(a6 - b6) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a6), Mathf.abs(b6)) &&\n    Mathf.abs(a7 - b7) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a7), Mathf.abs(b7)) &&\n    Mathf.abs(a8 - b8) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a8), Mathf.abs(b8))\n\t)\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nexport const sub = subtract\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport * as mat4 from './_mat4'\nimport * as quat from './_quat'\nimport * as vec3 from './_vec3'\n\nexport type quat2 = IndexedCollection;\n\nexport type ReadonlyQuat2 = IndexedCollection;\n\n/**\n * Dual Quaternion<br>\n * Format: [real, dual]<br>\n * Quaternion format: XYZW<br>\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\n * @module quat2\n */\n\n/**\n * Creates a new identity dual quat\n *\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\n */\nexport function create(): quat2 {\n\tconst dq = changetype<IndexedCollection>(new Float32Array(8))\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tdq[0] = 0\n\t\tdq[1] = 0\n\t\tdq[2] = 0\n\t\tdq[4] = 0\n\t\tdq[5] = 0\n\t\tdq[6] = 0\n\t\tdq[7] = 0\n\t}\n\tdq[3] = 1\n\treturn dq\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat2} a dual quaternion to clone\n * @returns {quat2} new dual quaternion\n * @function\n */\nexport function clone(a: ReadonlyQuat2): quat2 {\n\tconst dq = changetype<IndexedCollection>(new Float32Array(8))\n\tdq[0] = a[0]\n\tdq[1] = a[1]\n\tdq[2] = a[2]\n\tdq[3] = a[3]\n\tdq[4] = a[4]\n\tdq[5] = a[5]\n\tdq[6] = a[6]\n\tdq[7] = a[7]\n\treturn dq\n}\n\n/**\n * Creates a new dual quat initialized with the given values\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} new dual quaternion\n * @function\n */\nexport function fromValues(x1: f32, y1: f32, z1: f32, w1: f32, x2: f32, y2: f32, z2: f32, w2: f32): quat2 {\n\tconst dq = changetype<IndexedCollection>(new Float32Array(8))\n\tdq[0] = x1\n\tdq[1] = y1\n\tdq[2] = z1\n\tdq[3] = w1\n\tdq[4] = x2\n\tdq[5] = y2\n\tdq[6] = z2\n\tdq[7] = w2\n\treturn dq\n}\n\n/**\n * Creates a new dual quat from the given values (quat and translation)\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component (translation)\n * @param {Number} y2 Y component (translation)\n * @param {Number} z2 Z component (translation)\n * @returns {quat2} new dual quaternion\n * @function\n */\nexport function fromRotationTranslationValues(x1: f32, y1: f32, z1: f32, w1: f32, x2: f32, y2: f32, z2: f32): quat2 {\n\tconst dq = changetype<IndexedCollection>(new Float32Array(8))\n\tdq[0] = x1\n\tdq[1] = y1\n\tdq[2] = z1\n\tdq[3] = w1\n\tconst ax = x2 * 0.5,\n\t\tay = y2 * 0.5,\n\t\taz = z2 * 0.5\n\tdq[4] = ax * w1 + ay * z1 - az * y1\n\tdq[5] = ay * w1 + az * x1 - ax * z1\n\tdq[6] = az * w1 + ax * y1 - ay * x1\n\tdq[7] = -ax * x1 - ay * y1 - az * z1\n\treturn dq\n}\n\n/**\n * Creates a dual quat from a quaternion and a translation\n *\n * @param {quat2} out quaternion receiving operation result\n * @param {ReadonlyQuat} q a normalized quaternion\n * @param {ReadonlyVec3} t translation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nexport function fromRotationTranslation(out: quat2, q: quat.ReadonlyQuat, t: vec3.ReadonlyVec3): quat2 {\n\tconst ax = t[0] * 0.5,\n\t\tay = t[1] * 0.5,\n\t\taz = t[2] * 0.5,\n\t\tbx = q[0],\n\t\tby = q[1],\n\t\tbz = q[2],\n\t\tbw = q[3]\n\tout[0] = bx\n\tout[1] = by\n\tout[2] = bz\n\tout[3] = bw\n\tout[4] = ax * bw + ay * bz - az * by\n\tout[5] = ay * bw + az * bx - ax * bz\n\tout[6] = az * bw + ax * by - ay * bx\n\tout[7] = -ax * bx - ay * by - az * bz\n\treturn out\n}\n\n/**\n * Creates a dual quat from a translation\n *\n * @param {quat2} out quaternion receiving operation result\n * @param {ReadonlyVec3} t translation vector\n * @returns {quat2} out quaternion receiving operation result\n * @function\n */\nexport function fromTranslation(out: quat2, t: vec3.ReadonlyVec3): quat2 {\n\tout[0] = 0\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\tout[4] = t[0] * 0.5\n\tout[5] = t[1] * 0.5\n\tout[6] = t[2] * 0.5\n\tout[7] = 0\n\treturn out\n}\n\n/**\n * Creates a dual quat from a quaternion\n *\n * @param {quat2} out quaternion receiving operation result\n * @param {ReadonlyQuat} q the quaternion\n * @returns {quat2} out quaternion receiving operation result\n * @function\n */\nexport function fromRotation(out: quat2, q: quat.ReadonlyQuat): quat2 {\n\tout[0] = q[0]\n\tout[1] = q[1]\n\tout[2] = q[2]\n\tout[3] = q[3]\n\tout[4] = 0\n\tout[5] = 0\n\tout[6] = 0\n\tout[7] = 0\n\treturn out\n}\n\n/**\n * Creates a new dual quat from a matrix (4x4)\n *\n * @param {quat2} out the dual quaternion\n * @param {ReadonlyMat4} a the matrix\n * @returns {quat2} dual quat receiving operation result\n * @function\n */\nexport function fromMat4(out: quat2, a: mat4.ReadonlyMat4): quat2 {\n\t//TODO Optimize this\n\tconst outer = quat.create()\n\tmat4.getRotation(outer, a)\n\tconst t = new Float32Array(3)\n\tmat4.getTranslation(t, a)\n\tfromRotationTranslation(out, outer, t)\n\treturn out\n}\n\n/**\n * Copy the values from one dual quat to another\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the source dual quaternion\n * @returns {quat2} out\n * @function\n */\nexport function copy(out: quat2, a: ReadonlyQuat2): quat2 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\tout[6] = a[6]\n\tout[7] = a[7]\n\treturn out\n}\n\n/**\n * Set a dual quat to the identity dual quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @returns {quat2} out\n */\nexport function identity(out: quat2): quat2 {\n\tout[0] = 0\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\tout[4] = 0\n\tout[5] = 0\n\tout[6] = 0\n\tout[7] = 0\n\treturn out\n}\n\n/**\n * Set the components of a dual quat to the given values\n *\n * @param {quat2} out the receiving quaternion\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} out\n * @function\n */\nexport function set(out: quat2, x1: f32, y1: f32, z1: f32, w1: f32, x2: f32, y2: f32, z2: f32, w2: f32): quat2 {\n\tout[0] = x1\n\tout[1] = y1\n\tout[2] = z1\n\tout[3] = w1\n\n\tout[4] = x2\n\tout[5] = y2\n\tout[6] = z2\n\tout[7] = w2\n\treturn out\n}\n\n/**\n * Gets the real part of a dual quat\n * @param  {quat} out real part\n * @param  {ReadonlyQuat2} a Dual Quaternion\n * @return {quat} real part\n */\nexport const getReal = quat.copy\n\n/**\n * Gets the dual part of a dual quat\n * @param  {quat} out dual part\n * @param  {ReadonlyQuat2} a Dual Quaternion\n * @return {quat} dual part\n */\nexport function getDual(out: quat.quat, a: ReadonlyQuat2): quat.quat {\n\tout[0] = a[4]\n\tout[1] = a[5]\n\tout[2] = a[6]\n\tout[3] = a[7]\n\treturn out\n}\n\n/**\n * Set the real component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat} q a quaternion representing the real part\n * @returns {quat2} out\n * @function\n */\nexport const setReal = quat.copy\n\n/**\n * Set the dual component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat} q a quaternion representing the dual part\n * @returns {quat2} out\n * @function\n */\nexport function setDual(out: quat2, q: quat.ReadonlyQuat): quat2 {\n\tout[4] = q[0]\n\tout[5] = q[1]\n\tout[6] = q[2]\n\tout[7] = q[3]\n\treturn out\n}\n\n/**\n * Gets the translation of a normalized dual quat\n * @param  {vec3} out translation\n * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed\n * @return {vec3} translation\n */\nexport function getTranslation(out: vec3.vec3, a: ReadonlyQuat2): vec3.vec3 {\n\tconst ax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7],\n\t\tbx = -a[0],\n\t\tby = -a[1],\n\t\tbz = -a[2],\n\t\tbw = a[3]\n\tout[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2\n\tout[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2\n\tout[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2\n\treturn out\n}\n\n/**\n * Translates a dual quat by the given vector\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {quat2} out\n */\nexport function translate(out: quat2, a: ReadonlyQuat2, v: vec3.ReadonlyVec3): quat2 {\n\tconst ax1 = a[0],\n\t\tay1 = a[1],\n\t\taz1 = a[2],\n\t\taw1 = a[3],\n\t\tbx1 = v[0] * 0.5,\n\t\tby1 = v[1] * 0.5,\n\t\tbz1 = v[2] * 0.5,\n\t\tax2 = a[4],\n\t\tay2 = a[5],\n\t\taz2 = a[6],\n\t\taw2 = a[7]\n\tout[0] = ax1\n\tout[1] = ay1\n\tout[2] = az1\n\tout[3] = aw1\n\tout[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2\n\tout[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2\n\tout[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2\n\tout[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2\n\treturn out\n}\n\n/**\n * Rotates a dual quat around the X axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nexport function rotateX(out: quat2, a: ReadonlyQuat2, rad: f32): quat2 {\n\tlet bx = -a[0],\n\t\tby = -a[1],\n\t\tbz = -a[2],\n\t\tbw = a[3],\n\t\tax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7],\n\t\tax1 = ax * bw + aw * bx + ay * bz - az * by,\n\t\tay1 = ay * bw + aw * by + az * bx - ax * bz,\n\t\taz1 = az * bw + aw * bz + ax * by - ay * bx,\n\t\taw1 = aw * bw - ax * bx - ay * by - az * bz\n\tquat.rotateX(out, a, rad)\n\tbx = out[0]\n\tby = out[1]\n\tbz = out[2]\n\tbw = out[3]\n\tout[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by\n\tout[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz\n\tout[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx\n\tout[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz\n\treturn out\n}\n\n/**\n * Rotates a dual quat around the Y axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nexport function rotateY(out: quat2, a: ReadonlyQuat2, rad: f32): quat2 {\n\tlet bx = -a[0],\n\t\tby = -a[1],\n\t\tbz = -a[2],\n\t\tbw = a[3],\n\t\tax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7],\n\t\tax1 = ax * bw + aw * bx + ay * bz - az * by,\n\t\tay1 = ay * bw + aw * by + az * bx - ax * bz,\n\t\taz1 = az * bw + aw * bz + ax * by - ay * bx,\n\t\taw1 = aw * bw - ax * bx - ay * by - az * bz\n\tquat.rotateY(out, a, rad)\n\tbx = out[0]\n\tby = out[1]\n\tbz = out[2]\n\tbw = out[3]\n\tout[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by\n\tout[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz\n\tout[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx\n\tout[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz\n\treturn out\n}\n\n/**\n * Rotates a dual quat around the Z axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nexport function rotateZ(out: quat2, a: ReadonlyQuat2, rad: f32): quat2 {\n\tlet bx = -a[0],\n\t\tby = -a[1],\n\t\tbz = -a[2],\n\t\tbw = a[3],\n\t\tax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7],\n\t\tax1 = ax * bw + aw * bx + ay * bz - az * by,\n\t\tay1 = ay * bw + aw * by + az * bx - ax * bz,\n\t\taz1 = az * bw + aw * bz + ax * by - ay * bx,\n\t\taw1 = aw * bw - ax * bx - ay * by - az * bz\n\tquat.rotateZ(out, a, rad)\n\tbx = out[0]\n\tby = out[1]\n\tbz = out[2]\n\tbw = out[3]\n\tout[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by\n\tout[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz\n\tout[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx\n\tout[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz\n\treturn out\n}\n\n/**\n * Rotates a dual quat by a given quaternion (a * q)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {ReadonlyQuat} q quaternion to rotate by\n * @returns {quat2} out\n */\nexport function rotateByQuatAppend(out: quat2, a: ReadonlyQuat2, q: quat.ReadonlyQuat): quat2 {\n\tlet qx = q[0],\n\t\tqy = q[1],\n\t\tqz = q[2],\n\t\tqw = q[3],\n\t\tax = a[0],\n\t\tay = a[1],\n\t\taz = a[2],\n\t\taw = a[3]\n\n\tout[0] = ax * qw + aw * qx + ay * qz - az * qy\n\tout[1] = ay * qw + aw * qy + az * qx - ax * qz\n\tout[2] = az * qw + aw * qz + ax * qy - ay * qx\n\tout[3] = aw * qw - ax * qx - ay * qy - az * qz\n\tax = a[4]\n\tay = a[5]\n\taz = a[6]\n\taw = a[7]\n\tout[4] = ax * qw + aw * qx + ay * qz - az * qy\n\tout[5] = ay * qw + aw * qy + az * qx - ax * qz\n\tout[6] = az * qw + aw * qz + ax * qy - ay * qx\n\tout[7] = aw * qw - ax * qx - ay * qy - az * qz\n\treturn out\n}\n\n/**\n * Rotates a dual quat by a given quaternion (q * a)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat} q quaternion to rotate by\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @returns {quat2} out\n */\nexport function rotateByQuatPrepend(out: quat2, q: quat.ReadonlyQuat, a: ReadonlyQuat2): quat2 {\n\tlet qx = q[0],\n\t\tqy = q[1],\n\t\tqz = q[2],\n\t\tqw = q[3],\n\t\tbx = a[0],\n\t\tby = a[1],\n\t\tbz = a[2],\n\t\tbw = a[3]\n\n\tout[0] = qx * bw + qw * bx + qy * bz - qz * by\n\tout[1] = qy * bw + qw * by + qz * bx - qx * bz\n\tout[2] = qz * bw + qw * bz + qx * by - qy * bx\n\tout[3] = qw * bw - qx * bx - qy * by - qz * bz\n\tbx = a[4]\n\tby = a[5]\n\tbz = a[6]\n\tbw = a[7]\n\tout[4] = qx * bw + qw * bx + qy * bz - qz * by\n\tout[5] = qy * bw + qw * by + qz * bx - qx * bz\n\tout[6] = qz * bw + qw * bz + qx * by - qy * bx\n\tout[7] = qw * bw - qx * bx - qy * by - qz * bz\n\treturn out\n}\n\n/**\n * Rotates a dual quat around a given axis. Does the normalisation automatically\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @param {Number} rad how far the rotation should be\n * @returns {quat2} out\n */\nexport function rotateAroundAxis(out: quat2, a: ReadonlyQuat2, axis: vec3.ReadonlyVec3, rad: f32): quat2 {\n\t//Special case for rad = 0\n\tif (Mathf.abs(rad) < glMatrix.EPSILON) {\n\t\treturn copy(out, a)\n\t}\n\tconst axisLength = Maths.hypot3(axis[0], axis[1], axis[2])\n\n\trad = rad * 0.5\n\tconst s = Mathf.sin(rad)\n\tconst bx = (s * axis[0]) / axisLength\n\tconst by = (s * axis[1]) / axisLength\n\tconst bz = (s * axis[2]) / axisLength\n\tconst bw = Mathf.cos(rad)\n\n\tconst ax1 = a[0],\n\t\tay1 = a[1],\n\t\taz1 = a[2],\n\t\taw1 = a[3]\n\tout[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by\n\tout[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz\n\tout[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx\n\tout[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz\n\n\tconst ax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7]\n\tout[4] = ax * bw + aw * bx + ay * bz - az * by\n\tout[5] = ay * bw + aw * by + az * bx - ax * bz\n\tout[6] = az * bw + aw * bz + ax * by - ay * bx\n\tout[7] = aw * bw - ax * bx - ay * by - az * bz\n\n\treturn out\n}\n\n/**\n * Adds two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {quat2} out\n * @function\n */\nexport function add(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2): quat2 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\tout[4] = a[4] + b[4]\n\tout[5] = a[5] + b[5]\n\tout[6] = a[6] + b[6]\n\tout[7] = a[7] + b[7]\n\treturn out\n}\n\n/**\n * Multiplies two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {quat2} out\n */\nexport function multiply(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2): quat2 {\n\tconst ax0 = a[0],\n\t\tay0 = a[1],\n\t\taz0 = a[2],\n\t\taw0 = a[3],\n\t\tbx1 = b[4],\n\t\tby1 = b[5],\n\t\tbz1 = b[6],\n\t\tbw1 = b[7],\n\t\tax1 = a[4],\n\t\tay1 = a[5],\n\t\taz1 = a[6],\n\t\taw1 = a[7],\n\t\tbx0 = b[0],\n\t\tby0 = b[1],\n\t\tbz0 = b[2],\n\t\tbw0 = b[3]\n\tout[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0\n\tout[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0\n\tout[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0\n\tout[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0\n\tout[4] =\n    ax0 * bw1 +\n    aw0 * bx1 +\n    ay0 * bz1 -\n    az0 * by1 +\n    ax1 * bw0 +\n    aw1 * bx0 +\n    ay1 * bz0 -\n    az1 * by0\n\tout[5] =\n    ay0 * bw1 +\n    aw0 * by1 +\n    az0 * bx1 -\n    ax0 * bz1 +\n    ay1 * bw0 +\n    aw1 * by0 +\n    az1 * bx0 -\n    ax1 * bz0\n\tout[6] =\n    az0 * bw1 +\n    aw0 * bz1 +\n    ax0 * by1 -\n    ay0 * bx1 +\n    az1 * bw0 +\n    aw1 * bz0 +\n    ax1 * by0 -\n    ay1 * bx0\n\tout[7] =\n    aw0 * bw1 -\n    ax0 * bx1 -\n    ay0 * by1 -\n    az0 * bz1 +\n    aw1 * bw0 -\n    ax1 * bx0 -\n    ay1 * by0 -\n    az1 * bz0\n\treturn out\n}\n\n/**\n * Alias for {@link quat2.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Scales a dual quat by a scalar number\n *\n * @param {quat2} out the receiving dual quat\n * @param {ReadonlyQuat2} a the dual quat to scale\n * @param {Number} b amount to scale the dual quat by\n * @returns {quat2} out\n * @function\n */\nexport function scale(out: quat2, a: ReadonlyQuat2, b: f32): quat2 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\tout[4] = a[4] * b\n\tout[5] = a[5] * b\n\tout[6] = a[6] * b\n\tout[7] = a[7] * b\n\treturn out\n}\n\n/**\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\n *\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = quat.dot\n\n/**\n * Performs a linear interpolation between two dual quats's\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\n *\n * @param {quat2} out the receiving dual quat\n * @param {ReadonlyQuat2} a the first operand\n * @param {ReadonlyQuat2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat2} out\n */\nexport function lerp(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2, t: f32): quat2 {\n\tconst mt = <f32>1 - t\n\tif (dot(a, b) < 0) t = -t\n\n\tout[0] = a[0] * mt + b[0] * t\n\tout[1] = a[1] * mt + b[1] * t\n\tout[2] = a[2] * mt + b[2] * t\n\tout[3] = a[3] * mt + b[3] * t\n\tout[4] = a[4] * mt + b[4] * t\n\tout[5] = a[5] * mt + b[5] * t\n\tout[6] = a[6] * mt + b[6] * t\n\tout[7] = a[7] * mt + b[7] * t\n\n\treturn out\n}\n\n/**\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a dual quat to calculate inverse of\n * @returns {quat2} out\n */\nexport function invert(out: quat2, a: ReadonlyQuat2): quat2 {\n\tconst sqlen = squaredLength(a)\n\tout[0] = -a[0] / sqlen\n\tout[1] = -a[1] / sqlen\n\tout[2] = -a[2] / sqlen\n\tout[3] = a[3] / sqlen\n\tout[4] = -a[4] / sqlen\n\tout[5] = -a[5] / sqlen\n\tout[6] = -a[6] / sqlen\n\tout[7] = a[7] / sqlen\n\treturn out\n}\n\n/**\n * Calculates the conjugate of a dual quat\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\n *\n * @param {quat2} out the receiving quaternion\n * @param {ReadonlyQuat2} a quat to calculate conjugate of\n * @returns {quat2} out\n */\nexport function conjugate(out: quat2, a: ReadonlyQuat2): quat2 {\n\tout[0] = -a[0]\n\tout[1] = -a[1]\n\tout[2] = -a[2]\n\tout[3] = a[3]\n\tout[4] = -a[4]\n\tout[5] = -a[5]\n\tout[6] = -a[6]\n\tout[7] = a[7]\n\treturn out\n}\n\n/**\n * Calculates the length of a dual quat\n *\n * @param {ReadonlyQuat2} a dual quat to calculate length of\n * @returns {Number} length of a\n * @function\n */\nexport const length = quat.length\n\n/**\n * Alias for {@link quat2.length}\n * @function\n */\nexport const len = length\n\n/**\n * Calculates the squared length of a dual quat\n *\n * @param {ReadonlyQuat2} a dual quat to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport const squaredLength = quat.squaredLength\n\n/**\n * Alias for {@link quat2.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength\n\n/**\n * Normalize a dual quat\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {ReadonlyQuat2} a dual quaternion to normalize\n * @returns {quat2} out\n * @function\n */\nexport function normalize(out: quat2, a: ReadonlyQuat2): quat2 {\n\tlet magnitude = squaredLength(a)\n\tif (magnitude > 0) {\n\t\tmagnitude = Mathf.sqrt(magnitude)\n\n\t\tconst a0 = a[0] / magnitude\n\t\tconst a1 = a[1] / magnitude\n\t\tconst a2 = a[2] / magnitude\n\t\tconst a3 = a[3] / magnitude\n\n\t\tconst b0 = a[4]\n\t\tconst b1 = a[5]\n\t\tconst b2 = a[6]\n\t\tconst b3 = a[7]\n\n\t\tconst a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3\n\n\t\tout[0] = a0\n\t\tout[1] = a1\n\t\tout[2] = a2\n\t\tout[3] = a3\n\n\t\tout[4] = (b0 - a0 * a_dot_b) / magnitude\n\t\tout[5] = (b1 - a1 * a_dot_b) / magnitude\n\t\tout[6] = (b2 - a2 * a_dot_b) / magnitude\n\t\tout[7] = (b3 - a3 * a_dot_b) / magnitude\n\t}\n\treturn out\n}\n\n/**\n * Returns a string representation of a dual quaternion\n *\n * @param {ReadonlyQuat2} a dual quaternion to represent as a string\n * @returns {String} string representation of the dual quat\n */\nexport function str(a: ReadonlyQuat2): string {\n\treturn (\n\t\t'quat2(' +\n    a[0].toString() +\n    ', ' +\n    a[1].toString() +\n    ', ' +\n    a[2].toString() +\n    ', ' +\n    a[3].toString() +\n    ', ' +\n    a[4].toString() +\n    ', ' +\n    a[5].toString() +\n    ', ' +\n    a[6].toString() +\n    ', ' +\n    a[7].toString() +\n    ')'\n\t)\n}\n\n/**\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat2} a the first dual quaternion.\n * @param {ReadonlyQuat2} b the second dual quaternion.\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyQuat2, b: ReadonlyQuat2): bool {\n\treturn (\n\t\ta[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5] &&\n    a[6] === b[6] &&\n    a[7] === b[7]\n\t)\n}\n\n/**\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat2} a the first dual quat.\n * @param {ReadonlyQuat2} b the second dual quat.\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\n */\nexport function equals(a: ReadonlyQuat2, b: ReadonlyQuat2): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3],\n\t\ta4 = a[4],\n\t\ta5 = a[5],\n\t\ta6 = a[6],\n\t\ta7 = a[7]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3],\n\t\tb4 = b[4],\n\t\tb5 = b[5],\n\t\tb6 = b[6],\n\t\tb7 = b[7]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3)) &&\n    Mathf.abs(a4 - b4) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a4), Mathf.abs(b4)) &&\n    Mathf.abs(a5 - b5) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a5), Mathf.abs(b5)) &&\n    Mathf.abs(a6 - b6) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a6), Mathf.abs(b6)) &&\n    Mathf.abs(a7 - b7) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a7), Mathf.abs(b7))\n\t)\n}\n","/* eslint-disable*/\nimport * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport * as quat from './_quat'\nimport { ReadonlyQuat2 } from './_quat2'\nimport * as vec3 from './_vec3'\n\nexport type quat4 = IndexedCollection;\n\nexport type mat4 = IndexedCollection;\n\nexport type ReadonlyMat4 = IndexedCollection;\n\n/**\n * Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n */\nexport class Fov {\n  upDegrees: f32;\n  downDegrees: f32;\n  leftDegrees: f32;\n  rightDegrees: f32;\n  [key: string]: f32;\n}\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nexport function create(): mat4 {\n\tconst out = new Float32Array(16)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t\tout[3] = 0\n\t\tout[4] = 0\n\t\tout[6] = 0\n\t\tout[7] = 0\n\t\tout[8] = 0\n\t\tout[9] = 0\n\t\tout[11] = 0\n\t\tout[12] = 0\n\t\tout[13] = 0\n\t\tout[14] = 0\n\t}\n\tout[0] = 1\n\tout[5] = 1\n\tout[10] = 1\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nexport function clone(a: ReadonlyMat4): mat4 {\n\tconst out = new Float32Array(16)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\tout[6] = a[6]\n\tout[7] = a[7]\n\tout[8] = a[8]\n\tout[9] = a[9]\n\tout[10] = a[10]\n\tout[11] = a[11]\n\tout[12] = a[12]\n\tout[13] = a[13]\n\tout[14] = a[14]\n\tout[15] = a[15]\n\treturn out\n}\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out: mat4, a: ReadonlyMat4): mat4 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\tout[4] = a[4]\n\tout[5] = a[5]\n\tout[6] = a[6]\n\tout[7] = a[7]\n\tout[8] = a[8]\n\tout[9] = a[9]\n\tout[10] = a[10]\n\tout[11] = a[11]\n\tout[12] = a[12]\n\tout[13] = a[13]\n\tout[14] = a[14]\n\tout[15] = a[15]\n\treturn out\n}\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nexport function fromValues(\n\tm00: f32,\n\tm01: f32,\n\tm02: f32,\n\tm03: f32,\n\tm10: f32,\n\tm11: f32,\n\tm12: f32,\n\tm13: f32,\n\tm20: f32,\n\tm21: f32,\n\tm22: f32,\n\tm23: f32,\n\tm30: f32,\n\tm31: f32,\n\tm32: f32,\n\tm33: f32\n): mat4 {\n\tconst out = new Float32Array(16)\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m02\n\tout[3] = m03\n\tout[4] = m10\n\tout[5] = m11\n\tout[6] = m12\n\tout[7] = m13\n\tout[8] = m20\n\tout[9] = m21\n\tout[10] = m22\n\tout[11] = m23\n\tout[12] = m30\n\tout[13] = m31\n\tout[14] = m32\n\tout[15] = m33\n\treturn out\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nexport function set(\n\tout: mat4,\n\tm00: f32,\n\tm01: f32,\n\tm02: f32,\n\tm03: f32,\n\tm10: f32,\n\tm11: f32,\n\tm12: f32,\n\tm13: f32,\n\tm20: f32,\n\tm21: f32,\n\tm22: f32,\n\tm23: f32,\n\tm30: f32,\n\tm31: f32,\n\tm32: f32,\n\tm33: f32\n): mat4 {\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m02\n\tout[3] = m03\n\tout[4] = m10\n\tout[5] = m11\n\tout[6] = m12\n\tout[7] = m13\n\tout[8] = m20\n\tout[9] = m21\n\tout[10] = m22\n\tout[11] = m23\n\tout[12] = m30\n\tout[13] = m31\n\tout[14] = m32\n\tout[15] = m33\n\treturn out\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out: mat4): mat4 {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = 1\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = 1\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out: mat4, a: ReadonlyMat4): mat4 {\n\t// If we are transposing ourselves we can skip a few steps but have to cache some values\n\tif (out === a) {\n\t\tconst a01 = a[1],\n\t\t\ta02 = a[2],\n\t\t\ta03 = a[3]\n\t\tconst a12 = a[6],\n\t\t\ta13 = a[7]\n\t\tconst a23 = a[11]\n\n\t\tout[1] = a[4]\n\t\tout[2] = a[8]\n\t\tout[3] = a[12]\n\t\tout[4] = a01\n\t\tout[6] = a[9]\n\t\tout[7] = a[13]\n\t\tout[8] = a02\n\t\tout[9] = a12\n\t\tout[11] = a[14]\n\t\tout[12] = a03\n\t\tout[13] = a13\n\t\tout[14] = a23\n\t} else {\n\t\tout[0] = a[0]\n\t\tout[1] = a[4]\n\t\tout[2] = a[8]\n\t\tout[3] = a[12]\n\t\tout[4] = a[1]\n\t\tout[5] = a[5]\n\t\tout[6] = a[9]\n\t\tout[7] = a[13]\n\t\tout[8] = a[2]\n\t\tout[9] = a[6]\n\t\tout[10] = a[10]\n\t\tout[11] = a[14]\n\t\tout[12] = a[3]\n\t\tout[13] = a[7]\n\t\tout[14] = a[11]\n\t\tout[15] = a[15]\n\t}\n\n\treturn out\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out: mat4, a: ReadonlyMat4): mat4 | null {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta03 = a[3]\n\tconst a10 = a[4],\n\t\ta11 = a[5],\n\t\ta12 = a[6],\n\t\ta13 = a[7]\n\tconst a20 = a[8],\n\t\ta21 = a[9],\n\t\ta22 = a[10],\n\t\ta23 = a[11]\n\tconst a30 = a[12],\n\t\ta31 = a[13],\n\t\ta32 = a[14],\n\t\ta33 = a[15]\n\n\tconst b00 = a00 * a11 - a01 * a10\n\tconst b01 = a00 * a12 - a02 * a10\n\tconst b02 = a00 * a13 - a03 * a10\n\tconst b03 = a01 * a12 - a02 * a11\n\tconst b04 = a01 * a13 - a03 * a11\n\tconst b05 = a02 * a13 - a03 * a12\n\tconst b06 = a20 * a31 - a21 * a30\n\tconst b07 = a20 * a32 - a22 * a30\n\tconst b08 = a20 * a33 - a23 * a30\n\tconst b09 = a21 * a32 - a22 * a31\n\tconst b10 = a21 * a33 - a23 * a31\n\tconst b11 = a22 * a33 - a23 * a32\n\n\t// Calculate the determinant\n\tlet det =\n    b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06\n\n\tif (!det) {\n\t\treturn null\n\t}\n\tdet = 1.0 / det\n\n\tout[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det\n\tout[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det\n\tout[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det\n\tout[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det\n\tout[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det\n\tout[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det\n\tout[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det\n\tout[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det\n\tout[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det\n\tout[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det\n\tout[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det\n\tout[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det\n\tout[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det\n\tout[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det\n\tout[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det\n\tout[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det\n\n\treturn out\n}\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function adjoint(out: mat4, a: ReadonlyMat4): mat4 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta03 = a[3]\n\tconst a10 = a[4],\n\t\ta11 = a[5],\n\t\ta12 = a[6],\n\t\ta13 = a[7]\n\tconst a20 = a[8],\n\t\ta21 = a[9],\n\t\ta22 = a[10],\n\t\ta23 = a[11]\n\tconst a30 = a[12],\n\t\ta31 = a[13],\n\t\ta32 = a[14],\n\t\ta33 = a[15]\n\n\tconst b00 = a00 * a11 - a01 * a10\n\tconst b01 = a00 * a12 - a02 * a10\n\tconst b02 = a00 * a13 - a03 * a10\n\tconst b03 = a01 * a12 - a02 * a11\n\tconst b04 = a01 * a13 - a03 * a11\n\tconst b05 = a02 * a13 - a03 * a12\n\tconst b06 = a20 * a31 - a21 * a30\n\tconst b07 = a20 * a32 - a22 * a30\n\tconst b08 = a20 * a33 - a23 * a30\n\tconst b09 = a21 * a32 - a22 * a31\n\tconst b10 = a21 * a33 - a23 * a31\n\tconst b11 = a22 * a33 - a23 * a32\n\n\tout[0] = a11 * b11 - a12 * b10 + a13 * b09\n\tout[1] = a02 * b10 - a01 * b11 - a03 * b09\n\tout[2] = a31 * b05 - a32 * b04 + a33 * b03\n\tout[3] = a22 * b04 - a21 * b05 - a23 * b03\n\tout[4] = a12 * b08 - a10 * b11 - a13 * b07\n\tout[5] = a00 * b11 - a02 * b08 + a03 * b07\n\tout[6] = a32 * b02 - a30 * b05 - a33 * b01\n\tout[7] = a20 * b05 - a22 * b02 + a23 * b01\n\tout[8] = a10 * b10 - a11 * b08 + a13 * b06\n\tout[9] = a01 * b08 - a00 * b10 - a03 * b06\n\tout[10] = a30 * b04 - a31 * b02 + a33 * b00\n\tout[11] = a21 * b02 - a20 * b04 - a23 * b00\n\tout[12] = a11 * b07 - a10 * b09 - a12 * b06\n\tout[13] = a00 * b09 - a01 * b07 + a02 * b06\n\tout[14] = a31 * b01 - a30 * b03 - a32 * b00\n\tout[15] = a20 * b03 - a21 * b01 + a22 * b00\n\treturn out\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a: ReadonlyMat4): f32 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta03 = a[3]\n\tconst a10 = a[4],\n\t\ta11 = a[5],\n\t\ta12 = a[6],\n\t\ta13 = a[7]\n\tconst a20 = a[8],\n\t\ta21 = a[9],\n\t\ta22 = a[10],\n\t\ta23 = a[11]\n\tconst a30 = a[12],\n\t\ta31 = a[13],\n\t\ta32 = a[14],\n\t\ta33 = a[15]\n\n\tconst b0 = a00 * a11 - a01 * a10\n\tconst b1 = a00 * a12 - a02 * a10\n\tconst b2 = a01 * a12 - a02 * a11\n\tconst b3 = a20 * a31 - a21 * a30\n\tconst b4 = a20 * a32 - a22 * a30\n\tconst b5 = a21 * a32 - a22 * a31\n\tconst b6 = a00 * b5 - a01 * b4 + a02 * b3\n\tconst b7 = a10 * b5 - a11 * b4 + a12 * b3\n\tconst b8 = a20 * b2 - a21 * b1 + a22 * b0\n\tconst b9 = a30 * b2 - a31 * b1 + a32 * b0\n\n\t// Calculate the determinant\n\treturn a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4 {\n\tconst a00 = a[0],\n\t\ta01 = a[1],\n\t\ta02 = a[2],\n\t\ta03 = a[3]\n\tconst a10 = a[4],\n\t\ta11 = a[5],\n\t\ta12 = a[6],\n\t\ta13 = a[7]\n\tconst a20 = a[8],\n\t\ta21 = a[9],\n\t\ta22 = a[10],\n\t\ta23 = a[11]\n\tconst a30 = a[12],\n\t\ta31 = a[13],\n\t\ta32 = a[14],\n\t\ta33 = a[15]\n\n\t// Cache only the current line of the second matrix\n\tlet b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3]\n\tout[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30\n\tout[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31\n\tout[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32\n\tout[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33\n\n\tb0 = b[4]\n\tb1 = b[5]\n\tb2 = b[6]\n\tb3 = b[7]\n\tout[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30\n\tout[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31\n\tout[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32\n\tout[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33\n\n\tb0 = b[8]\n\tb1 = b[9]\n\tb2 = b[10]\n\tb3 = b[11]\n\tout[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30\n\tout[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31\n\tout[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32\n\tout[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33\n\n\tb0 = b[12]\n\tb1 = b[13]\n\tb2 = b[14]\n\tb3 = b[15]\n\tout[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30\n\tout[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31\n\tout[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32\n\tout[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33\n\treturn out\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out: mat4, a: ReadonlyMat4, v: vec3.ReadonlyVec3): mat4 {\n\tconst x = v[0],\n\t\ty = v[1],\n\t\tz = v[2]\n\tlet a00: f32, a01: f32, a02: f32, a03: f32\n\tlet a10: f32, a11: f32, a12: f32, a13: f32\n\tlet a20: f32, a21: f32, a22: f32, a23: f32\n\n\tif (a === out) {\n\t\tout[12] = a[0] * x + a[4] * y + a[8] * z + a[12]\n\t\tout[13] = a[1] * x + a[5] * y + a[9] * z + a[13]\n\t\tout[14] = a[2] * x + a[6] * y + a[10] * z + a[14]\n\t\tout[15] = a[3] * x + a[7] * y + a[11] * z + a[15]\n\t} else {\n\t\ta00 = a[0]\n\t\ta01 = a[1]\n\t\ta02 = a[2]\n\t\ta03 = a[3]\n\t\ta10 = a[4]\n\t\ta11 = a[5]\n\t\ta12 = a[6]\n\t\ta13 = a[7]\n\t\ta20 = a[8]\n\t\ta21 = a[9]\n\t\ta22 = a[10]\n\t\ta23 = a[11]\n\n\t\tout[0] = a00\n\t\tout[1] = a01\n\t\tout[2] = a02\n\t\tout[3] = a03\n\t\tout[4] = a10\n\t\tout[5] = a11\n\t\tout[6] = a12\n\t\tout[7] = a13\n\t\tout[8] = a20\n\t\tout[9] = a21\n\t\tout[10] = a22\n\t\tout[11] = a23\n\n\t\tout[12] = a00 * x + a10 * y + a20 * z + a[12]\n\t\tout[13] = a01 * x + a11 * y + a21 * z + a[13]\n\t\tout[14] = a02 * x + a12 * y + a22 * z + a[14]\n\t\tout[15] = a03 * x + a13 * y + a23 * z + a[15]\n\t}\n\n\treturn out\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out: mat4, a: ReadonlyMat4, v: vec3.ReadonlyVec3): mat4 {\n\tconst x = v[0],\n\t\ty = v[1],\n\t\tz = v[2]\n\n\tout[0] = a[0] * x\n\tout[1] = a[1] * x\n\tout[2] = a[2] * x\n\tout[3] = a[3] * x\n\tout[4] = a[4] * y\n\tout[5] = a[5] * y\n\tout[6] = a[6] * y\n\tout[7] = a[7] * y\n\tout[8] = a[8] * z\n\tout[9] = a[9] * z\n\tout[10] = a[10] * z\n\tout[11] = a[11] * z\n\tout[12] = a[12]\n\tout[13] = a[13]\n\tout[14] = a[14]\n\tout[15] = a[15]\n\treturn out\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out: mat4, a: ReadonlyMat4, rad: f32, axis: vec3.ReadonlyVec3): mat4 | null {\n\tlet x = axis[0],\n\t\ty = axis[1],\n\t\tz = axis[2]\n\tlet len = Maths.hypot3(x, y, z)\n\tlet s: f32, c: f32, t: f32\n\tlet a00: f32, a01: f32, a02: f32, a03: f32\n\tlet a10: f32, a11: f32, a12: f32, a13: f32\n\tlet a20: f32, a21: f32, a22: f32, a23: f32\n\tlet b00: f32, b01: f32, b02: f32\n\tlet b10: f32, b11: f32, b12: f32\n\tlet b20: f32, b21: f32, b22: f32\n\n\tif (len < glMatrix.EPSILON) {\n\t\treturn null\n\t}\n\n\tlen = 1 / len\n\tx *= len\n\ty *= len\n\tz *= len\n\n\ts = Mathf.sin(rad)\n\tc = Mathf.cos(rad)\n\tt = 1 - c\n\n\ta00 = a[0]\n\ta01 = a[1]\n\ta02 = a[2]\n\ta03 = a[3]\n\ta10 = a[4]\n\ta11 = a[5]\n\ta12 = a[6]\n\ta13 = a[7]\n\ta20 = a[8]\n\ta21 = a[9]\n\ta22 = a[10]\n\ta23 = a[11]\n\n\t// Construct the elements of the rotation matrix\n\tb00 = x * x * t + c\n\tb01 = y * x * t + z * s\n\tb02 = z * x * t - y * s\n\tb10 = x * y * t - z * s\n\tb11 = y * y * t + c\n\tb12 = z * y * t + x * s\n\tb20 = x * z * t + y * s\n\tb21 = y * z * t - x * s\n\tb22 = z * z * t + c\n\n\t// Perform rotation-specific matrix multiplication\n\tout[0] = a00 * b00 + a10 * b01 + a20 * b02\n\tout[1] = a01 * b00 + a11 * b01 + a21 * b02\n\tout[2] = a02 * b00 + a12 * b01 + a22 * b02\n\tout[3] = a03 * b00 + a13 * b01 + a23 * b02\n\tout[4] = a00 * b10 + a10 * b11 + a20 * b12\n\tout[5] = a01 * b10 + a11 * b11 + a21 * b12\n\tout[6] = a02 * b10 + a12 * b11 + a22 * b12\n\tout[7] = a03 * b10 + a13 * b11 + a23 * b12\n\tout[8] = a00 * b20 + a10 * b21 + a20 * b22\n\tout[9] = a01 * b20 + a11 * b21 + a21 * b22\n\tout[10] = a02 * b20 + a12 * b21 + a22 * b22\n\tout[11] = a03 * b20 + a13 * b21 + a23 * b22\n\n\tif (a !== out) {\n\t\t// If the source and destination differ, copy the unchanged last row\n\t\tout[12] = a[12]\n\t\tout[13] = a[13]\n\t\tout[14] = a[14]\n\t\tout[15] = a[15]\n\t}\n\treturn out\n}\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateX(out: mat4, a: ReadonlyMat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tconst a10 = a[4]\n\tconst a11 = a[5]\n\tconst a12 = a[6]\n\tconst a13 = a[7]\n\tconst a20 = a[8]\n\tconst a21 = a[9]\n\tconst a22 = a[10]\n\tconst a23 = a[11]\n\n\tif (a !== out) {\n\t\t// If the source and destination differ, copy the unchanged rows\n\t\tout[0] = a[0]\n\t\tout[1] = a[1]\n\t\tout[2] = a[2]\n\t\tout[3] = a[3]\n\t\tout[12] = a[12]\n\t\tout[13] = a[13]\n\t\tout[14] = a[14]\n\t\tout[15] = a[15]\n\t}\n\n\t// Perform axis-specific matrix multiplication\n\tout[4] = a10 * c + a20 * s\n\tout[5] = a11 * c + a21 * s\n\tout[6] = a12 * c + a22 * s\n\tout[7] = a13 * c + a23 * s\n\tout[8] = a20 * c - a10 * s\n\tout[9] = a21 * c - a11 * s\n\tout[10] = a22 * c - a12 * s\n\tout[11] = a23 * c - a13 * s\n\treturn out\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateY(out: mat4, a: ReadonlyMat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tconst a00 = a[0]\n\tconst a01 = a[1]\n\tconst a02 = a[2]\n\tconst a03 = a[3]\n\tconst a20 = a[8]\n\tconst a21 = a[9]\n\tconst a22 = a[10]\n\tconst a23 = a[11]\n\n\tif (a !== out) {\n\t\t// If the source and destination differ, copy the unchanged rows\n\t\tout[4] = a[4]\n\t\tout[5] = a[5]\n\t\tout[6] = a[6]\n\t\tout[7] = a[7]\n\t\tout[12] = a[12]\n\t\tout[13] = a[13]\n\t\tout[14] = a[14]\n\t\tout[15] = a[15]\n\t}\n\n\t// Perform axis-specific matrix multiplication\n\tout[0] = a00 * c - a20 * s\n\tout[1] = a01 * c - a21 * s\n\tout[2] = a02 * c - a22 * s\n\tout[3] = a03 * c - a23 * s\n\tout[8] = a00 * s + a20 * c\n\tout[9] = a01 * s + a21 * c\n\tout[10] = a02 * s + a22 * c\n\tout[11] = a03 * s + a23 * c\n\treturn out\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateZ(out: mat4, a: ReadonlyMat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tconst a00 = a[0]\n\tconst a01 = a[1]\n\tconst a02 = a[2]\n\tconst a03 = a[3]\n\tconst a10 = a[4]\n\tconst a11 = a[5]\n\tconst a12 = a[6]\n\tconst a13 = a[7]\n\n\tif (a !== out) {\n\t\t// If the source and destination differ, copy the unchanged last row\n\t\tout[8] = a[8]\n\t\tout[9] = a[9]\n\t\tout[10] = a[10]\n\t\tout[11] = a[11]\n\t\tout[12] = a[12]\n\t\tout[13] = a[13]\n\t\tout[14] = a[14]\n\t\tout[15] = a[15]\n\t}\n\n\t// Perform axis-specific matrix multiplication\n\tout[0] = a00 * c + a10 * s\n\tout[1] = a01 * c + a11 * s\n\tout[2] = a02 * c + a12 * s\n\tout[3] = a03 * c + a13 * s\n\tout[4] = a10 * c - a00 * s\n\tout[5] = a11 * c - a01 * s\n\tout[6] = a12 * c - a02 * s\n\tout[7] = a13 * c - a03 * s\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\nexport function fromTranslation(out: mat4, v: vec3.ReadonlyVec3): mat4 {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = 1\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = 1\n\tout[11] = 0\n\tout[12] = v[0]\n\tout[13] = v[1]\n\tout[14] = v[2]\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\nexport function fromScaling(out: mat4, v: vec3.ReadonlyVec3): mat4 {\n\tout[0] = v[0]\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = v[1]\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = v[2]\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad: f32, axis: vec3.ReadonlyVec3);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function fromRotation(out: mat4, rad: f32, axis: vec3.ReadonlyVec3): mat4 | null {\n\tlet x = axis[0],\n\t\ty = axis[1],\n\t\tz = axis[2]\n\tlet len = Maths.hypot3(x, y, z)\n\tlet s: f32, c: f32, t: f32\n\n\tif (len < glMatrix.EPSILON) {\n\t\treturn null\n\t}\n\n\tlen = 1 / len\n\tx *= len\n\ty *= len\n\tz *= len\n\n\ts = Mathf.sin(rad)\n\tc = Mathf.cos(rad)\n\tt = 1 - c\n\n\t// Perform rotation-specific matrix multiplication\n\tout[0] = x * x * t + c\n\tout[1] = y * x * t + z * s\n\tout[2] = z * x * t - y * s\n\tout[3] = 0\n\tout[4] = x * y * t - z * s\n\tout[5] = y * y * t + c\n\tout[6] = z * y * t + x * s\n\tout[7] = 0\n\tout[8] = x * z * t + y * s\n\tout[9] = y * z * t - x * s\n\tout[10] = z * z * t + c\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromXRotation(out: mat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\n\t// Perform axis-specific matrix multiplication\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = c\n\tout[6] = s\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = -s\n\tout[10] = c\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromYRotation(out: mat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\n\t// Perform axis-specific matrix multiplication\n\tout[0] = c\n\tout[1] = 0\n\tout[2] = -s\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = 1\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = s\n\tout[9] = 0\n\tout[10] = c\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromZRotation(out: mat4, rad: f32): mat4 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\n\t// Perform axis-specific matrix multiplication\n\tout[0] = c\n\tout[1] = s\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = -s\n\tout[5] = c\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = 1\n\tout[11] = 0\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslation(out: mat4, q: quat4, v: vec3.ReadonlyVec3): mat4 {\n\t// Quaternion math\n\tconst x = q[0],\n\t\ty = q[1],\n\t\tz = q[2],\n\t\tw = q[3]\n\tconst x2 = x + x\n\tconst y2 = y + y\n\tconst z2 = z + z\n\n\tconst xx = x * x2\n\tconst xy = x * y2\n\tconst xz = x * z2\n\tconst yy = y * y2\n\tconst yz = y * z2\n\tconst zz = z * z2\n\tconst wx = w * x2\n\tconst wy = w * y2\n\tconst wz = w * z2\n\n\tout[0] = 1 - (yy + zz)\n\tout[1] = xy + wz\n\tout[2] = xz - wy\n\tout[3] = 0\n\tout[4] = xy - wz\n\tout[5] = 1 - (xx + zz)\n\tout[6] = yz + wx\n\tout[7] = 0\n\tout[8] = xz + wy\n\tout[9] = yz - wx\n\tout[10] = 1 - (xx + yy)\n\tout[11] = 0\n\tout[12] = v[0]\n\tout[13] = v[1]\n\tout[14] = v[2]\n\tout[15] = 1\n\n\treturn out\n}\n\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\nexport function fromQuat2(out: mat4, a: ReadonlyQuat2): mat4 {\n\tconst translation = new Float32Array(3)\n\tconst bx = -a[0],\n\t\tby = -a[1],\n\t\tbz = -a[2],\n\t\tbw = a[3],\n\t\tax = a[4],\n\t\tay = a[5],\n\t\taz = a[6],\n\t\taw = a[7]\n\n\tconst magnitude = bx * bx + by * by + bz * bz + bw * bw\n\t//Only scale if it makes sense\n\tif (magnitude > 0) {\n\t\ttranslation[0] = ((ax * bw + aw * bx + ay * bz - az * by) * 2) / magnitude\n\t\ttranslation[1] = ((ay * bw + aw * by + az * bx - ax * bz) * 2) / magnitude\n\t\ttranslation[2] = ((az * bw + aw * bz + ax * by - ay * bx) * 2) / magnitude\n\t} else {\n\t\ttranslation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2\n\t\ttranslation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2\n\t\ttranslation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2\n\t}\n\tfromRotationTranslation(out, a, translation)\n\treturn out\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out: vec3.vec3, mat: ReadonlyMat4): vec3.vec3 {\n\tout[0] = mat[12]\n\tout[1] = mat[13]\n\tout[2] = mat[14]\n\n\treturn out\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out: mat4, mat: ReadonlyMat4): mat4 {\n\tconst m11 = mat[0]\n\tconst m12 = mat[1]\n\tconst m13 = mat[2]\n\tconst m21 = mat[4]\n\tconst m22 = mat[5]\n\tconst m23 = mat[6]\n\tconst m31 = mat[8]\n\tconst m32 = mat[9]\n\tconst m33 = mat[10]\n\n\tout[0] = Maths.hypot3(m11, m12, m13)\n\tout[1] = Maths.hypot3(m21, m22, m23)\n\tout[2] = Maths.hypot3(m31, m32, m33)\n\n\treturn out\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport function getRotation(out: mat4, mat: ReadonlyMat4): mat4 {\n\tconst scaling = changetype<IndexedCollection>(new Float32Array(3))\n\tgetScaling(scaling, mat)\n\n\tconst is1 = <f32>1 / scaling[0]\n\tconst is2 = <f32>1 / scaling[1]\n\tconst is3 = <f32>1 / scaling[2]\n\n\tconst sm11 = mat[0] * is1\n\tconst sm12 = mat[1] * is2\n\tconst sm13 = mat[2] * is3\n\tconst sm21 = mat[4] * is1\n\tconst sm22 = mat[5] * is2\n\tconst sm23 = mat[6] * is3\n\tconst sm31 = mat[8] * is1\n\tconst sm32 = mat[9] * is2\n\tconst sm33 = mat[10] * is3\n\n\tconst trace = sm11 + sm22 + sm33\n\tlet S: f32 = 0\n\n\tif (trace > 0) {\n\t\tS = Mathf.sqrt(trace + 1.0) * 2\n\t\tout[3] = 0.25 * S\n\t\tout[0] = (sm23 - sm32) / S\n\t\tout[1] = (sm31 - sm13) / S\n\t\tout[2] = (sm12 - sm21) / S\n\t} else if (sm11 > sm22 && sm11 > sm33) {\n\t\tS = Mathf.sqrt(1.0 + sm11 - sm22 - sm33) * 2\n\t\tout[3] = (sm23 - sm32) / S\n\t\tout[0] = 0.25 * S\n\t\tout[1] = (sm12 + sm21) / S\n\t\tout[2] = (sm31 + sm13) / S\n\t} else if (sm22 > sm33) {\n\t\tS = Mathf.sqrt(1.0 + sm22 - sm11 - sm33) * 2\n\t\tout[3] = (sm31 - sm13) / S\n\t\tout[0] = (sm12 + sm21) / S\n\t\tout[1] = 0.25 * S\n\t\tout[2] = (sm23 + sm32) / S\n\t} else {\n\t\tS = Mathf.sqrt(1.0 + sm33 - sm11 - sm22) * 2\n\t\tout[3] = (sm12 - sm21) / S\n\t\tout[0] = (sm31 + sm13) / S\n\t\tout[1] = (sm23 + sm32) / S\n\t\tout[2] = 0.25 * S\n\t}\n\n\treturn out\n}\n\n/**\n * Decomposes a transformation matrix into its rotation, translation\n * and scale components. Returns only the rotation component\n * @param  {quat} out_r Quaternion to receive the rotation component\n * @param  {vec3} out_t Vector to receive the translation vector\n * @param  {vec3} out_s Vector to receive the scaling factor\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @returns {quat} out_r\n */\nexport function decompose(out_r: quat.quat, out_t: vec3.vec3, out_s: vec3.vec3, mat: ReadonlyMat4): quat.quat {\n\tout_t[0] = mat[12]\n\tout_t[1] = mat[13]\n\tout_t[2] = mat[14]\n\n\tconst m11 = mat[0]\n\tconst m12 = mat[1]\n\tconst m13 = mat[2]\n\tconst m21 = mat[4]\n\tconst m22 = mat[5]\n\tconst m23 = mat[6]\n\tconst m31 = mat[8]\n\tconst m32 = mat[9]\n\tconst m33 = mat[10]\n\n\tout_s[0] = Maths.hypot3(m11, m12, m13)\n\tout_s[1] = Maths.hypot3(m21, m22, m23)\n\tout_s[2] = Maths.hypot3(m31, m32, m33)\n\n\tconst is1 = <f32>1 / out_s[0]\n\tconst is2 = <f32>1 / out_s[1]\n\tconst is3 = <f32>1 / out_s[2]\n\n\tconst sm11 = m11 * is1\n\tconst sm12 = m12 * is2\n\tconst sm13 = m13 * is3\n\tconst sm21 = m21 * is1\n\tconst sm22 = m22 * is2\n\tconst sm23 = m23 * is3\n\tconst sm31 = m31 * is1\n\tconst sm32 = m32 * is2\n\tconst sm33 = m33 * is3\n\n\tconst trace = sm11 + sm22 + sm33\n\tlet S: f32 = 0\n\n\tif (trace > 0) {\n\t\tS = Mathf.sqrt(trace + 1.0) * 2\n\t\tout_r[3] = <f32>0.25 * S\n\t\tout_r[0] = (sm23 - sm32) / S\n\t\tout_r[1] = (sm31 - sm13) / S\n\t\tout_r[2] = (sm12 - sm21) / S\n\t} else if (sm11 > sm22 && sm11 > sm33) {\n\t\tS = Mathf.sqrt(<f32>1.0 + sm11 - sm22 - sm33) * 2\n\t\tout_r[3] = (sm23 - sm32) / S\n\t\tout_r[0] = <f32>0.25 * S\n\t\tout_r[1] = (sm12 + sm21) / S\n\t\tout_r[2] = (sm31 + sm13) / S\n\t} else if (sm22 > sm33) {\n\t\tS = Mathf.sqrt(<f32>1.0 + sm22 - sm11 - sm33) * 2\n\t\tout_r[3] = (sm31 - sm13) / S\n\t\tout_r[0] = (sm12 + sm21) / S\n\t\tout_r[1] = <f32>0.25 * S\n\t\tout_r[2] = (sm23 + sm32) / S\n\t} else {\n\t\tS = Mathf.sqrt(<f32>1.0 + sm33 - sm11 - sm22) * 2\n\t\tout_r[3] = (sm12 - sm21) / S\n\t\tout_r[0] = (sm31 + sm13) / S\n\t\tout_r[1] = (sm23 + sm32) / S\n\t\tout_r[2] = <f32>0.25 * S\n\t}\n\n\treturn out_r\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out: mat4, q: quat4, v: vec3.ReadonlyVec3, s: vec3.ReadonlyVec3): mat4 {\n\t// Quaternion math\n\tconst x = q[0],\n\t\ty = q[1],\n\t\tz = q[2],\n\t\tw = q[3]\n\tconst x2 = x + x\n\tconst y2 = y + y\n\tconst z2 = z + z\n\n\tconst xx = x * x2\n\tconst xy = x * y2\n\tconst xz = x * z2\n\tconst yy = y * y2\n\tconst yz = y * z2\n\tconst zz = z * z2\n\tconst wx = w * x2\n\tconst wy = w * y2\n\tconst wz = w * z2\n\tconst sx = s[0]\n\tconst sy = s[1]\n\tconst sz = s[2]\n\n\tout[0] = (1 - (yy + zz)) * sx\n\tout[1] = (xy + wz) * sx\n\tout[2] = (xz - wy) * sx\n\tout[3] = 0\n\tout[4] = (xy - wz) * sy\n\tout[5] = (1 - (xx + zz)) * sy\n\tout[6] = (yz + wx) * sy\n\tout[7] = 0\n\tout[8] = (xz + wy) * sz\n\tout[9] = (yz - wx) * sz\n\tout[10] = (1 - (xx + yy)) * sz\n\tout[11] = 0\n\tout[12] = v[0]\n\tout[13] = v[1]\n\tout[14] = v[2]\n\tout[15] = 1\n\n\treturn out\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScaleOrigin(out: mat4, q: quat4, v: vec3.ReadonlyVec3, s: vec3.ReadonlyVec3, o: vec3.ReadonlyVec3): mat4 {\n\t// Quaternion math\n\tconst x = q[0],\n\t\ty = q[1],\n\t\tz = q[2],\n\t\tw = q[3]\n\tconst x2 = x + x\n\tconst y2 = y + y\n\tconst z2 = z + z\n\n\tconst xx = x * x2\n\tconst xy = x * y2\n\tconst xz = x * z2\n\tconst yy = y * y2\n\tconst yz = y * z2\n\tconst zz = z * z2\n\tconst wx = w * x2\n\tconst wy = w * y2\n\tconst wz = w * z2\n\n\tconst sx = s[0]\n\tconst sy = s[1]\n\tconst sz = s[2]\n\n\tconst ox = o[0]\n\tconst oy = o[1]\n\tconst oz = o[2]\n\n\tconst out0 = (<f32>1 - (yy + zz)) * sx\n\tconst out1 = (xy + wz) * sx\n\tconst out2 = (xz - wy) * sx\n\tconst out4 = (xy - wz) * sy\n\tconst out5 = (<f32>1 - (xx + zz)) * sy\n\tconst out6 = (yz + wx) * sy\n\tconst out8 = (xz + wy) * sz\n\tconst out9 = (yz - wx) * sz\n\tconst out10 = (<f32>1 - (xx + yy)) * sz\n\n\tout[0] = out0\n\tout[1] = out1\n\tout[2] = out2\n\tout[3] = 0\n\tout[4] = out4\n\tout[5] = out5\n\tout[6] = out6\n\tout[7] = 0\n\tout[8] = out8\n\tout[9] = out9\n\tout[10] = out10\n\tout[11] = 0\n\tout[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz)\n\tout[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz)\n\tout[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz)\n\tout[15] = 1\n\n\treturn out\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out: mat4, q: quat.ReadonlyQuat): mat4 {\n\tconst x = q[0],\n\t\ty = q[1],\n\t\tz = q[2],\n\t\tw = q[3]\n\tconst x2 = x + x\n\tconst y2 = y + y\n\tconst z2 = z + z\n\n\tconst xx = x * x2\n\tconst yx = y * x2\n\tconst yy = y * y2\n\tconst zx = z * x2\n\tconst zy = z * y2\n\tconst zz = z * z2\n\tconst wx = w * x2\n\tconst wy = w * y2\n\tconst wz = w * z2\n\n\tout[0] = 1 - yy - zz\n\tout[1] = yx + wz\n\tout[2] = zx - wy\n\tout[3] = 0\n\n\tout[4] = yx - wz\n\tout[5] = 1 - xx - zz\n\tout[6] = zy + wx\n\tout[7] = 0\n\n\tout[8] = zx + wy\n\tout[9] = zy - wx\n\tout[10] = 1 - xx - yy\n\tout[11] = 0\n\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = 0\n\tout[15] = 1\n\n\treturn out\n}\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function frustum(out: mat4, left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): mat4 {\n\tconst rl = <f32>1 / (right - left)\n\tconst tb = <f32>1 / (top - bottom)\n\tconst nf = <f32>1 / (near - far)\n\tout[0] = near * 2 * rl\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = near * 2 * tb\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = (right + left) * rl\n\tout[9] = (top + bottom) * tb\n\tout[10] = (far + near) * nf\n\tout[11] = -1\n\tout[12] = 0\n\tout[13] = 0\n\tout[14] = far * near * 2 * nf\n\tout[15] = 0\n\treturn out\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n * \n * Read https://www.assemblyscript.org/types.html#type-rules\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function perspectiveNO(out: mat4, fovy: f32, aspect: f32, near: f32, far: f32): mat4 {\n\tconst f = <f32>1.0 / Mathf.tan(fovy / 2)\n\tout[0] = f / aspect\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = f\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[11] = -1\n\tout[12] = 0\n\tout[13] = 0\n\tout[15] = 0\n\tif (typeof far === 'number' && far !== Infinity) {\n\t\tconst nf = <f32>1 / (near - far)\n\t\tout[10] = (far + near) * nf\n\t\tout[14] = <f32>2 * far * near * nf\n\t} else {\n\t\tout[10] = -1\n\t\tout[14] = -2 * near\n\t}\n\treturn out\n}\n\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\nexport const perspective = perspectiveNO\n\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n * \n * Read https://www.assemblyscript.org/types.html#type-rules\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function perspectiveZO(out: mat4, fovy: f32, aspect: f32, near: f32, far: f32): mat4 {\n\tconst f = <f32>1.0 / Mathf.tan(fovy / 2)\n\tout[0] = f / aspect\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = f\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[11] = -1\n\tout[12] = 0\n\tout[13] = 0\n\tout[15] = 0\n\tif (typeof far === 'number' && far !== Infinity) {\n\t\tconst nf = <f32>1 / (near - far)\n\t\tout[10] = far * nf\n\t\tout[14] = far * near * nf\n\t} else {\n\t\tout[10] = -1\n\t\tout[14] = -near\n\t}\n\treturn out\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Fov} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspectiveFromFieldOfView(out: mat4, fov: Fov, near: f32, far: f32): mat4 {\n\tconst upTan = Mathf.tan((fov.upDegrees * Mathf.PI) / 180.0)\n\tconst downTan = Mathf.tan((fov.downDegrees * Mathf.PI) / 180.0)\n\tconst leftTan = Mathf.tan((fov.leftDegrees * Mathf.PI) / 180.0)\n\tconst rightTan = Mathf.tan((fov.rightDegrees * Mathf.PI) / 180.0)\n\tconst xScale = <f32>2.0 / (leftTan + rightTan)\n\tconst yScale = <f32>2.0 / (upTan + downTan)\n\n\tout[0] = xScale\n\tout[1] = 0.0\n\tout[2] = 0.0\n\tout[3] = 0.0\n\tout[4] = 0.0\n\tout[5] = yScale\n\tout[6] = 0.0\n\tout[7] = 0.0\n\tout[8] = -((leftTan - rightTan) * xScale * 0.5)\n\tout[9] = (upTan - downTan) * yScale * 0.5\n\tout[10] = far / (near - far)\n\tout[11] = -1.0\n\tout[12] = 0.0\n\tout[13] = 0.0\n\tout[14] = (far * near) / (near - far)\n\tout[15] = 0.0\n\treturn out\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function orthoNO(out: mat4, left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): mat4 {\n\tconst lr = <f32>1 / (left - right)\n\tconst bt = <f32>1 / (bottom - top)\n\tconst nf = <f32>1 / (near - far)\n\tout[0] = -2 * lr\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = -2 * bt\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = 2 * nf\n\tout[11] = 0\n\tout[12] = (left + right) * lr\n\tout[13] = (top + bottom) * bt\n\tout[14] = (far + near) * nf\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\nexport const ortho = orthoNO\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function orthoZO(out: mat4, left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32): mat4 {\n\tconst lr = <f32>1 / (left - right)\n\tconst bt = <f32>1 / (bottom - top)\n\tconst nf = <f32>1 / (near - far)\n\tout[0] = -2 * lr\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 0\n\tout[4] = 0\n\tout[5] = -2 * bt\n\tout[6] = 0\n\tout[7] = 0\n\tout[8] = 0\n\tout[9] = 0\n\tout[10] = nf\n\tout[11] = 0\n\tout[12] = (left + right) * lr\n\tout[13] = (top + bottom) * bt\n\tout[14] = near * nf\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function lookAt(out: mat4, eye: vec3.ReadonlyVec3, center: vec3.ReadonlyVec3, up: vec3.ReadonlyVec3): mat4 {\n\tlet x0: f32, x1: f32, x2: f32, y0: f32, y1: f32, y2: f32, z0: f32, z1: f32, z2: f32, len: f32\n\tconst eyex = eye[0]\n\tconst eyey = eye[1]\n\tconst eyez = eye[2]\n\tconst upx = up[0]\n\tconst upy = up[1]\n\tconst upz = up[2]\n\tconst centerx = center[0]\n\tconst centery = center[1]\n\tconst centerz = center[2]\n\n\tif (\n\t\tMathf.abs(eyex - centerx) < glMatrix.EPSILON &&\n    Mathf.abs(eyey - centery) < glMatrix.EPSILON &&\n    Mathf.abs(eyez - centerz) < glMatrix.EPSILON\n\t) {\n\t\treturn identity(out)\n\t}\n\n\tz0 = eyex - centerx\n\tz1 = eyey - centery\n\tz2 = eyez - centerz\n\n\tlen = 1 / Maths.hypot3(z0, z1, z2)\n\tz0 *= len\n\tz1 *= len\n\tz2 *= len\n\n\tx0 = upy * z2 - upz * z1\n\tx1 = upz * z0 - upx * z2\n\tx2 = upx * z1 - upy * z0\n\tlen = Maths.hypot3(x0, x1, x2)\n\tif (!len) {\n\t\tx0 = 0\n\t\tx1 = 0\n\t\tx2 = 0\n\t} else {\n\t\tlen = 1 / len\n\t\tx0 *= len\n\t\tx1 *= len\n\t\tx2 *= len\n\t}\n\n\ty0 = z1 * x2 - z2 * x1\n\ty1 = z2 * x0 - z0 * x2\n\ty2 = z0 * x1 - z1 * x0\n\n\tlen = Maths.hypot3(y0, y1, y2)\n\tif (!len) {\n\t\ty0 = 0\n\t\ty1 = 0\n\t\ty2 = 0\n\t} else {\n\t\tlen = 1 / len\n\t\ty0 *= len\n\t\ty1 *= len\n\t\ty2 *= len\n\t}\n\n\tout[0] = x0\n\tout[1] = y0\n\tout[2] = z0\n\tout[3] = 0\n\tout[4] = x1\n\tout[5] = y1\n\tout[6] = z1\n\tout[7] = 0\n\tout[8] = x2\n\tout[9] = y2\n\tout[10] = z2\n\tout[11] = 0\n\tout[12] = -(x0 * eyex + x1 * eyey + x2 * eyez)\n\tout[13] = -(y0 * eyex + y1 * eyey + y2 * eyez)\n\tout[14] = -(z0 * eyex + z1 * eyey + z2 * eyez)\n\tout[15] = 1\n\n\treturn out\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out: mat4, eye: vec3.ReadonlyVec3, target: vec3.ReadonlyVec3, up: vec3.ReadonlyVec3): mat4 {\n\tconst eyex = eye[0],\n\t\teyey = eye[1],\n\t\teyez = eye[2],\n\t\tupx = up[0],\n\t\tupy = up[1],\n\t\tupz = up[2]\n\n\tlet z0 = eyex - target[0],\n\t\tz1 = eyey - target[1],\n\t\tz2 = eyez - target[2]\n\n\tlet len = z0 * z0 + z1 * z1 + z2 * z2\n\tif (len > 0) {\n\t\tlen = 1 / Mathf.sqrt(len)\n\t\tz0 *= len\n\t\tz1 *= len\n\t\tz2 *= len\n\t}\n\n\tlet x0 = upy * z2 - upz * z1,\n\t\tx1 = upz * z0 - upx * z2,\n\t\tx2 = upx * z1 - upy * z0\n\n\tlen = x0 * x0 + x1 * x1 + x2 * x2\n\tif (len > 0) {\n\t\tlen = 1 / Mathf.sqrt(len)\n\t\tx0 *= len\n\t\tx1 *= len\n\t\tx2 *= len\n\t}\n\n\tout[0] = x0\n\tout[1] = x1\n\tout[2] = x2\n\tout[3] = 0\n\tout[4] = z1 * x2 - z2 * x1\n\tout[5] = z2 * x0 - z0 * x2\n\tout[6] = z0 * x1 - z1 * x0\n\tout[7] = 0\n\tout[8] = z0\n\tout[9] = z1\n\tout[10] = z2\n\tout[11] = 0\n\tout[12] = eyex\n\tout[13] = eyey\n\tout[14] = eyez\n\tout[15] = 1\n\treturn out\n}\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a: ReadonlyMat4): string {\n\treturn (\n\t\t'mat4(' +\n    a[0].toString() +\n    ', ' +\n    a[1].toString() +\n    ', ' +\n    a[2].toString() +\n    ', ' +\n    a[3].toString() +\n    ', ' +\n    a[4].toString() +\n    ', ' +\n    a[5].toString() +\n    ', ' +\n    a[6].toString() +\n    ', ' +\n    a[7].toString() +\n    ', ' +\n    a[8].toString() +\n    ', ' +\n    a[9].toString() +\n    ', ' +\n    a[10].toString() +\n    ', ' +\n    a[11].toString() +\n    ', ' +\n    a[12].toString() +\n    ', ' +\n    a[13].toString() +\n    ', ' +\n    a[14].toString() +\n    ', ' +\n    a[15].toString() +\n    ')'\n\t)\n}\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a: ReadonlyMat4): f32 {\n\treturn Maths.hypot16(\n\t\ta[0],\n\t\ta[1],\n\t\ta[2],\n\t\ta[3],\n\t\ta[4],\n\t\ta[5],\n\t\ta[6],\n\t\ta[7],\n\t\ta[8],\n\t\ta[9],\n\t\ta[10],\n\t\ta[11],\n\t\ta[12],\n\t\ta[13],\n\t\ta[14],\n\t\ta[15]\n\t)\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\tout[4] = a[4] + b[4]\n\tout[5] = a[5] + b[5]\n\tout[6] = a[6] + b[6]\n\tout[7] = a[7] + b[7]\n\tout[8] = a[8] + b[8]\n\tout[9] = a[9] + b[9]\n\tout[10] = a[10] + b[10]\n\tout[11] = a[11] + b[11]\n\tout[12] = a[12] + b[12]\n\tout[13] = a[13] + b[13]\n\tout[14] = a[14] + b[14]\n\tout[15] = a[15] + b[15]\n\treturn out\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\tout[3] = a[3] - b[3]\n\tout[4] = a[4] - b[4]\n\tout[5] = a[5] - b[5]\n\tout[6] = a[6] - b[6]\n\tout[7] = a[7] - b[7]\n\tout[8] = a[8] - b[8]\n\tout[9] = a[9] - b[9]\n\tout[10] = a[10] - b[10]\n\tout[11] = a[11] - b[11]\n\tout[12] = a[12] - b[12]\n\tout[13] = a[13] - b[13]\n\tout[14] = a[14] - b[14]\n\tout[15] = a[15] - b[15]\n\treturn out\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out: mat4, a: ReadonlyMat4, b: f32): mat4 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\tout[4] = a[4] * b\n\tout[5] = a[5] * b\n\tout[6] = a[6] * b\n\tout[7] = a[7] * b\n\tout[8] = a[8] * b\n\tout[9] = a[9] * b\n\tout[10] = a[10] * b\n\tout[11] = a[11] * b\n\tout[12] = a[12] * b\n\tout[13] = a[13] * b\n\tout[14] = a[14] * b\n\tout[15] = a[15] * b\n\treturn out\n}\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nexport function multiplyScalarAndAdd(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4, scale: f32): mat4 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\tout[3] = a[3] + b[3] * scale\n\tout[4] = a[4] + b[4] * scale\n\tout[5] = a[5] + b[5] * scale\n\tout[6] = a[6] + b[6] * scale\n\tout[7] = a[7] + b[7] * scale\n\tout[8] = a[8] + b[8] * scale\n\tout[9] = a[9] + b[9] * scale\n\tout[10] = a[10] + b[10] * scale\n\tout[11] = a[11] + b[11] * scale\n\tout[12] = a[12] + b[12] * scale\n\tout[13] = a[13] + b[13] * scale\n\tout[14] = a[14] + b[14] * scale\n\tout[15] = a[15] + b[15] * scale\n\treturn out\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyMat4, b: ReadonlyMat4): bool {\n\treturn (\n\t\ta[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5] &&\n    a[6] === b[6] &&\n    a[7] === b[7] &&\n    a[8] === b[8] &&\n    a[9] === b[9] &&\n    a[10] === b[10] &&\n    a[11] === b[11] &&\n    a[12] === b[12] &&\n    a[13] === b[13] &&\n    a[14] === b[14] &&\n    a[15] === b[15]\n\t)\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a: ReadonlyMat4, b: ReadonlyMat4): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst a4 = a[4],\n\t\ta5 = a[5],\n\t\ta6 = a[6],\n\t\ta7 = a[7]\n\tconst a8 = a[8],\n\t\ta9 = a[9],\n\t\ta10 = a[10],\n\t\ta11 = a[11]\n\tconst a12 = a[12],\n\t\ta13 = a[13],\n\t\ta14 = a[14],\n\t\ta15 = a[15]\n\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3]\n\tconst b4 = b[4],\n\t\tb5 = b[5],\n\t\tb6 = b[6],\n\t\tb7 = b[7]\n\tconst b8 = b[8],\n\t\tb9 = b[9],\n\t\tb10 = b[10],\n\t\tb11 = b[11]\n\tconst b12 = b[12],\n\t\tb13 = b[13],\n\t\tb14 = b[14],\n\t\tb15 = b[15]\n\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3)) &&\n    Mathf.abs(a4 - b4) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a4), Mathf.abs(b4)) &&\n    Mathf.abs(a5 - b5) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a5), Mathf.abs(b5)) &&\n    Mathf.abs(a6 - b6) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a6), Mathf.abs(b6)) &&\n    Mathf.abs(a7 - b7) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a7), Mathf.abs(b7)) &&\n    Mathf.abs(a8 - b8) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a8), Mathf.abs(b8)) &&\n    Mathf.abs(a9 - b9) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a9), Mathf.abs(b9)) &&\n    Mathf.abs(a10 - b10) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a10), Mathf.abs(b10)) &&\n    Mathf.abs(a11 - b11) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a11), Mathf.abs(b11)) &&\n    Mathf.abs(a12 - b12) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a12), Mathf.abs(b12)) &&\n    Mathf.abs(a13 - b13) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a13), Mathf.abs(b13)) &&\n    Mathf.abs(a14 - b14) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a14), Mathf.abs(b14)) &&\n    Mathf.abs(a15 - b15) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a15), Mathf.abs(b15))\n\t)\n}\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nexport const sub = subtract\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    var hasSur = <u32>code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    var leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    var length: isize = this.length;\n    var sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyMat2 } from './_mat2'\nimport { ReadonlyMat2d } from './_mat2d'\nimport { ReadonlyMat3 } from './_mat3'\nimport { ReadonlyMat4 } from './_mat4'\n\nexport type vec2 = IndexedCollection;\n\nexport type ReadonlyVec2 = IndexedCollection;\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nexport function create(): vec2 {\n\tconst out = new Float32Array(2)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[0] = 0\n\t\tout[1] = 0\n\t}\n\treturn out\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nexport function clone(a: ReadonlyVec2): vec2 {\n\tconst out = new Float32Array(2)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\treturn out\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nexport function fromValues(x: f32, y: f32): vec2 {\n\tconst out = new Float32Array(2)\n\tout[0] = x\n\tout[1] = y\n\treturn out\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\treturn out\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out: vec2, x: f32, y: f32): vec2 {\n\tout[0] = x\n\tout[1] = y\n\treturn out\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\treturn out\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\treturn out\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = a[0] * b[0]\n\tout[1] = a[1] * b[1]\n\treturn out\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = a[0] / b[0]\n\tout[1] = a[1] / b[1]\n\treturn out\n}\n\n/**\n * Mathf.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\nexport function ceil(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = Mathf.ceil(a[0])\n\tout[1] = Mathf.ceil(a[1])\n\treturn out\n}\n\n/**\n * Mathf.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\nexport function floor(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = Mathf.floor(a[0])\n\tout[1] = Mathf.floor(a[1])\n\treturn out\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function min(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = Mathf.min(a[0], b[0])\n\tout[1] = Mathf.min(a[1], b[1])\n\treturn out\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function max(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tout[0] = Mathf.max(a[0], b[0])\n\tout[1] = Mathf.max(a[1], b[1])\n\treturn out\n}\n\n/**\n * Mathf.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\nexport function round(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = Mathf.round(a[0])\n\tout[1] = Mathf.round(a[1])\n\treturn out\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out: vec2, a: ReadonlyVec2, b: f32): vec2 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\treturn out\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nexport function scaleAndAdd(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, scale: f32): vec2 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\treturn out\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a: ReadonlyVec2, b: ReadonlyVec2): f32 {\n\tconst x = b[0] - a[0],\n\t\ty = b[1] - a[1]\n\treturn Mathf.hypot(x, y)\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a: ReadonlyVec2, b: ReadonlyVec2): f32 {\n\tconst x = b[0] - a[0],\n\t\ty = b[1] - a[1]\n\treturn x * x + y * y\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a: ReadonlyVec2): f32 {\n\tconst x = a[0],\n\t\ty = a[1]\n\treturn Mathf.hypot(x, y)\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a: ReadonlyVec2): f32 {\n\tconst x = a[0],\n\t\ty = a[1]\n\treturn x * x + y * y\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = -a[0]\n\tout[1] = -a[1]\n\treturn out\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out: vec2, a: ReadonlyVec2): vec2 {\n\tout[0] = 1.0 / a[0]\n\tout[1] = 1.0 / a[1]\n\treturn out\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out: vec2, a: ReadonlyVec2): vec2 {\n\tconst x = a[0],\n\t\ty = a[1]\n\tlet len = x * x + y * y\n\tif (len > 0) {\n\t\t//TODO: evaluate use of glm_invsqrt here?\n\t\tlen = 1 / Mathf.sqrt(len)\n\t}\n\tout[0] = a[0] * len\n\tout[1] = a[1] * len\n\treturn out\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a: ReadonlyVec2, b: ReadonlyVec2): f32 {\n\treturn a[0] * b[0] + a[1] * b[1]\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2 {\n\tconst z = a[0] * b[1] - a[1] * b[0]\n\tout[0] = out[1] = 0\n\tout[2] = z\n\treturn out\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, t: f32): vec2 {\n\tconst ax = a[0],\n\t\tay = a[1]\n\tout[0] = ax + t * (b[0] - ax)\n\tout[1] = ay + t * (b[1] - ay)\n\treturn out\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec2} out\n */\nexport function random(out: vec2, scale: f32): vec2 {\n\tscale = scale || 1.0\n\tconst r = glMatrix.RANDOM() * 2.0 * Mathf.PI\n\tout[0] = Mathf.cos(r) * scale\n\tout[1] = Mathf.sin(r) * scale\n\treturn out\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out: vec2, a: ReadonlyVec2, m: ReadonlyMat2): vec2 {\n\tconst x = a[0],\n\t\ty = a[1]\n\tout[0] = m[0] * x + m[2] * y\n\tout[1] = m[1] * x + m[3] * y\n\treturn out\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out: vec2, a: ReadonlyVec2, m: ReadonlyMat2d): vec2 {\n\tconst x = a[0],\n\t\ty = a[1]\n\tout[0] = m[0] * x + m[2] * y + m[4]\n\tout[1] = m[1] * x + m[3] * y + m[5]\n\treturn out\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out: vec2, a: ReadonlyVec2, m: ReadonlyMat3): vec2 {\n\tconst x = a[0],\n\t\ty = a[1]\n\tout[0] = m[0] * x + m[3] * y + m[6]\n\tout[1] = m[1] * x + m[4] * y + m[7]\n\treturn out\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out: vec2, a: ReadonlyVec2, m: ReadonlyMat4): vec2 {\n\tconst x = a[0]\n\tconst y = a[1]\n\tout[0] = m[0] * x + m[4] * y + m[12]\n\tout[1] = m[1] * x + m[5] * y + m[13]\n\treturn out\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\nexport function rotate(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, rad: f32): vec2 {\n\t//Translate point to the origin\n\tconst p0 = a[0] - b[0],\n\t\tp1 = a[1] - b[1],\n\t\tsinC = Mathf.sin(rad),\n\t\tcosC = Mathf.cos(rad)\n\n\t//perform rotation and translate to correct position\n\tout[0] = p0 * cosC - p1 * sinC + b[0]\n\tout[1] = p0 * sinC + p1 * cosC + b[1]\n\n\treturn out\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a: ReadonlyVec2, b: ReadonlyVec2): f32 {\n\tconst x1 = a[0],\n\t\ty1 = a[1],\n\t\tx2 = b[0],\n\t\ty2 = b[1],\n\t\t// mag is the product of the magnitudes of a and b\n\t\tmag = Mathf.sqrt(x1 * x1 + y1 * y1) * Mathf.sqrt(x2 * x2 + y2 * y2),\n\t\t// mag &&.. short circuits if mag == 0\n\t\tcosine = mag && (x1 * x2 + y1 * y2) / mag\n\t// Mathf.min(Mathf.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\treturn Mathf.acos(Mathf.min(Mathf.max(cosine, -1), 1))\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nexport function zero(out: vec2): vec2 {\n\tout[0] = 0.0\n\tout[1] = 0.0\n\treturn out\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a: ReadonlyVec2): string {\n\treturn 'vec2(' + a[0].toString() + ', ' + a[1].toString() + ')'\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyVec2, b: ReadonlyVec2): bool {\n\treturn a[0] === b[0] && a[1] === b[1]\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a: ReadonlyVec2, b: ReadonlyVec2): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1]\n\tconst b0 = b[0],\n\t\tb1 = b[1]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1))\n\t)\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nexport const len = length\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nexport const sub = subtract\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nexport const div = divide\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nexport const dist = distance\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n","import * as glMatrix from './_common'\nimport { IndexedCollection } from './imports'\nimport { Maths } from './maths'\nimport { ReadonlyVec2 } from './_vec2'\n\nexport type mat2 = IndexedCollection;\n\nexport type ReadonlyMat2 = IndexedCollection;\n\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nexport function create(): mat2 {\n\tconst out = new Float32Array(4)\n\tif (glMatrix.ARRAY_TYPE != glMatrix.ArrayTypeEnum.Float32ArrayT) {\n\t\tout[1] = 0\n\t\tout[2] = 0\n\t}\n\tout[0] = 1\n\tout[3] = 1\n\treturn out\n}\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nexport function clone(a: ReadonlyMat2): mat2 {\n\tconst out = new Float32Array(4)\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\nexport function copy(out: mat2, a: ReadonlyMat2): mat2 {\n\tout[0] = a[0]\n\tout[1] = a[1]\n\tout[2] = a[2]\n\tout[3] = a[3]\n\treturn out\n}\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nexport function identity(out: mat2): mat2 {\n\tout[0] = 1\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = 1\n\treturn out\n}\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nexport function fromValues(m00: f32, m01: f32, m10: f32, m11: f32): mat2 {\n\tconst out = new Float32Array(4)\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m10\n\tout[3] = m11\n\treturn out\n}\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nexport function set(out: mat2, m00: f32, m01: f32, m10: f32, m11: f32): mat2 {\n\tout[0] = m00\n\tout[1] = m01\n\tout[2] = m10\n\tout[3] = m11\n\treturn out\n}\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\nexport function transpose(out: mat2, a: ReadonlyMat2): mat2 {\n\t// If we are transposing ourselves we can skip a few steps but have to cache\n\t// some values\n\tif (out === a) {\n\t\tconst a1 = a[1]\n\t\tout[1] = a[2]\n\t\tout[2] = a1\n\t} else {\n\t\tout[0] = a[0]\n\t\tout[1] = a[2]\n\t\tout[2] = a[1]\n\t\tout[3] = a[3]\n\t}\n\n\treturn out\n}\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\nexport function invert(out: mat2, a: ReadonlyMat2): mat2 | null {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\n\t// Calculate the determinant\n\tlet det = a0 * a3 - a2 * a1\n\n\tif (!det) {\n\t\treturn null\n\t}\n\tdet = 1.0 / det\n\n\tout[0] = a3 * det\n\tout[1] = -a1 * det\n\tout[2] = -a2 * det\n\tout[3] = a0 * det\n\n\treturn out\n}\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\nexport function adjoint(out: mat2, a: ReadonlyMat2): mat2 {\n\t// Caching this value is necessary if out == a\n\tconst a0 = a[0]\n\tout[0] = a[3]\n\tout[1] = -a[1]\n\tout[2] = -a[2]\n\tout[3] = a0\n\n\treturn out\n}\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {ReadonlyMat2} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a: ReadonlyMat2): f32 {\n\treturn a[0] * a[3] - a[2] * a[1]\n}\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\nexport function multiply(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2 {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3]\n\tout[0] = a0 * b0 + a2 * b1\n\tout[1] = a1 * b0 + a3 * b1\n\tout[2] = a0 * b2 + a2 * b3\n\tout[3] = a1 * b2 + a3 * b3\n\treturn out\n}\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nexport function rotate(out: mat2, a: ReadonlyMat2, rad: f32): mat2 {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tout[0] = a0 * c + a2 * s\n\tout[1] = a1 * c + a3 * s\n\tout[2] = a0 * -s + a2 * c\n\tout[3] = a1 * -s + a3 * c\n\treturn out\n}\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nexport function scale(out: mat2, a: ReadonlyMat2, v: ReadonlyVec2): mat2 {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst v0 = v[0],\n\t\tv1 = v[1]\n\tout[0] = a0 * v0\n\tout[1] = a1 * v0\n\tout[2] = a2 * v1\n\tout[3] = a3 * v1\n\treturn out\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nexport function fromRotation(out: mat2, rad: f32): mat2 {\n\tconst s = Mathf.sin(rad)\n\tconst c = Mathf.cos(rad)\n\tout[0] = c\n\tout[1] = s\n\tout[2] = -s\n\tout[3] = c\n\treturn out\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2} out\n */\nexport function fromScaling(out: mat2, v: ReadonlyVec2): mat2 {\n\tout[0] = v[0]\n\tout[1] = 0\n\tout[2] = 0\n\tout[3] = v[1]\n\treturn out\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {ReadonlyMat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a: ReadonlyMat2): string {\n\treturn 'mat2(' + a[0].toString() + ', ' + a[1].toString() + ', ' + a[2].toString() + ', ' + a[3].toString() + ')'\n}\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a: ReadonlyMat2): f32 {\n\treturn Maths.hypot4(a[0], a[1], a[2], a[3])\n}\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {ReadonlyMat2} L the lower triangular matrix\n * @param {ReadonlyMat2} D the diagonal matrix\n * @param {ReadonlyMat2} U the upper triangular matrix\n * @param {ReadonlyMat2} a the input matrix to factorize\n * @returns {Array<ReadonlyMat2>} LDU\n */\n\nexport function LDU(L: ReadonlyMat2, D: ReadonlyMat2, U: ReadonlyMat2, a: ReadonlyMat2): Array<ReadonlyMat2> {\n\tL[2] = a[2] / a[0]\n\tU[0] = a[0]\n\tU[1] = a[1]\n\tU[3] = a[3] - L[2] * U[1]\n\treturn [L, D, U]\n}\n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\nexport function add(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2 {\n\tout[0] = a[0] + b[0]\n\tout[1] = a[1] + b[1]\n\tout[2] = a[2] + b[2]\n\tout[3] = a[3] + b[3]\n\treturn out\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\nexport function subtract(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2 {\n\tout[0] = a[0] - b[0]\n\tout[1] = a[1] - b[1]\n\tout[2] = a[2] - b[2]\n\tout[3] = a[3] - b[3]\n\treturn out\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a: ReadonlyMat2, b: ReadonlyMat2): bool {\n\treturn a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a: ReadonlyMat2, b: ReadonlyMat2): bool {\n\tconst a0 = a[0],\n\t\ta1 = a[1],\n\t\ta2 = a[2],\n\t\ta3 = a[3]\n\tconst b0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3]\n\treturn (\n\t\tMathf.abs(a0 - b0) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a0), Mathf.abs(b0)) &&\n    Mathf.abs(a1 - b1) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a1), Mathf.abs(b1)) &&\n    Mathf.abs(a2 - b2) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a2), Mathf.abs(b2)) &&\n    Mathf.abs(a3 - b3) <=\n      glMatrix.EPSILON * Maths.max(1.0, Mathf.abs(a3), Mathf.abs(b3))\n\t)\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nexport function multiplyScalar(out: mat2, a: ReadonlyMat2, b: f32): mat2 {\n\tout[0] = a[0] * b\n\tout[1] = a[1] * b\n\tout[2] = a[2] * b\n\tout[3] = a[3] * b\n\treturn out\n}\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nexport function multiplyScalarAndAdd(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2, scale: f32): mat2 {\n\tout[0] = a[0] + b[0] * scale\n\tout[1] = a[1] + b[1] * scale\n\tout[2] = a[2] + b[2] * scale\n\tout[3] = a[3] + b[3] * scale\n\treturn out\n}\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nexport const mul = multiply\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nexport const sub = subtract\n","import { mat4, quat } from '../glMatrix'\nimport { EPSILON } from './constants'\nimport { Matrix } from './Matrix'\nimport { Vector3 } from './Vector3'\n\n\nexport class Quaternion{\n\t\n\t\n\tstatic tmp0: Quaternion = new Quaternion()\n\tstatic new(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1): Quaternion{ \n\t\treturn new Quaternion(x, y, z, w) }\n\tstatic dot(a: Quaternion, b: Quaternion): f32{\n\t\treturn quat.dot(a.m, b.m)\n\t}\n\tstatic get identity(): Quaternion{ \n\t\treturn new Quaternion() }\n\tstatic look(direction: Vector3, up: Vector3 = Vector3._up, ref: Quaternion = new Quaternion()): Quaternion{ \n\t\treturn ref.lookAt(direction, up) }\n\t// static right(ref: Quaternion = new Quaternion()): Quaternion{ \n\t// \treturn ref.lookRotation(Vector3.right) }\n\t// static up(ref: Quaternion = new Quaternion()): Quaternion{ \n\t// \treturn ref.lookRotation(Vector3.up) }\n\n\tstatic fromArray(m: Float32Array): Quaternion{\n\t\tconst quat = new Quaternion()\n\t\tquat.m = m\n\t\treturn quat\n\t}\n\n\t\t\t\t\t\t\n\tm: Float32Array\n\tget x(): f32{ return this.m[0] } set x(val: f32){ this.m[0] = val }\n\tget y(): f32{ return this.m[1] } set y(val: f32){ this.m[1] = val }\n\tget z(): f32{ return this.m[2] } set z(val: f32){ this.m[2] = val }\n\tget w(): f32{ return this.m[3] } set w(val: f32){ this.m[3] = val }\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1){ \n\t\tthis.m = new Float32Array(4)\n\t\tthis.x = x; this.y = y; this.z = z; this.w = w\n\t}\n\tset(x: f32, y: f32, z: f32, w: f32): Quaternion{ \n\t\tthis.x = x; this.y = y; this.z = z; this.w = w; return this }\n\n\tforward(): Vector3 { \n\t\treturn this.multiplyDirection(Vector3._forward) }\n\tup(): Vector3 { \n\t\treturn this.multiplyDirection(Vector3._up) }\n\tright(): Vector3 { \n\t\treturn this.multiplyDirection(Vector3._right) }\n\t\n\tmultiplyDirection(direction: Vector3, ref: Vector3 = new Vector3()): Vector3 {\n\t\tconst x = this.x * 2\n\t\tconst y = this.y * 2\n\t\tconst z = this.z * 2\n\t\tconst xx = this.x * x\n\t\tconst yy = this.y * y\n\t\tconst zz = this.z * z\n\t\tconst xy = this.x * y\n\t\tconst xz = this.x * z\n\t\tconst yz = this.y * z\n\t\tconst wx = this.w * x\n\t\tconst wy = this.w * y\n\t\tconst wz = this.w * z\n\t\t\n\t\tref.x = (1 - (yy + zz)) * direction.x + (xy - wz) * direction.y + (xz + wy) * direction.z\n\t\tref.y = (xy + wz) * direction.x + (1 - (xx + zz)) * direction.y + (yz - wx) * direction.z\n\t\tref.z = (xz - wy) * direction.x + (yz + wx) * direction.y + (1 - (xx + yy)) * direction.z\n\t\treturn ref\n\t}\n\trotate(x: f32 = 0, y: f32 = 0, z: f32 = 0): Quaternion{\n\t\tconst euler = this.toEulerAngles()\n\t\teuler.x += x\n\t\teuler.y += y\n\t\teuler.z += z\n\t\tthis.fromEulerAngles(euler)\n\t\treturn this\n\t}\n\n\t\n\t// applyQuaternion(q: Quaternion): Vector3 {\n\t// \tconst x = this.x, y = this.y, z = this.z\n\t// \tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w\n\t// \tconst ix = qw * x + qy * z - qz * y\n\t// \tconst iy = qw * y + qz * x - qx * z\n\t// \tconst iz = qw * z + qx * y - qy * x\n\t// \tconst iw = - qx * x - qy * y - qz * z\n\t// \tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy\n\t// \tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz\n\t// \tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx\n\t// \treturn this\n\t// }\n\t// lookAt(pos: Vector3, target: Vector3, up: Vector3 = Vector3.up): Quaternion{\n\t// \tMatrix._tmp0.setPosition(pos)\n\t// \tconst matrix = Matrix._tmp0.lookAt(target, up)\n\t// \t// matrix.invert()\n\t// \treturn this.fromRotationMatrix(matrix)\n\t// }\n\tlookAt(target: Vector3, up: Vector3 = Vector3._up): Quaternion{\n\t\tmat4.fromTranslation(Matrix._tmp0.m, Vector3._zero.m)\n\t\tMatrix._tmp0.lookAt(target, up)\n\t\tmat4.getRotation(this.m, Matrix._tmp0.m)\n\t\treturn this\n\t}\n\tangleAxis(theta: f32, axis: Vector3 = Vector3.forward): Quaternion{\n\t\tconst s = Mathf.sin(theta / 2)\n\t\tthis.x = axis.x * s,\n\t\tthis.y = axis.y * s,\n\t\tthis.z = axis.z * s,\n\t\tthis.w = Mathf.cos(theta / 2)\n\t\treturn this\n\t}\n\t\n\tfromRotationMatrix(matrix: Matrix): Quaternion{\n\t\tconst m = matrix.m\n\t\tconst m11 = m[0], m12 = m[4], m13 = m[8]\n\t\tconst m21 = m[1], m22 = m[5], m23 = m[9]\n\t\tconst m31 = m[2], m32 = m[6], m33 = m[10]\n\t\tconst trace = m11 + m22 + m33\n\t\tlet s: f32\n\t\tif (trace > 0) {\n\t\t\ts = 0.5 / Mathf.sqrt(trace + 1.0)\n\t\t\tthis.w = 0.25 / s\n\t\t\tthis.x = (m32 - m23) * s\n\t\t\tthis.y = (m13 - m31) * s\n\t\t\tthis.z = (m21 - m12) * s\n\t\t} else if (m11 > m22 && m11 > m33) {\t\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m11 - m22 - m33)\n\t\t\tthis.w = (m32 - m23) / s\n\t\t\tthis.x = 0.25 * s\n\t\t\tthis.y = (m12 + m21) / s\n\t\t\tthis.z = (m13 + m31) / s\n\t\t} else if (m22 > m33) {\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m22 - m11 - m33)\n\t\t\tthis.w = (m13 - m31) / s\n\t\t\tthis.x = (m12 + m21) / s\n\t\t\tthis.y = 0.25 * s\n\t\t\tthis.z = (m23 + m32) / s\n\t\t} else {\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m33 - m11 - m22)\n\t\t\tthis.w = (m21 - m12) / s\n\t\t\tthis.x = (m13 + m31) / s\n\t\t\tthis.y = (m23 + m32) / s\n\t\t\tthis.z = 0.25 * s\n\t\t}\n\t\treturn this\n\t}\n\n\t//z-y-x order, Tait-Bryan\n\tfromEulerAngles(angles: Vector3): Quaternion{\n\t\tconst yaw = angles.y\n\t\tconst pitch = angles.x\n\t\tconst roll = angles.z\n\n\t\tconst halfRoll = roll * 0.5\n\t\tconst halfPitch = pitch * 0.5\n\t\tconst halfYaw = yaw * 0.5\n\t\n\t\tconst sinRoll = Mathf.sin(halfRoll)\n\t\tconst cosRoll = Mathf.cos(halfRoll)\n\t\tconst sinPitch = Mathf.sin(halfPitch)\n\t\tconst cosPitch = Mathf.cos(halfPitch)\n\t\tconst sinYaw = Mathf.sin(halfYaw)\n\t\tconst cosYaw = Mathf.cos(halfYaw)\n\t\n\t\tthis.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll)\n\t\tthis.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll)\n\t\tthis.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll)\n\t\tthis.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll)\n\t\treturn this\n\t}\n\n\ttoEulerAngles(result: Vector3 = new Vector3()): Vector3 {\n\t\tconst qx = this.x\n\t\tconst qy = this.y\n\t\tconst qz = this.z\n\t\tconst qw = this.w\n\n\t\tconst sqx = qx * qx\n\t\tconst sqy = qy * qy\n\t\tconst sqz = qz * qz\n\t\tconst sqw = qw * qw\n\n\t\tconst zAxisY = qy * qz - qx * qw\n\t\tconst limit = <f32>.4999999\n\n\t\tif (zAxisY < -limit) {\n\t\t\tresult.y = <f32>2 * Mathf.atan2(qy, qw)\n\t\t\tresult.x = Mathf.PI / 2\n\t\t\tresult.z = 0\n\t\t} else if (zAxisY > limit) {\n\t\t\tresult.y = 2 * Mathf.atan2(qy, qw)\n\t\t\tresult.x = -Mathf.PI / 2\n\t\t\tresult.z = 0\n\t\t} else {\n\t\t\tresult.z = Mathf.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw))\n\t\t\tresult.x = Mathf.asin(-2.0 * (qz * qy - qx * qw))\n\t\t\tresult.y = Mathf.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw))\n\t\t}\n\t\treturn result\n\t}\n\n\n\t// @operator('==')\n\tisEqual (b: Quaternion): boolean\n\t{ return this.x == b.x && this.y == b.y && this.z == b.z && this.w == b.w }\n\t// @operator('!=')\n\tisNotEqual (b: Quaternion): boolean\n\t{ return this.x != b.x || this.y != b.y || this.z != b.z || this.w !== b.w }\n\t// isAlmostEqual (b: Quaternion): boolean\n\t// { return Math2.isAlmostEqual(this.x, b.x)\n\t// \t&& Math2.isAlmostEqual(this.y, b.y)\n\t// \t&& Math2.isAlmostEqual(this.z, b.z) \n\t// \t&& Math2.isAlmostEqual(this.w, b.w) \n\t// }\n\tisAlmostEqual (b: Quaternion): boolean\n\t{\n\t\treturn 1 - Mathf.abs(Quaternion.dot(this, b)) < EPSILON\n\t}\n\n}","import { mat4 } from '../glMatrix'\nimport { Quaternion } from './Quaternion'\nimport { Vector3 } from './Vector3'\n\nexport class Matrix{\n\tstatic new(): Matrix{ return new Matrix() }\n\tstatic get identity(): Matrix{ return new Matrix() }\n\tstatic _identity: Matrix = Matrix.identity\n\tstatic _tmp0: Matrix = new Matrix()\t\n\n\tstatic multiply(out: Matrix, a: Matrix, b: Matrix): Matrix{\n\t\tmat4.multiply(out.m, a.m, b.m)\n\t\treturn out\n\t}\n\tstatic transpose(out: Matrix, a: Matrix): Matrix{\n\t\tmat4.transpose(out.m, a.m)\n\t\treturn out\n\t}\n\n\tm: Float32Array\n\n\tconstructor(m: Float32Array = new Float32Array(16)){\n\t\tthis.m = m\n\t\tmat4.identity(this.m)\n\t}\n\tidentity(): Matrix{\n\t\tmat4.identity(this.m)\n\t\treturn this\n\t}\n\tsetRows(\n\t\tm11: f32 = 1, m12: f32 = 0, m13: f32 = 0, m14: f32 = 0,\n\t\tm21: f32 = 0, m22: f32 = 1, m23: f32 = 0, m24: f32 = 0,\n\t\tm31: f32 = 0, m32: f32 = 0, m33: f32 = 1, m34: f32 = 0,\n\t\tm41: f32 = 0, m42: f32 = 0, m43: f32 = 0, m44: f32 = 1): Matrix {\n\t\tconst m = this.m\n\t\tm[ 0 ] = m11; m[ 4 ] = m12; m[ 8 ] = m13; m[ 12 ] = m14\n\t\tm[ 1 ] = m21; m[ 5 ] = m22; m[ 9 ] = m23; m[ 13 ] = m24\n\t\tm[ 2 ] = m31; m[ 6 ] = m32; m[ 10 ] = m33; m[ 14 ] = m34\n\t\tm[ 3 ] = m41; m[ 7 ] = m42; m[ 11 ] = m43; m[ 15 ] = m44\n\t\treturn this\n\t}\n\n\tscaledRight(target: Vector3 = new Vector3()): Vector3{ target.set(this.m[0], this.m[1], this.m[2]); return target }\n\tscaledUp(target: Vector3 = new Vector3()): Vector3{ target.set(this.m[4], this.m[5], this.m[6]); return target }\n\tscaledForward(target: Vector3 = new Vector3()): Vector3{ target.set(this.m[8], this.m[9], this.m[10]); return target }\n\tposition(target: Vector3 = new Vector3()): Vector3{ target.set(this.m[12], this.m[13], this.m[14]); return target }\n\t// right(): Vector3{ return new Vector3(this.m[0], this.m[4], this.m[8]) }\n\t// up(): Vector3{ return new Vector3(this.m[1], this.m[5], this.m[9]) }\n\t// forward(): Vector3{ return new Vector3(this.m[2], this.m[6], this.m[10]) }\n\t// position(target: Vector3 = new Vector3): Vector3{ target.x = this.m[3]; target.y = this.m[7]; target.z = this.m[11]; return target }\n\tclone(o: Matrix = new Matrix()): Matrix{ o.m.set(this.m); return o }\n\n\trotation(target: Quaternion = new Quaternion()): Quaternion{\n\t\tmat4.getRotation(target.m, this.m)\n\t\treturn target\n\t}\n\tscale(target: Vector3 = new Vector3()): Vector3\n\t{\n\t\tmat4.getScaling(target.m, this.m)\n\t\treturn target\n\t}\n\t\n\tisIdentity(): boolean{\n\t\tconst m = this.m\n\t\treturn m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 &&\n\t\tm[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 &&\n\t\tm[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 &&\n\t\tm[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0\n\t}\n\ttransformDirection (vec: Vector3, target: Vector3 = new Vector3()): Vector3{\n\t\tconst m = this.m\n\t\ttarget.x = \tvec.x * m[0] + vec.y * m[4] + vec.z * m[8]\n\t\ttarget.y = \tvec.x * m[1] + vec.y * m[5] + vec.z * m[9]\n\t\ttarget.z = \tvec.x * m[2] + vec.y * m[6] + vec.z * m[10]\n\t\t//target.normalize()\n\t\treturn target\n\t}\n\ttransformPoint (vec: Vector3, target: Vector3 = new Vector3()): Vector3 {\n\t\tconst m = this.m\n\t\tconst rw = <f32>1 / (vec.x * m[3] + vec.y * m[7] + vec.z * m[11] + m[15])\n\t\ttarget.x = vec.x * m[0] + vec.y * m[4] + vec.z * m[8] + m[12] * rw\n\t\ttarget.y = vec.x * m[1] + vec.y * m[5] + vec.z * m[9] + m[13] * rw\n\t\ttarget.z = vec.x * m[2] + vec.y * m[6] + vec.z * m[10] + m[14] * rw\n\t\treturn target\n\t}\n\n\t\n\tlookAt(target: Vector3, up: Vector3 = Vector3._up): Matrix{\n\t\tthis.position(Vector3._tmp0)\n\t\tmat4.targetTo(this.m, target.m, Vector3._tmp0.m, up.m)\n\t\treturn this\n\t}\n\t\n\tlookAway(target: Vector3, up: Vector3 = Vector3._up): Matrix{\n\t\tthis.position(Vector3._tmp0)\n\t\tmat4.targetTo(this.m, Vector3._tmp0.m, target.m, up.m)\n\t\treturn this\n\t}\n\n\tsetPosition(pos: Vector3): Matrix{\n\t\tthis.m[12] = pos.x; this.m[13] = pos.y; this.m[14] = pos.z\n\t\treturn this\n\t}\n\t\n\t\n\tcopy(a: Matrix): Matrix{\n\t\tmat4.copy(this.m, a.m)\n\t\treturn this\n\t}\n\tinvert(a: Matrix = this): Matrix{\n\t\tmat4.invert(this.m, a.m)\n\t\treturn this\n\t}\n\tperspective(fovy: f32, aspect: f32, near: f32, far: f32): Matrix{\n\t\tmat4.perspective(this.m, fovy, aspect, near, far)\n\t\treturn this\n\t}\n\t\n\tmultiply(b: Matrix): Matrix{\n\t\tmat4.multiply(this.m, this.m, b.m)\n\t\treturn this\n\t}\n\n\tcompose(position: Vector3, rotation: Quaternion, scale: Vector3): Matrix{\n\t\tmat4.fromRotationTranslationScale(this.m, rotation.m, position.m, scale.m)\n\t\treturn this\n\t}\t\n\t\n\tdecompose(position: Vector3, rotation: Quaternion, scale: Vector3): Matrix{\n\t\tmat4.getTranslation(position.m, this.m)\n\t\t//TODO optimize, this gets scaling twice\n\t\tmat4.getRotation(rotation.m, this.m)\n\t\tmat4.getScaling(scale.m, this.m)\n\t\treturn this\n\t}\n\t\n\t/*\n\n\t\t// applyMatrix3(matrix: Matrix): Vector3 {\n\t// \tconst x = this.x, y = this.y, z = this.z\n\t// \tconst m = matrix.m\n\t// \tthis.x = m[ 0 ] * x + m[ 3 ] * y + m[ 6 ] * z\n\t// \tthis.y = m[ 1 ] * x + m[ 4 ] * y + m[ 7 ] * z\n\t// \tthis.z = m[ 2 ] * x + m[ 5 ] * y + m[ 8 ] * z\n\t// \treturn this\n\t// }\n\t// applyMatrix4(matrix: Matrix): Vector3 {\n\t// \tconst x = this.x, y = this.y, z = this.z\n\t// \tconst m = matrix.m\n\t// \tconst w = 1 / (m[ 3 ] * x + m[ 7 ] * y + m[ 11 ] * z + m[ 15 ])\n\t// \tthis.x = (m[ 0 ] * x + m[ 4 ] * y + m[ 8 ] * z + m[ 12 ]) * w\n\t// \tthis.y = (m[ 1 ] * x + m[ 5 ] * y + m[ 9 ] * z + m[ 13 ]) * w\n\t// \tthis.z = (m[ 2 ] * x + m[ 6 ] * y + m[ 10 ] * z + m[ 14 ]) * w\n\t// \treturn this\n\t// }\n\n\t*/\n}","import { Math2 } from './aliases'\nimport { Matrix } from './Matrix'\n// import { Quaternion } from './Quaternion'\n\n\n\nexport class Vector3{\n\tstatic new(x: f32 = 0, y: f32 = 0, z: f32 = 0): Vector3{ \n\t\treturn new Vector3(x, y, z) }\n\tstatic _tmp0: Vector3 = new Vector3()\n\tstatic _tmpX: Vector3 = new Vector3()\n\tstatic _tmpY: Vector3 = new Vector3()\n\tstatic _tmpZ: Vector3 = new Vector3()\n\n\tstatic get zero(): Vector3{\treturn new Vector3(0, 0, 0) }\n\tstatic get one(): Vector3{\treturn new Vector3(1, 1, 1) }\n\tstatic get right(): Vector3{ return new Vector3(1, 0, 0) }\n\tstatic get up(): Vector3{ return new Vector3(0, 1, 0) }\n\tstatic get forward(): Vector3{ return new Vector3(0, 0, 1) }\n\tstatic get left(): Vector3{ return new Vector3(-1, 0, 0) }\n\tstatic get down(): Vector3{ return new Vector3(0, -1, 0) }\n\tstatic get back(): Vector3{ return new Vector3(0, 0, -1) }\n\t\n\tstatic readonly _zero: Vector3 = Vector3.zero\n\tstatic readonly _one: Vector3 = Vector3.one\n\tstatic readonly _right: Vector3 = Vector3.right\n\tstatic readonly _up: Vector3 = Vector3.up\n\tstatic readonly _forward: Vector3 = Vector3.forward\n\tstatic readonly _left: Vector3 = Vector3.left\n\tstatic readonly _down: Vector3 = Vector3.down\n\tstatic readonly _back: Vector3 = Vector3.back\n\t\n\tstatic dot(a: Vector3, b: Vector3): f32{\n\t\treturn a.x * b.x + a.y * b.y + a.z * b.z }\n\tstatic lerp (a: Vector3, b: Vector3, t: f32, ref: Vector3 = new Vector3()): Vector3 {\n\t\tref.x = Math2.lerp(a.x, b.x, t)\n\t\tref.y = Math2.lerp(a.y, b.y, t)\n\t\tref.z = Math2.lerp(a.z, b.z, t)\n\t\treturn ref\n\t}\n\tstatic cross (a: Vector3, b: Vector3, ref: Vector3 = new Vector3()): Vector3{\n\t\tconst ax = a.x, ay = a.y, az = a.z\n\t\tconst bx = b.x, by = b.y, bz = b.z\n\t\tref.x = ay * bz - az * by\n\t\tref.y = az * bx - ax * bz\n\t\tref.z = ax * by - ay * bx\n\t\treturn ref\n\t}\n\tstatic crossNormalized (a: Vector3, b: Vector3, ref: Vector3 = new Vector3()): Vector3{\n\t\tconst ax = a.x, ay = a.y, az = a.z\n\t\tconst bx = b.x, by = b.y, bz = b.z\n\t\tref.x = ay * bz - az * by\n\t\tref.y = az * bx - ax * bz\n\t\tref.z = ax * by - ay * bx\n\t\tref.normalize()\n\t\treturn ref\n\t}\n\tstatic randomInBox(ref: Vector3 = new Vector3()): Vector3 {\n\t\tref.x = Mathf.random()\n\t\tref.y = Mathf.random()\n\t\tref.z = Mathf.random()\n\t\treturn ref\n\t}\n\n\tstatic random(ref: Vector3 = new Vector3()): Vector3 {\n\t\tconst u = (Mathf.random() - 0.5) * 2\n\t\tconst t = Mathf.random() * Mathf.PI * 2\n\t\tconst f = Mathf.sqrt(1 - u ** 2)\n\t\tref.x = f * Mathf.cos(t)\n\t\tref.y = f * Mathf.sin(t)\n\t\tref.z = u\n\t\treturn ref\n\t}\n\n\tstatic fromArray(m: Float32Array): Vector3{\n\t\tconst vec = new Vector3()\n\t\tvec.m = m\n\t\treturn vec\n\t}\n\tstatic fromMatrix(mat: Matrix): Vector3{\n\t\tconst offset = Float32Array.BYTES_PER_ELEMENT * 12\n\t\treturn Vector3.fromArray(Float32Array.wrap(mat.m.buffer, offset, 3))\n\t}\n\tget x(): f32{ return this.m[0] } set x(val: f32){ this.m[0] = val }\n\tget y(): f32{ return this.m[1] } set y(val: f32){ this.m[1] = val }\n\tget z(): f32{ return this.m[2] } set z(val: f32){ this.m[2] = val }\n\t\n\tm: Float32Array\n\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0){\n\t\tthis.m = new Float32Array(3)\n\t\tthis.m[0] = x\n\t\tthis.m[1] = y\n\t\tthis.m[2] = z\n\t}\n\ttoString(): string{\n\t\treturn `${this.x}, ${this.y}, ${this.z}`\n\t}\n\tclone(ref: Vector3 = new Vector3()): Vector3{\n\t\tref.x = this.x; ref.y = this.y; ref.z = this.z; return ref }\n\tset(x: f32, y: f32, z: f32): Vector3 { \n\t\tthis.x = x; this.y = y; this.z = z; return this }\n\n\tlengthSquared(): f32 {\t\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z }\n\tlength(): f32{\n\t\treturn Mathf.sqrt(this.lengthSquared())\n\t}\n\tclampLength (maxLength: f32): Vector3 {\n\t\tconst sqrmag = this.lengthSquared()\n\t\tif (sqrmag > maxLength * maxLength) {\n\t\t\tconst mag = Mathf.sqrt(sqrmag)\n\t\t\tconst nx = this.x / mag\n\t\t\tconst ny = this.y / mag\n\t\t\tconst nz = this.z / mag\n\t\n\t\t\tthis.x = nx * maxLength\n\t\t\tthis.y = ny * maxLength\n\t\t\tthis.z = nz * maxLength\n\t\t}\n\t\treturn this\n\t}\t\n\t\n\tround (): Vector3 {\n\t\tthis.x = Mathf.round(this.x)\n\t\tthis.y = Mathf.round(this.y)\n\t\tthis.z = Mathf.round(this.z)\n\t\treturn this\n\t}\n\t\t\n\tswapXZ (): Vector3 {\n\t\tconst temp = this.z\n\t\tthis.x = this.z\n\t\tthis.z = temp\n\t\treturn this\n\t}\n\tnegate(): Vector3 {\n\t\tthis.x = - this.x\n\t\tthis.y = - this.y\n\t\tthis.z = - this.z\n\t\treturn this\n\t}\n\n\tabs(): Vector3{\n\t\tthis.x = Mathf.abs(this.x)\n\t\tthis.y = Mathf.abs(this.y)\n\t\tthis.z = Mathf.abs(this.z)\n\t\treturn this\n\t}\n\n\tnormalize (): Vector3 {\n\t\treturn this.scaleDiv(this.length()) }\n\t\n\tnormalizeFromLength (len: f32): Vector3 {\n\t\tif (len === 0 || len === 1)\n\t\t\treturn this\n\t\treturn this.scale(<f32>1.0 / len)\n\t}\n\n\troundToNearest (vec: Vector3, interval: f32): Vector3 {\n\t\tvec.x = interval * Mathf.round(vec.x / interval)\n\t\tvec.y = interval * Mathf.round(vec.y / interval)\n\t\tvec.z = interval * Mathf.round(vec.z / interval)\n\t\treturn vec\n\t}\t\n\t// @operator('==')\n\tisEqual (b: Vector3): boolean\n\t{ return this.x == b.x && this.y == b.y && this.z == b.z }\n\t// @operator('!=')\n\tisNotEqual (b: Vector3): boolean\n\t{ return this.x != b.x || this.y != b.y || this.z != b.z }\n\tisAlmostEqual (b: Vector3): boolean\n\t{ return Math2.isAlmostEqual(this.x, b.x)\n\t\t&& Math2.isAlmostEqual(this.y, b.y)\n\t\t&& Math2.isAlmostEqual(this.z, b.z) }\n\n\t// @operator('+')\n\tstatic add (a: Vector3, b: Vector3, o: Vector3 = new Vector3()): Vector3\n\t{ o.x = a.x + b.x; o.y = a.y + b.y; o.z = a.z + b.z; return o }\n\t// @operator('-')\n\tstatic sub (a: Vector3, b: Vector3, o: Vector3 = new Vector3()): Vector3 \n\t{ o.x = a.x - b.x; o.y = a.y - b.y; o.z = a.z - b.z; return o }\n\t// @operator('*')\n\tstatic mult (a: Vector3, b: Vector3, o: Vector3 = new Vector3()): Vector3 \n\t{ o.x = a.x * b.x; o.y = a.y * b.y; o.z = a.z * b.z; return o }\n\t// @operator('/')\n\tstatic div (a: Vector3, b: Vector3, o: Vector3 = new Vector3()): Vector3 \n\t{ o.x = a.x / b.x; o.y = a.y / b.y; o.z = a.z / b.z; return o }\n\t//TODO make all sets static\n\t// addSet (a: Vector3, b: Vector3): Vector3\n\t// { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; return this }\n\t// subSet (a: Vector3, b: Vector3): Vector3 \n\t// { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; return this }\n\t// multSet (a: Vector3, b: Vector3): Vector3 \n\t// { this.x = a.x * b.x; this.y = a.y * b.y; this.z = a.z * b.z; return this }\n\t// divSet (a: Vector3, b: Vector3): Vector3 \n\t// { this.x = a.x / b.x; this.y = a.y / b.y; this.z = a.z / b.z; return this }\n\tadd (b: Vector3): Vector3\n\t{ this.x += b.x; this.y += b.y; this.z += b.z; return this }\n\tsub (b: Vector3): Vector3 \n\t{ this.x -= b.x; this.y -= b.y; this.z -= b.z; return this }\n\tmult (b: Vector3): Vector3 \n\t{ this.x *= b.x; this.y *= b.y; this.z *= b.z; return this }\n\tdiv (b: Vector3): Vector3 \n\t{ this.x /= b.x; this.y /= b.y; this.z /= b.z; return this }\n\taddValue (b: f32): Vector3\n\t{ this.x += b;\tthis.y += b; this.z += b; return this }\n\tsubValue (b: f32): Vector3\n\t{ this.x -= b;\tthis.y -= b; this.z -= b; return this }\n\tscale (b: f32): Vector3\n\t{ this.x *= b;\tthis.y *= b; this.z *= b; return this }\n\tscaleDiv (b: f32): Vector3\n\t{ this.x /= b; this.y /= b; this.z /= b; return this }\n\t// { this.x /= b || 1; this.y /= b || 1; this.z /= b || 1; return this }\n}\n","import { Math2 } from './aliases'\nimport { Color } from './Color'\n\n\n\n\nexport class Color8{\n\n\tstatic get red (): Color8{ return new Color8(255, 0, 0) }\n\tstatic get green (): Color8{ return new Color8(0, 255, 0) }\n\tstatic get blue (): Color8{ return new Color8(0, 0, 255) }\n\t\n\tstatic get yellow (): Color8{ return new Color8(255, 255, 0) }\n\tstatic get magenta (): Color8{ return new Color8(255, 0, 255) }\n\tstatic get cyan (): Color8{ return new Color8(0, 255, 255) }\n\t\n\tstatic get black (): Color8{ return new Color8(0, 0, 0) }\n\tstatic get white (): Color8{ return new Color8(255, 255, 255) }\n\tstatic get gray (): Color8{ return new Color8(127, 127, 127) }\n\t\n\tstatic get purple(): Color8 { return new Color8(127, 0, 127) }\n\t\n\tstatic readonly _red: Color8 = Color8.red\n\tstatic readonly _green: Color8 = Color8.green\n\tstatic readonly _blue: Color8 = Color8.blue\n\t\n\tstatic readonly _yellow: Color8 = Color8.yellow\n\tstatic readonly _magenta: Color8 = Color8.magenta\n\tstatic readonly _cyan: Color8 = Color8.cyan\n\t\n\tstatic readonly _black: Color8 = Color8.black\n\tstatic readonly _white: Color8 = Color8.white\n\tstatic readonly _gray: Color8 = Color8.gray\n\n\tstatic fromNormal(r: f32 = 1, g: f32 = 1, b: f32 = 1, a: f32 = 1): Color8{\n\t\treturn new Color8(<u8>(r * 255), <u8>(g * 255), <u8>(b * 255), <u8>(a * 255))\n\t}\n\t\n\tstatic fromArray(m: Uint8Array): Color8{\n\t\tconst col = new Color8()\n\t\tcol.m = m\n\t\treturn col\n\t}\n\tstatic random(): Color8{\n\t\treturn Color8.fromNormal(Mathf.random(), Mathf.random(), Mathf.random())\n\t}\n\tstatic lerp(a: Color8, b: Color8, t: f32): Color8{\n\t\treturn new Color8(\n\t\t\t<u8>Math2.lerp(<f32>a.r, <f32>b.r, t),\n\t\t\t<u8>Math2.lerp(<f32>a.g, <f32>b.g, t),\n\t\t\t<u8>Math2.lerp(<f32>a.b, <f32>b.b, t),\n\t\t\t<u8>Math2.lerp(<f32>a.a, <f32>b.a, t))\n\t}\n\n\t\n\tm: Uint8Array\n\n\tget r(): u8{ return this.m[0] } set r(val: u8){ this.m[0] = val }\n\tget g(): u8{ return this.m[1] } set g(val: u8){ this.m[1] = val }\n\tget b(): u8{ return this.m[2] } set b(val: u8){ this.m[2] = val }\n\tget a(): u8{ return this.m[3] } set a(val: u8){ this.m[3] = val }\n\n\tconstructor(r: u8 = 255, g: u8 = 255, b: u8 = 255, a: u8 = 255){\n\t\tthis.m = new Uint8Array(4)\n\t\tthis.m[0] = r\n\t\tthis.m[1] = g\n\t\tthis.m[2] = b\n\t\tthis.m[3] = a\n\t}\n\n\ttoNormalColor(): Color{\n\t\treturn new Color(<f32> this.r / 255, <f32> this.g / 255, <f32> this.b / 255, <f32> this.a / 255)\n\t}\n\n\t// @operator('==')\n\tisEqual (b: Color8): boolean\n\t{ return this.r == b.r && this.g == b.g && this.b == b.b && this.a == b.a }\n\t// @operator('!=')\n\tisNotEqual (b: Color8): boolean\n\t{ return this.r != b.r || this.g != b.g || this.b != b.b || this.a != b.a }\n\tisAlmostEqual (b: Color8): boolean\n\t{ return Math2.isAlmostEqual(this.r, b.r)\n\t\t\t&& Math2.isAlmostEqual(this.g, b.g)\n\t\t\t&& Math2.isAlmostEqual(this.b, b.b) \n\t\t\t&& Math2.isAlmostEqual(this.a, b.a) \t\t\n\t}\n\t\n}","import { Math2 } from './aliases'\nimport { Color8 } from './Color8'\n\n\n\nexport class Color{\n\tstatic clear: Color = new Color(0, 0, 0, 0)\n\n\n\tstatic new(r: f32, g: f32, b: f32, a: f32 = 1): Color{ return new Color(r, g, b, a) }\n\tstatic fromColor8(col: Color8): Color{\n\t\treturn new Color(<f32>col.r / 255, <f32>col.g / 255, <f32>col.b / 255, <f32>col.a / 255)\n\t}\n\n\tstatic fromHSV(h: f32, s: f32, v: f32, ref: Color = new Color()): Color{\n\t\tconst i = Mathf.floor(h * 6)\n\t\tconst f = h * 6 - i\n\t\tconst p = v * (1 - s)\n\t\tconst q = v * (1 - f * s)\n\t\tconst t = v * (1 - (1 - f) * s)\n\t\tlet r: f32, g: f32, b: f32\n\t\tswitch (<u32>i % 6) {\n\t\tcase 0: r = v, g = t, b = p; break\n\t\tcase 1: r = q, g = v, b = p; break\n\t\tcase 2: r = p, g = v, b = t; break\n\t\tcase 3: r = p, g = q, b = v; break\n\t\tcase 4: r = t, g = p, b = v; break\n\t\tcase 5: r = v, g = p, b = q; break\n\t\t}\n\t\t//@ts-ignore\n\t\tref.set(r, g, b)\n\t\treturn ref\n\t}\n\n\tm: Float32Array\n\n\tget r(): f32{ return this.m[0] } set r(val: f32){ this.m[0] = val }\n\tget g(): f32{ return this.m[1] } set g(val: f32){ this.m[1] = val }\n\tget b(): f32{ return this.m[2] } set b(val: f32){ this.m[2] = val }\n\tget a(): f32{ return this.m[3] } set a(val: f32){ this.m[3] = val }\n\tset(r: f32, g: f32, b: f32, a: f32 = 1): Color { \n\t\tthis.r = r; this.g = g; this.b = b; this.a = a; return this }\n\n\tconstructor(r: f32 = 1, g: f32 = 1, b: f32 = 1, a: f32 = 1){\n\t\tthis.m = new Float32Array(4)\n\t\tthis.m[0] = r\n\t\tthis.m[1] = g\n\t\tthis.m[2] = b\n\t\tthis.m[3] = a\n\t}\n\n\n\ttoHSV(): f32[]{\n\t\tconst r = this.r, g = this.g, b = this.b\n\t\tconst max = Math2.max3(r, g, b)\n\t\tconst min = Math2.min3(r, g, b)\n\t\tconst d = max - min\n\t\tlet h: f32\n\t\tconst s = max === <f32>0 ? <f32>0 : d / max\n\t\tconst v = max\n\t\tif (max === min)\n\t\t\th = 0\n\t\telse if (max === r)\n\t\t\th = ((g - b) + d * (g < b ? 6 : 0)) / (6 * d)\n\t\telse if (max === g) \n\t\t\th = ((b - r) + d * 2) / (6 * d)\n\t\telse if (max === b) \n\t\t\th = ((r - g) + d * 4) / (6 * d)\n\t\t//@ts-ignore\n\t\treturn [h, s, v]\n\t}\n\n}","import { ArrayUtils } from '../utility'\n\n\n\nexport class Texture{\n\n\n\twidth: u16\n\theight: u16\n\tpixels: Uint8Array\n\tget length(): u32{ return this.pixels.length }\n\tstatic white: Texture = new Texture(1, 1, ArrayUtils.toTyped_u8([255, 255, 255, 255]))\n\tstatic testTexture: Texture = new Texture(2, 2, ArrayUtils.toTyped_u8([\n\t\t0, 0, 0, 255,\n\t\t255, 0, 0, 255,\n\t\t0, 255, 0, 255,\n\t\t255, 255, 0, 255\n\t]))\n\tstatic testTexture2: Texture = new Texture(2, 2, ArrayUtils.toTyped_u8([\n\t\t0, 0, 255, 255,\n\t\t255, 0, 255, 255,\n\t\t0, 255, 255, 255,\n\t\t255, 255, 255, 255\n\t]))\n\tstatic new(width: u16, height: u16, pixels: Uint8Array): Texture{\n\t\treturn new Texture(width, height, pixels)\n\t}\n\tconstructor(width: u16, height: u16, pixels: Uint8Array = new Uint8Array(width * height)){\n\t\tthis.width = width\n\t\tthis.height = height\n\t\tthis.pixels = pixels\n\t}\n}","\nexport function fill<T>(arr: StaticArray<T>, values: T[]): StaticArray<T>{\n\tfor (let i = 0; i < arr.length; i += values.length){\n\t\tfor (let j = 0; j < values.length; j++) {\n\t\t\tarr[i + j] = values[j]\n\t\t}\n\t}\n\treturn arr\n}\n\nexport function flatMapStatic<T>(arr: StaticArray<StaticArray<T>>): StaticArray<T>{\n\tif (arr.length === 0)\n\t\treturn new StaticArray<T>(0)\n\tconst nestedLen = arr[0].length\n\tconst out = new StaticArray<T>(arr.length * nestedLen)\n\tfor (let i = 0; i < arr.length; i++){\n\t\tfor (let j = 0; j < nestedLen; j++) {\n\t\t\tconst k = i * nestedLen + j\n\t\t\tout[k] = arr[i][j]\n\t\t}\n\t}\n\treturn out\n}\nexport function flatMap<T>(arr: Array<Array<T>>): StaticArray<T>{\n\tif (arr.length === 0)\n\t\treturn new StaticArray<T>(0)\n\tconst nestedLen = arr[0].length\n\tconst out = new StaticArray<T>(arr.length * nestedLen)\n\tfor (let i = 0; i < arr.length; i++){\n\t\tfor (let j = 0; j < nestedLen; j++) {\n\t\t\tconst k = i * nestedLen + j\n\t\t\tout[k] = arr[i][j]\n\t\t}\n\t}\n\treturn out\n}\nexport function jaggedFlatMap<T>(arr: StaticArray<StaticArray<T>>): Array<T>{\n\tconst out = new Array<T>()\n\tfor (let i = 0; i < arr.length; i++){\n\t\tfor (let j = 0; j < arr[i].length; j++) {\n\t\t\tout.push(arr[i][j])\n\t\t}\n\t}\n\treturn out\n}\n\nexport function copy<T>(target: T, other: T): T{\n\t//@ts-ignore\n\tfor (let i = 0; i < target.length; i++){\n\t\t//@ts-ignore\n\t\ttarget[i] = other[i]\n\t}\n\treturn target\n}\n\nexport function arrayToStatic<T>(a: T[]): StaticArray<T>{\n\tconst b = new StaticArray<T>(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\n\nexport function arrayToTyped<T1, T2>(a: T1[]): T2{\n\tconst b = instantiate<T2>(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\t//@ts-ignore\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\n\n\nexport function toTyped_u8(a: StaticArray<u8>): Uint8Array{\n\tconst b = new Uint8Array(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\nexport function toTyped_u16(a: StaticArray<u16>): Uint16Array{\n\tconst b = new Uint16Array(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\nexport function toTyped_u32(a: StaticArray<u32>): Uint32Array{\n\tconst b = new Uint32Array(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\nexport function toTyped_i32(a: StaticArray<i32>): Int32Array{\n\tconst b = new Int32Array(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\nexport function toTyped_f32(a: StaticArray<f32>): Float32Array{\n\tconst b = new Float32Array(a.length)\n\tfor (let i = 0; i < a.length; i++){\n\t\tb[i] = a[i]\n\t}\n\treturn b\n}\n\n\nexport function toString<T>(arr: T | null, nextLine: u32 = 1): string{\n\tlet str = ''\n\tif (arr === null)\n\t\treturn str\n\t//@ts-ignore\n\tfor (let i = 0; i < arr.length; i++){\n\t\tif (i % nextLine === 0)\n\t\t\tstr += '\\n'\n\t\t//@ts-ignore\n\t\tstr += `${arr[i]}, `\n\t}\n\treturn str\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = other.length;\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = other.length;\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    var len = this.length;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): this {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { EPSILON } from '../math'\nimport { System } from './System'\n\n\n\nexport class SystemPriority{\n\tstatic after(other: SystemPriority): SystemPriority{\n\t\tconst depth = other.depth + 1\n\t\tconst value = other.value + 1 / Mathf.pow(2, depth)\n\t\treturn new SystemPriority(value, depth)\n\t}\n\tstatic before(other: SystemPriority): SystemPriority{\n\t\tconst depth = other.depth + 1\n\t\tconst value = other.value - 1 / Mathf.pow(2, depth)\n\t\treturn new SystemPriority(value, depth)\n\t}\n\tvalue: f32\n\tdepth: i16\n\tconstructor(value: f32 = 1, depth: i16 = 0){\n\t\tthis.value = value\n\t\tthis.depth = depth\n\t}\n\tisEqual(other: SystemPriority): bool{\n\t\treturn this.value == other.value && this.depth == other.depth\n\t}\n\tisAlmostEqual(other: SystemPriority): bool{\n\t\treturn Mathf.abs(this.value - other.value) < EPSILON && Mathf.abs(this.depth - other.depth) < EPSILON\n\t}\n\tstatic sortSystems<T extends System>(systems: T[]): void{\n\t\tsystems.sort((a, b) => {\n\t\t\tif (a.priority.value < b.priority.value)\n\t\t\t\treturn -1\n\t\t\telse if (b.priority.value < a.priority.value)\n\t\t\t\treturn 1\n\t\t\treturn 0 \n\t\t})\n\t}\n}\n\nexport const rootSystemPriority = new SystemPriority()\nexport const renderSystemPriority = SystemPriority.before(rootSystemPriority)\nexport const transformSystemPriority = SystemPriority.before(renderSystemPriority)\nexport const timeSystemPriority = SystemPriority.before(transformSystemPriority)\nexport const behaviorSystemPriority = SystemPriority.after(transformSystemPriority)\nexport const defaultSystemPriority = SystemPriority.after(behaviorSystemPriority)","export const Model = 'u_model'\nexport const View = 'u_view'\nexport const Projection = 'u_projection'\nexport const ModelView = 'u_modelView'\nexport const ViewProjection = 'u_viewProjection'\nexport const ModelViewProjection = 'u_modelViewProjection'\n\nexport const InverseTransposeModel = 'u_inverseTransposeModel'\nexport const InverseModel = 'u_inverseModel'\n\nexport const CameraModel = 'u_cameraModel'\n\nexport const Time = 'u_time'\nexport const DeltaTime = 'u_deltaTime'\n\nexport const Color = 'u_color'\nexport const Texture = 'u_texture'\n\nexport const Acceleration = 'u_acceleration'\n\nexport const DirectionalLights = 'u_directionalLights'\nexport const DirectionalLights_direction = `${DirectionalLights}_direction`\nexport const DirectionalLights_ambientIntensity = `${DirectionalLights}_ambientIntensity`","export const Position = 'a_position'\nexport const Color = 'a_color'\nexport const Normal = 'a_normal'\nexport const Texcoord = 'a_texcoord'\nexport const ModelViewProjection = 'a_modelViewProjection'\n\nexport const InstancePosition = 'a_instancePosition'\nexport const InstanceVelocity = 'a_instanceVelocity'\nexport const InstanceTangent = 'a_instanceTangent'","export const Position = 'vPosition'\nexport const InstancePosition = 'vInstancePosition'\nexport const InstanceVelocity = 'vInstanceVelocity'","import { Uniform } from '../../material/Uniform'\nimport { UniformBufferObject } from '../../material/UniformBufferObject'\nimport * as UniformName from '../_uniforms'\n\nconst uboName = 'ubo_camera'\nconst uboBlock = `\nlayout( std140 ) uniform ${uboName}{\n\tmat4 ${UniformName.View};\n\tmat4 ${UniformName.Projection};\n\tmat4 ${UniformName.ViewProjection};\n\tmat4 ${UniformName.CameraModel};\n};\n`\n\n\nexport const camera = new UniformBufferObject(uboName, uboBlock,\n\t[\n\t\tUniform.Mat4(UniformName.View),\n\t\tUniform.Mat4(UniformName.Projection),\n\t\tUniform.Mat4(UniformName.ViewProjection),\n\t\tUniform.Mat4(UniformName.CameraModel)\n\t])","import { Uniform } from './Uniform'\n\n\nexport class UniformBufferObject{\n\n\tname: string\n\tblock: string\n\tdynamic: bool = true\n\tuniformArr: Uniform[] = []\n\tuniformMap: Map<string, Uniform> = new Map()\n\n\tconstructor(name: string, block: string, uniforms: Uniform[]){\n\t\tthis.name = name\n\t\tthis.block = block\n\t\tthis.uniformArr = uniforms\n\t\tfor (let i = 0; i < this.uniformArr.length; i++){\n\t\t\tthis.uniformMap.set(this.uniformArr[i].name, this.uniformArr[i])\n\t\t}\n\t}\n\n\t// apply(): void{\n\t// imports.ubo.apply(this)\n\t// }\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    var bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    var ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    var ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var oldLen = this.length_;\n    var len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = other.length_;\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var len = this.length_;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    var ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    var result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): this {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    var byteLength = <usize>size << align;\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { Bitmap, Texture } from '../../math'\nimport { UniformType } from '../constants'\n\nexport class Uniform{\n\n\tstatic Float(name: string, value: Float32Array = new Float32Array(1)): Uniform_f32{\n\t\treturn new Uniform_f32(name, value, UniformType.FLOAT)\n\t}\n\tstatic Vec2(name: string, value: Float32Array = new Float32Array(2)): Uniform_f32{\n\t\treturn new Uniform_f32(name, value, UniformType.FLOAT_VEC2)\n\t}\n\tstatic Vec3(name: string, value: Float32Array = new Float32Array(3)): Uniform_f32{\n\t\treturn new Uniform_f32(name, value, UniformType.FLOAT_VEC3)\n\t}\n\tstatic Vec4(name: string, value: Float32Array = new Float32Array(4)): Uniform_f32{\n\t\treturn new Uniform_f32(name, value, UniformType.FLOAT_VEC4)\n\t}\n\tstatic Mat4(name: string, value: Float32Array = new Float32Array(16)): Uniform_f32{\n\t\treturn new Uniform_f32(name, value, UniformType.FLOAT_MAT4)\n\t}\n\tstatic Texture(name: string, value: Texture = Texture.testTexture): Uniform_texture{\n\t\treturn new Uniform_texture(name, value, UniformType.TEXTURE)\n\t}\n\tstatic Bitmap(name: string, value: Bitmap): Uniform_bitmap{\n\t\treturn new Uniform_bitmap(name, value, UniformType.BITMAP)\n\t}\n\n\tname: string\n\ttype: UniformType\n\telementSize: u32\n\n\tconstructor(name: string, elementSize: u32, type: UniformType = UniformType.FLOAT){\n\t\tthis.name = name\n\t\tthis.elementSize = elementSize\n\t\tthis.type = type\n\t}\n}\n\nexport class TypedUniform<T> extends Uniform{\n\tvalue: T\n\tconstructor(name: string,  value: T, type: UniformType = UniformType.FLOAT){\n\t\t//@ts-ignore\n\t\tsuper(name, <u32>value.length, type)\n\t\tthis.value = value\n\t}\n}\nexport class Uniform_f32 extends TypedUniform<Float32Array>{}\nexport class Uniform_i32 extends TypedUniform<Int32Array>{}\nexport class Uniform_u8 extends TypedUniform<Uint8Array>{}\nexport class Uniform_u32 extends TypedUniform<Uint32Array>{}\nexport class Uniform_texture extends TypedUniform<Texture>{}\nexport class Uniform_bitmap extends TypedUniform<Bitmap>{}","import * as UniformName from '../_uniforms'\nimport { UniformBufferObject } from '../../material/UniformBufferObject'\nimport { Uniform } from '../../material/Uniform'\n\nconst uboName = 'ubo_model'\nconst uboBlock = `\nlayout( std140 ) uniform ${uboName}{\n\tmat4 ${UniformName.Model};\n\tmat4 ${UniformName.ModelView};\n\tmat4 ${UniformName.ModelViewProjection};\n\tmat4 ${UniformName.InverseModel};\n\tmat4 ${UniformName.InverseTransposeModel};\n};\n`\n\nexport const mesh = new UniformBufferObject(uboName, uboBlock, [\n\tUniform.Mat4(UniformName.Model),\n\tUniform.Mat4(UniformName.ModelView),\n\tUniform.Mat4(UniformName.ModelViewProjection),\n\tUniform.Mat4(UniformName.InverseModel),\n\tUniform.Mat4(UniformName.InverseTransposeModel)\n])","import { UniformBufferObject } from '../../material/UniformBufferObject'\nimport { Uniform } from '../../material/Uniform'\nimport { UniformName } from '../aliases'\n\n\nconst uboName = 'ubo_directionalLight'\nconst uboBlock = `\nlayout( std140 ) uniform ${uboName}{\n\tvec3[NUM_LIGHTS] ${UniformName.DirectionalLights_direction};\n\tfloat[NUM_LIGHTS] ${UniformName.DirectionalLights_ambientIntensity};\n};\n`\nexport const directionalLight = new UniformBufferObject(uboName, uboBlock, [\n\tUniform.Float(UniformName.DirectionalLights_ambientIntensity),\n\tUniform.Vec3(UniformName.DirectionalLights_direction, new Float32Array(6))\n])","\nexport enum Parameter{\nREAD_BUFFER=0x0C02,\nUNPACK_ROW_LENGTH=0x0CF2,\nUNPACK_SKIP_ROWS=0x0CF3,\nUNPACK_SKIP_PIXELS=0x0CF4,\nPACK_ROW_LENGTH=0x0D02,\nPACK_SKIP_ROWS=0x0D03,\nPACK_SKIP_PIXELS=0x0D04,\nTEXTURE_BINDING_3D=0x806A,\nUNPACK_SKIP_IMAGES=0x806D,\nUNPACK_IMAGE_HEIGHT=0x806E,\nMAX_3D_TEXTURE_SIZE=0x8073,\nMAX_ELEMENTS_VERTICES=0x80E8,\nMAX_ELEMENTS_INDICES=0x80E9,\nMAX_TEXTURE_LOD_BIAS=0x84FD,\nMAX_FRAGMENT_UNIFORM_COMPONENTS=0x8B49,\nMAX_VERTEX_UNIFORM_COMPONENTS=0x8B4A,\nMAX_ARRAY_TEXTURE_LAYERS=0x88FF,\nMIN_PROGRAM_TEXEL_OFFSET=0x8904,\nMAX_PROGRAM_TEXEL_OFFSET=0x8905,\nMAX_VARYING_COMPONENTS=0x8B4B,\nFRAGMENT_SHADER_DERIVATIVE_HINT=0x8B8B,\nRASTERIZER_DISCARD=0x8C89,\nVERTEX_ARRAY_BINDING=0x85B5,\nMAX_VERTEX_OUTPUT_COMPONENTS=0x9122,\nMAX_FRAGMENT_INPUT_COMPONENTS=0x9125,\nMAX_SERVER_WAIT_TIMEOUT=0x9111,\nMAX_ELEMENT_INDEX=0x8D6B,\nBLEND_EQUATION=0x8009,\nBLEND_EQUATION_RGB=0x8009,\nBLEND_EQUATION_ALPHA=0x883D,\nBLEND_DST_RGB=0x80C8,\nBLEND_SRC_RGB=0x80C9,\nBLEND_DST_ALPHA=0x80CA,\nBLEND_SRC_ALPHA=0x80CB,\nBLEND_COLOR=0x8005,\nARRAY_BUFFER_BINDING=0x8894,\nELEMENT_ARRAY_BUFFER_BINDING=0x8895,\nLINE_WIDTH=0x0B21,\nALIASED_POINT_SIZE_RANGE=0x846D,\nALIASED_LINE_WIDTH_RANGE=0x846E,\nCULL_FACE_MODE=0x0B45,\nFRONT_FACE=0x0B46,\nDEPTH_RANGE=0x0B70,\nDEPTH_WRITEMASK=0x0B72,\nDEPTH_CLEAR_VALUE=0x0B73,\nDEPTH_FUNC=0x0B74,\nSTENCIL_CLEAR_VALUE=0x0B91,\nSTENCIL_FUNC=0x0B92,\nSTENCIL_FAIL=0x0B94,\nSTENCIL_PASS_DEPTH_FAIL=0x0B95,\nSTENCIL_PASS_DEPTH_PASS=0x0B96,\nSTENCIL_REF=0x0B97,\nSTENCIL_VALUE_MASK=0x0B93,\nSTENCIL_WRITEMASK=0x0B98,\nSTENCIL_BACK_FUNC=0x8800,\nSTENCIL_BACK_FAIL=0x8801,\nSTENCIL_BACK_PASS_DEPTH_FAIL=0x8802,\nSTENCIL_BACK_PASS_DEPTH_PASS=0x8803,\nSTENCIL_BACK_REF=0x8CA3,\nSTENCIL_BACK_VALUE_MASK=0x8CA4,\nSTENCIL_BACK_WRITEMASK=0x8CA5,\nVIEWPORT=0x0BA2,\nSCISSOR_BOX=0x0C10,\nCOLOR_CLEAR_VALUE=0x0C22,\nCOLOR_WRITEMASK=0x0C23,\nUNPACK_ALIGNMENT=0x0CF5,\nPACK_ALIGNMENT=0x0D05,\nMAX_TEXTURE_SIZE=0x0D33,\nMAX_VIEWPORT_DIMS=0x0D3A,\nSUBPIXEL_BITS=0x0D50,\nRED_BITS=0x0D52,\nGREEN_BITS=0x0D53,\nBLUE_BITS=0x0D54,\nALPHA_BITS=0x0D55,\nDEPTH_BITS=0x0D56,\nSTENCIL_BITS=0x0D57,\nPOLYGON_OFFSET_UNITS=0x2A00,\nPOLYGON_OFFSET_FACTOR=0x8038,\nTEXTURE_BINDING_2D=0x8069,\nSAMPLE_BUFFERS=0x80A8,\nSAMPLES=0x80A9,\nSAMPLE_COVERAGE_VALUE=0x80AA,\nSAMPLE_COVERAGE_INVERT=0x80AB,\nCOMPRESSED_TEXTURE_FORMATS=0x86A3,\nVENDOR=0x1F00,\nRENDERER=0x1F01,\nVERSION=0x1F02,\nIMPLEMENTATION_COLOR_READ_TYPE=0x8B9A,\nIMPLEMENTATION_COLOR_READ_FORMAT=0x8B9B,\nBROWSER_DEFAULT_WEBGL=0x9244,\n}\nexport enum Texture{\nRED=0x1903,\nRGB8=0x8051,\nRGBA8=0x8058,\nRGB10_A2=0x8059,\nTEXTURE_3D=0x806F,\nTEXTURE_WRAP_R=0x8072,\nTEXTURE_MIN_LOD=0x813A,\nTEXTURE_MAX_LOD=0x813B,\nTEXTURE_BASE_LEVEL=0x813C,\nTEXTURE_MAX_LEVEL=0x813D,\nTEXTURE_COMPARE_MODE=0x884C,\nTEXTURE_COMPARE_FUNC=0x884D,\nSRGB=0x8C40,\nSRGB8=0x8C41,\nSRGB8_ALPHA8=0x8C43,\nCOMPARE_REF_TO_TEXTURE=0x884E,\nRGBA32F=0x8814,\nRGB32F=0x8815,\nRGBA16F=0x881A,\nRGB16F=0x881B,\nTEXTURE_2D_ARRAY=0x8C1A,\nTEXTURE_BINDING_2D_ARRAY=0x8C1D,\nR11F_G11F_B10F=0x8C3A,\nRGB9_E5=0x8C3D,\nRGBA32UI=0x8D70,\nRGB32UI=0x8D71,\nRGBA16UI=0x8D76,\nRGB16UI=0x8D77,\nRGBA8UI=0x8D7C,\nRGB8UI=0x8D7D,\nRGBA32I=0x8D82,\nRGB32I=0x8D83,\nRGBA16I=0x8D88,\nRGB16I=0x8D89,\nRGBA8I=0x8D8E,\nRGB8I=0x8D8F,\nRED_INTEGER=0x8D94,\nRGB_INTEGER=0x8D98,\nRGBA_INTEGER=0x8D99,\nR8=0x8229,\nRG8=0x822B,\nR16F=0x822D,\nR32F=0x822E,\nRG16F=0x822F,\nRG32F=0x8230,\nR8I=0x8231,\nR8UI=0x8232,\nR16I=0x8233,\nR16UI=0x8234,\nR32I=0x8235,\nR32UI=0x8236,\nRG8I=0x8237,\nRG8UI=0x8238,\nRG16I=0x8239,\nRG16UI=0x823A,\nRG32I=0x823B,\nRG32UI=0x823C,\nR8_SNORM=0x8F94,\nRG8_SNORM=0x8F95,\nRGB8_SNORM=0x8F96,\nRGBA8_SNORM=0x8F97,\nRGB10_A2UI=0x906F,\nTEXTURE_IMMUTABLE_FORMAT=0x912F,\nTEXTURE_IMMUTABLE_LEVELS=0x82DF,\nNEAREST=0x2600,\nLINEAR=0x2601,\nNEAREST_MIPMAP_NEAREST=0x2700,\nLINEAR_MIPMAP_NEAREST=0x2701,\nNEAREST_MIPMAP_LINEAR=0x2702,\nLINEAR_MIPMAP_LINEAR=0x2703,\nTEXTURE_MAG_FILTER=0x2800,\nTEXTURE_MIN_FILTER=0x2801,\nTEXTURE_WRAP_S=0x2802,\nTEXTURE_WRAP_T=0x2803,\nTEXTURE_2D=0x0DE1,\nTEXTURE=0x1702,\nTEXTURE_CUBE_MAP=0x8513,\nTEXTURE_BINDING_CUBE_MAP=0x8514,\nTEXTURE_CUBE_MAP_POSITIVE_X=0x8515,\nTEXTURE_CUBE_MAP_NEGATIVE_X=0x8516,\nTEXTURE_CUBE_MAP_POSITIVE_Y=0x8517,\nTEXTURE_CUBE_MAP_NEGATIVE_Y=0x8518,\nTEXTURE_CUBE_MAP_POSITIVE_Z=0x8519,\nTEXTURE_CUBE_MAP_NEGATIVE_Z=0x851A,\nMAX_CUBE_MAP_TEXTURE_SIZE=0x851C,\nTEXTURE0= 33984,\nTEXTURE1= 33985,\nTEXTURE2= 33986,\nTEXTURE3= 33987,\nTEXTURE4= 33988,\nTEXTURE5= 33989,\nTEXTURE6= 33990,\nTEXTURE7= 33991,\nTEXTURE8= 33992,\nTEXTURE9= 33993,\nTEXTURE10= 33994,\nTEXTURE11= 33995,\nTEXTURE12= 33996,\nTEXTURE13= 33997,\nTEXTURE14= 33998,\nTEXTURE15= 33999,\nTEXTURE16= 34000,\nTEXTURE17= 34001,\nTEXTURE18= 34002,\nTEXTURE19= 34003,\nTEXTURE20= 34004,\nTEXTURE21= 34005,\nTEXTURE22= 34006,\nTEXTURE23= 34007,\nTEXTURE24= 34008,\nTEXTURE25= 34009,\nTEXTURE26= 34010,\nTEXTURE27= 34011,\nTEXTURE28= 34012,\nTEXTURE29= 34013,\nTEXTURE30= 34014,\nTEXTURE31= 34015,\nACTIVE_TEXTURE=0x84E0,\nREPEAT=0x2901,\nCLAMP_TO_EDGE=0x812F,\nMIRRORED_REPEAT=0x8370,\n}\nexport enum PixelType{\nUNSIGNED_INT_2_10_10_10_REV=0x8368,\nUNSIGNED_INT_10F_11F_11F_REV=0x8C3B,\nUNSIGNED_INT_5_9_9_9_REV=0x8C3E,\nFLOAT_32_UNSIGNED_INT_24_8_REV=0x8DAD,\nUNSIGNED_INT_24_8=0x84FA,\nHALF_FLOAT=0x140B,\nRG=0x8227,\nRG_INTEGER=0x8228,\nINT_2_10_10_10_REV=0x8D9F,\nUNSIGNED_BYTE=0x1401,\nUNSIGNED_SHORT_4_4_4_4=0x8033,\nUNSIGNED_SHORT_5_5_5_1=0x8034,\nUNSIGNED_SHORT_5_6_5=0x8363,\n}\nexport enum Query{\nCURRENT_QUERY=0x8865,\nQUERY_RESULT=0x8866,\nQUERY_RESULT_AVAILABLE=0x8867,\nANY_SAMPLES_PASSED=0x8C2F,\nANY_SAMPLES_PASSED_CONSERVATIVE=0x8D6A,\n}\nexport enum DrawBuffer{\nMAX_DRAW_BUFFERS=0x8824,\nDRAW_BUFFER0=0x8825,\nDRAW_BUFFER1=0x8826,\nDRAW_BUFFER2=0x8827,\nDRAW_BUFFER3=0x8828,\nDRAW_BUFFER4=0x8829,\nDRAW_BUFFER5=0x882A,\nDRAW_BUFFER6=0x882B,\nDRAW_BUFFER7=0x882C,\nDRAW_BUFFER8=0x882D,\nDRAW_BUFFER9=0x882E,\nDRAW_BUFFER10=0x882F,\nDRAW_BUFFER11=0x8830,\nDRAW_BUFFER12=0x8831,\nDRAW_BUFFER13=0x8832,\nDRAW_BUFFER14=0x8833,\nDRAW_BUFFER15=0x8834,\nMAX_COLOR_ATTACHMENTS=0x8CDF,\nCOLOR_ATTACHMENT1=0x8CE1,\nCOLOR_ATTACHMENT2=0x8CE2,\nCOLOR_ATTACHMENT3=0x8CE3,\nCOLOR_ATTACHMENT4=0x8CE4,\nCOLOR_ATTACHMENT5=0x8CE5,\nCOLOR_ATTACHMENT6=0x8CE6,\nCOLOR_ATTACHMENT7=0x8CE7,\nCOLOR_ATTACHMENT8=0x8CE8,\nCOLOR_ATTACHMENT9=0x8CE9,\nCOLOR_ATTACHMENT10=0x8CEA,\nCOLOR_ATTACHMENT11=0x8CEB,\nCOLOR_ATTACHMENT12=0x8CEC,\nCOLOR_ATTACHMENT13=0x8CED,\nCOLOR_ATTACHMENT14=0x8CEE,\nCOLOR_ATTACHMENT15=0x8CEF,\n}\nexport enum Sampler{\nSAMPLER_3D=0x8B5F,\nSAMPLER_2D_SHADOW=0x8B62,\nSAMPLER_2D_ARRAY=0x8DC1,\nSAMPLER_2D_ARRAY_SHADOW=0x8DC4,\nSAMPLER_CUBE_SHADOW=0x8DC5,\nINT_SAMPLER_2D=0x8DCA,\nINT_SAMPLER_3D=0x8DCB,\nINT_SAMPLER_CUBE=0x8DCC,\nINT_SAMPLER_2D_ARRAY=0x8DCF,\nUNSIGNED_INT_SAMPLER_2D=0x8DD2,\nUNSIGNED_INT_SAMPLER_3D=0x8DD3,\nUNSIGNED_INT_SAMPLER_CUBE=0x8DD4,\nUNSIGNED_INT_SAMPLER_2D_ARRAY=0x8DD7,\nMAX_SAMPLES=0x8D57,\nSAMPLER_BINDING=0x8919,\n}\n\nexport enum BufferType{\n\tUNIFORM_BUFFER=0x8A11,\n\tPIXEL_PACK_BUFFER=0x88EB,\n\tPIXEL_UNPACK_BUFFER=0x88EC,\n\tARRAY_BUFFER=0x8892,\n\tELEMENT_ARRAY_BUFFER=0x8893,\n\tCOPY_READ_BUFFER=0x8F36,\n\tCOPY_WRITE_BUFFER=0x8F37,\n\tTRANSFORM_FEEDBACK_BUFFER=0x8C8E,\n}\n\nexport enum Buffer{\nPIXEL_PACK_BUFFER_BINDING=0x88ED,\nPIXEL_UNPACK_BUFFER_BINDING=0x88EF,\nCOPY_READ_BUFFER_BINDING=0x8F36,\nCOPY_WRITE_BUFFER_BINDING=0x8F37,\nBUFFER_SIZE=0x8764,\nBUFFER_USAGE=0x8765,\n}\n\nexport enum BufferUsage{\n\tSTATIC_DRAW=0x88E4,\n\tSTREAM_DRAW=0x88E0,\n\tDYNAMIC_DRAW=0x88E8,\t\n}\n\n\nexport enum DataType{\nBYTE=0x1400,\nUNSIGNED_BYTE=0x1401,\nSHORT=0x1402,\nUNSIGNED_SHORT=0x1403,\nINT=0x1404,\nUNSIGNED_INT=0x1405,\nFLOAT=0x1406,\nFLOAT_MAT2x3=0x8B65,\nFLOAT_MAT2x4=0x8B66,\nFLOAT_MAT3x2=0x8B67,\nFLOAT_MAT3x4=0x8B68,\nFLOAT_MAT4x2=0x8B69,\nFLOAT_MAT4x3=0x8B6A,\nUNSIGNED_INT_VEC2=0x8DC6,\nUNSIGNED_INT_VEC3=0x8DC7,\nUNSIGNED_INT_VEC4=0x8DC8,\nUNSIGNED_NORMALIZED=0x8C17,\nSIGNED_NORMALIZED=0x8F9C,\n}\nexport enum VertexAttribute{\nVERTEX_ATTRIB_ARRAY_INTEGER=0x88FD,\nVERTEX_ATTRIB_ARRAY_DIVISOR=0x88FE,\nCURRENT_VERTEX_ATTRIB=0x8626,\nVERTEX_ATTRIB_ARRAY_ENABLED=0x8622,\nVERTEX_ATTRIB_ARRAY_SIZE=0x8623,\nVERTEX_ATTRIB_ARRAY_STRIDE=0x8624,\nVERTEX_ATTRIB_ARRAY_TYPE=0x8625,\nVERTEX_ATTRIB_ARRAY_NORMALIZED=0x886A,\nVERTEX_ATTRIB_ARRAY_POINTER=0x8645,\nVERTEX_ATTRIB_ARRAY_BUFFER_BINDING=0x889F,\n}\nexport enum TransformFeedback{\nTRANSFORM_FEEDBACK_BUFFER_MODE=0x8C7F,\nMAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS=0x8C80,\nTRANSFORM_FEEDBACK_VARYINGS=0x8C83,\nTRANSFORM_FEEDBACK_BUFFER_START=0x8C84,\nTRANSFORM_FEEDBACK_BUFFER_SIZE=0x8C85,\nTRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN=0x8C88,\nMAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS=0x8C8A,\nMAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS=0x8C8B,\nINTERLEAVED_ATTRIBS=0x8C8C,\nSEPARATE_ATTRIBS=0x8C8D,\n// TRANSFORM_FEEDBACK_BUFFER=0x8C8E,\nTRANSFORM_FEEDBACK_BUFFER_BINDING=0x8C8F,\nTRANSFORM_FEEDBACK=0x8E22,\nTRANSFORM_FEEDBACK_PAUSED=0x8E23,\nTRANSFORM_FEEDBACK_ACTIVE=0x8E24,\nTRANSFORM_FEEDBACK_BINDING=0x8E25,\n}\nexport enum FrameRenderBuffer{\nFRAMEBUFFER_ATTACHMENT_COLOR_ENCODING=0x8210,\nFRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE=0x8211,\nFRAMEBUFFER_ATTACHMENT_RED_SIZE=0x8212,\nFRAMEBUFFER_ATTACHMENT_GREEN_SIZE=0x8213,\nFRAMEBUFFER_ATTACHMENT_BLUE_SIZE=0x8214,\nFRAMEBUFFER_ATTACHMENT_ALPHA_SIZE=0x8215,\nFRAMEBUFFER_ATTACHMENT_DEPTH_SIZE=0x8216,\nFRAMEBUFFER_ATTACHMENT_STENCIL_SIZE=0x8217,\nFRAMEBUFFER_DEFAULT=0x8218,\nDEPTH24_STENCIL8=0x88F0,\nDRAW_FRAMEBUFFER_BINDING=0x8CA6,\nREAD_FRAMEBUFFER=0x8CA8,\nDRAW_FRAMEBUFFER=0x8CA9,\nREAD_FRAMEBUFFER_BINDING=0x8CAA,\nRENDERBUFFER_SAMPLES=0x8CAB,\nFRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER=0x8CD4,\nFRAMEBUFFER_INCOMPLETE_MULTISAMPLE=0x8D56,\nFRAMEBUFFER=0x8D40,\nRENDERBUFFER=0x8D41,\nRGBA4=0x8056,\nRGB5_A1=0x8057,\nRGB565=0x8D62,\nDEPTH_COMPONENT16=0x81A5,\nSTENCIL_INDEX8=0x8D48,\nDEPTH_STENCIL=0x84F9,\nRENDERBUFFER_WIDTH=0x8D42,\nRENDERBUFFER_HEIGHT=0x8D43,\nRENDERBUFFER_INTERNAL_FORMAT=0x8D44,\nRENDERBUFFER_RED_SIZE=0x8D50,\nRENDERBUFFER_GREEN_SIZE=0x8D51,\nRENDERBUFFER_BLUE_SIZE=0x8D52,\nRENDERBUFFER_ALPHA_SIZE=0x8D53,\nRENDERBUFFER_DEPTH_SIZE=0x8D54,\nRENDERBUFFER_STENCIL_SIZE=0x8D55,\nFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=0x8CD0,\nFRAMEBUFFER_ATTACHMENT_OBJECT_NAME=0x8CD1,\nFRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=0x8CD2,\nFRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=0x8CD3,\nCOLOR_ATTACHMENT0=0x8CE0,\nDEPTH_ATTACHMENT=0x8D00,\nSTENCIL_ATTACHMENT=0x8D20,\nDEPTH_STENCIL_ATTACHMENT=0x821A,\nNONE=0,\nFRAMEBUFFER_COMPLETE=0x8CD5,\nFRAMEBUFFER_INCOMPLETE_ATTACHMENT=0x8CD6,\nFRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=0x8CD7,\nFRAMEBUFFER_INCOMPLETE_DIMENSIONS=0x8CD9,\nFRAMEBUFFER_UNSUPPORTED=0x8CDD,\nFRAMEBUFFER_BINDING=0x8CA6,\nRENDERBUFFER_BINDING=0x8CA7,\nMAX_RENDERBUFFER_SIZE=0x84E8,\nINVALID_FRAMEBUFFER_OPERATION=0x0506,\n}\nexport enum Uniform{\n// UNIFORM_BUFFER=0x8A11,\nUNIFORM_BUFFER_BINDING=0x8A28,\nUNIFORM_BUFFER_START=0x8A29,\nUNIFORM_BUFFER_SIZE=0x8A2A,\nMAX_VERTEX_UNIFORM_BLOCKS=0x8A2B,\nMAX_FRAGMENT_UNIFORM_BLOCKS=0x8A2D,\nMAX_COMBINED_UNIFORM_BLOCKS=0x8A2E,\nMAX_UNIFORM_BUFFER_BINDINGS=0x8A2F,\nMAX_UNIFORM_BLOCK_SIZE=0x8A30,\nMAX_COMBINED_VERTEX_UNIFORM_COMPONENTS=0x8A31,\nMAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS=0x8A33,\nUNIFORM_BUFFER_OFFSET_ALIGNMENT=0x8A34,\nACTIVE_UNIFORM_BLOCKS=0x8A36,\nUNIFORM_TYPE=0x8A37,\nUNIFORM_SIZE=0x8A38,\nUNIFORM_BLOCK_INDEX=0x8A3A,\nUNIFORM_OFFSET=0x8A3B,\nUNIFORM_ARRAY_STRIDE=0x8A3C,\nUNIFORM_MATRIX_STRIDE=0x8A3D,\nUNIFORM_IS_ROW_MAJOR=0x8A3E,\nUNIFORM_BLOCK_BINDING=0x8A3F,\nUNIFORM_BLOCK_DATA_SIZE=0x8A40,\nUNIFORM_BLOCK_ACTIVE_UNIFORMS=0x8A42,\nUNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES=0x8A43,\nUNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER=0x8A44,\nUNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER=0x8A46,\n}\nexport enum SyncObject{\nOBJECT_TYPE=0x9112,\nSYNC_CONDITION=0x9113,\nSYNC_STATUS=0x9114,\nSYNC_FLAGS=0x9115,\nSYNC_FENCE=0x9116,\nSYNC_GPU_COMMANDS_COMPLETE=0x9117,\nUNSIGNALED=0x9118,\nSIGNALED=0x9119,\nALREADY_SIGNALED=0x911A,\nTIMEOUT_EXPIRED=0x911B,\nCONDITION_SATISFIED=0x911C,\nWAIT_FAILED=0x911D,\nSYNC_FLUSH_COMMANDS_BIT=0x00000001,\n}\nexport enum Misc{\nCOLOR=0x1800,\nDEPTH=0x1801,\nSTENCIL=0x1802,\nMIN=0x8007,\nMAX=0x8008,\nDEPTH_COMPONENT24=0x81A6,\nSTREAM_READ=0x88E1,\nSTREAM_COPY=0x88E2,\nSTATIC_READ=0x88E5,\nSTATIC_COPY=0x88E6,\nDYNAMIC_READ=0x88E9,\nDYNAMIC_COPY=0x88EA,\nDEPTH_COMPONENT32F=0x8CAC,\nDEPTH32F_STENCIL8=0x8CAD,\nINVALID_INDEX=0xFFFFFFFF,\nTIMEOUT_IGNORED=-1,\nMAX_CLIENT_WAIT_TIMEOUT_WEBGL=0x9247,\n}\n\n\nexport enum ClearingBuffer{\nDEPTH_BUFFER_BIT=0x00000100,\nSTENCIL_BUFFER_BIT=0x00000400,\nCOLOR_BUFFER_BIT=0x00004000,\n}\nexport enum Primitive{\nPOINTS=0x0000,\nLINES=0x0001,\nLINE_LOOP=0x0002,\nLINE_STRIP=0x0003,\nTRIANGLES=0x0004,\nTRIANGLE_STRIP=0x0005,\nTRIANGLE_FAN=0x0006,\n}\nexport enum Blend{\nZERO=0,\nONE=1,\nSRC_COLOR=0x0300,\nONE_MINUS_SRC_COLOR=0x0301,\nSRC_ALPHA=0x0302,\nONE_MINUS_SRC_ALPHA=0x0303,\nDST_ALPHA=0x0304,\nONE_MINUS_DST_ALPHA=0x0305,\nDST_COLOR=0x0306,\nONE_MINUS_DST_COLOR=0x0307,\nSRC_ALPHA_SATURATE=0x0308,\nCONSTANT_COLOR=0x8001,\nONE_MINUS_CONSTANT_COLOR=0x8002,\nCONSTANT_ALPHA=0x8003,\nONE_MINUS_CONSTANT_ALPHA=0x8004,\n}\nexport enum BlendEquation{\nFUNC_ADD=0x8006,\nFUNC_SUBTRACT=0x800A,\nFUNC_REVERSE_SUBTRACT=0x800B,\n}\n\nexport enum Culling{\nCULL_FACE=0x0B44,\nFRONT=0x0404,\nBACK=0x0405,\nFRONT_AND_BACK=0x0408,\n}\nexport enum Toggle{\nBLEND=0x0BE2,\nDEPTH_TEST=0x0B71,\nDITHER=0x0BD0,\nPOLYGON_OFFSET_FILL=0x8037,\nSAMPLE_ALPHA_TO_COVERAGE=0x809E,\nSAMPLE_COVERAGE=0x80A0,\nSCISSOR_TEST=0x0C11,\nSTENCIL_TEST=0x0B90,\n}\nexport enum Error{\nNO_ERROR=0,\nINVALID_ENUM=0x0500,\nINVALID_VALUE=0x0501,\nINVALID_OPERATION=0x0502,\nOUT_OF_MEMORY=0x0505,\nCONTEXT_LOST_WEBGL=0x9242,\n}\nexport enum FrontFaceDirection{\nCW=0x0900,\nCCW=0x0901,\n}\nexport enum Hint{\nDONT_CARE=0x1100,\nFASTEST=0x1101,\nNICEST=0x1102,\nGENERATE_MIPMAP_HINT=0x8192,\n}\nexport enum PixelFormat{\nDEPTH_COMPONENT=0x1902,\nALPHA=0x1906,\nRGB=0x1907,\nRGBA=0x1908,\nLUMINANCE=0x1909,\nLUMINANCE_ALPHA=0x190A,\n}\nexport enum ShaderType{\n\tFRAGMENT_SHADER=0x8B30,\n\tVERTEX_SHADER=0x8B31,\t\n}\n\nexport enum ShaderStatus{\n\tCOMPILE_STATUS=0x8B81,\n\tDELETE_STATUS=0x8B80,\n\tLINK_STATUS=0x8B82,\n\tVALIDATE_STATUS=0x8B83,\n}\n\nexport enum Shader{\nATTACHED_SHADERS=0x8B85,\nACTIVE_ATTRIBUTES=0x8B89,\nACTIVE_UNIFORMS=0x8B86,\nMAX_VERTEX_ATTRIBS=0x8869,\nMAX_VERTEX_UNIFORM_VECTORS=0x8DFB,\nMAX_VARYING_VECTORS=0x8DFC,\nMAX_COMBINED_TEXTURE_IMAGE_UNITS=0x8B4D,\nMAX_VERTEX_TEXTURE_IMAGE_UNITS=0x8B4C,\nMAX_TEXTURE_IMAGE_UNITS=0x8872,\nMAX_FRAGMENT_UNIFORM_VECTORS=0x8DFD,\nSHADER_TYPE=0x8B4F,\nSHADING_LANGUAGE_VERSION=0x8B8C,\nCURRENT_PROGRAM=0x8B8D,\n\n}\nexport enum Test{\nNEVER=0x0200,\nLESS=0x0201,\nEQUAL=0x0202,\nLEQUAL=0x0203,\nGREATER=0x0204,\nNOTEQUAL=0x0205,\nGEQUAL=0x0206,\nALWAYS=0x0207,\n}\nexport enum StencilAction{\nKEEP=0x1E00,\nREPLACE=0x1E01,\nINCR=0x1E02,\nDECR=0x1E03,\nINVERT=0x150A,\nINCR_WRAP=0x8507,\nDECR_WRAP=0x8508,\n}\nexport enum UniformType{\nFLOAT_VEC2=0x8B50,\nFLOAT_VEC3=0x8B51,\nFLOAT_VEC4=0x8B52,\nINT_VEC2=0x8B53,\nINT_VEC3=0x8B54,\nINT_VEC4=0x8B55,\nBOOL=0x8B56,\nBOOL_VEC2=0x8B57,\nBOOL_VEC3=0x8B58,\nBOOL_VEC4=0x8B59,\nFLOAT_MAT2=0x8B5A,\nFLOAT_MAT3=0x8B5B,\nFLOAT_MAT4=0x8B5C,\nSAMPLER_2D=0x8B5E,\nSAMPLER_CUBE=0x8B60,\n}\nexport enum ShaderPrecision{\nLOW_FLOAT=0x8DF0,\nMEDIUM_FLOAT=0x8DF1,\nHIGH_FLOAT=0x8DF2,\nLOW_INT=0x8DF3,\nMEDIUM_INT=0x8DF4,\nHIGH_INT=0x8DF5,\n}\n\nexport enum PixelStorage{\nUNPACK_FLIP_Y_WEBGL=0x9240,\nUNPACK_PREMULTIPLY_ALPHA_WEBGL=0x9241,\nUNPACK_COLORSPACE_CONVERSION_WEBGL=0x9243,\n}\n","import { Camera, Mesh, DirectionalLight, Time, Transform } from '../components'\nimport { Matrix } from '../../math'\nimport { Viewport } from '../../utility'\nimport { Ubo, UniformName, Uniform_f32 } from '../../rendering'\nimport { ListenerSystem, TypedQuery, Entity, renderSystemPriority, World } from '../../base'\nimport { UniformBufferObjectSystem } from './UniformBufferObjectSystem'\n\nexport class RenderSystem extends ListenerSystem{\n\n\tcameraQuery: TypedQuery<Camera>\n\n\topaqueMeshes: Entity[] = []\n\ttransparentMeshes: Entity[] = []\n\tstatic canvasWidth: u32 = 100\n\tstatic canvasHeight: u32 = 100\n\tuboSystem: UniformBufferObjectSystem\t\n\tconstructor(uboSystem: UniformBufferObjectSystem){\n\t\tsuper([idof<Mesh>()], renderSystemPriority)\n\t\tthis.uboSystem = uboSystem\n\t\tthis.cameraQuery = this.world.createQuery<Camera>()\n\t\t// this.camera = this.world.createEntity()\n\t\t// \t.getOrAdd<Camera>()\n\t\t// this.uboSystem.\n\t}\n\n\tonAdd(entity: Entity): void {\n\t\tconst mesh = entity.get<Mesh>()\n\t\tif (mesh.material.transparent)\n\t\t\tthis.transparentMeshes.push(entity)\n\t\telse\n\t\t\tthis.opaqueMeshes.push(entity)\n\t\tthis.handleCreateMesh(mesh)\n\t}\n\t\n\tupdate(): void {\n\t\tsuper.update()\n\t\t\n\t\t//TODO only apply if lights in scene\n\t\tDirectionalLight.applyUbo()\n\t\tthis.uboSystem.apply(Ubo.directionalLight)\n\t\t\n\t\tfor (let i = 0; i < this.cameraQuery.components.length; i++){\n\t\t\tconst camera = this.cameraQuery.components[i]\n\t\t\t//doesnt camera update get called anyway?\n\t\t\tcamera.update()\n\t\t\tcamera.applyUbo()\n\t\t\tthis.uboSystem.apply(Ubo.camera)\n\t\t\t\n\t\t\tthis.handleViewport(camera.viewport)\n\t\t\t\n\t\t\tthis.handlePrepareOpaque()\n\t\t\tfor (let i = 0; i < this.opaqueMeshes.length; i++){\n\t\t\t\tthis.renderMesh(camera, this.opaqueMeshes[i])\n\t\t\t}\n\t\t\tthis.handlePrepareTransparent()\n\t\t\tfor (let i = 0; i < this.transparentMeshes.length; i++){\n\t\t\t\tthis.renderMesh(camera, this.transparentMeshes[i])\n\t\t\t}\n\t\t}\n\t}\n\trenderMesh(camera: Camera, entity: Entity): void {\n\t\tconst mesh = entity.get<Mesh>()\n\t\tconst transform = entity.get<Transform>()\n\t\t//update even if unused by material, maybe others would use it?\n\n\t\t//if so, this should execute just after transform system\n\t\tMatrix.multiply(mesh.modelViewProjection, camera.viewProjection, transform.worldMatrix)\n\t\tMatrix.multiply(mesh.modelView, camera.view, transform.worldMatrix)\n\t\tMatrix.transpose(mesh.inverseTransposeModel, transform.inverseWorldMatrix)\n\t\tmesh.applyUbo()\n\t\tthis.uboSystem.apply(Ubo.mesh)\n\n\t\t// TODO only update uniforms used by the shader\n\t\t// TODO only update color if dirty\n\t\t// TODO remove camera uniforms\n\t\t// TODO more efficient light copy / share\n\t\tfor (let i = 0; i < mesh.material.uniformArr.length; i++){\n\t\t\tconst uniform = mesh.material.uniformArr[i]\n\t\t\t// imports.utils.log_string(uniform.name)\n\t\t\tif (uniform.name === UniformName.Color){ /*implicit update*/ }\n\t\t\telse if (uniform.name === UniformName.Texture){ /*implicit update*/ }\n\t\t\telse if (uniform.name === UniformName.Acceleration){ /*implicit update*/ }\n\t\t\telse if (uniform.name === UniformName.Time)\n\t\t\t\t(uniform as Uniform_f32).value[0] = this.world.get<Time>().elapsed\n\t\t\telse if (uniform.name === UniformName.DeltaTime)\n\t\t\t\t(uniform as Uniform_f32).value[0] = this.world.get<Time>().delta\n\t\t\telse\n\t\t\t\tthrow new Error(`Uniform not implemented: ${uniform.name}`)\n\t\t}\n\t\tthis.handleRenderMesh(mesh)\n\t}\n\thandlePrepareOpaque(): void{}\n\thandlePrepareTransparent(): void{}\n\thandleCreateMesh(mesh: Mesh): void{}\n\thandleRenderMesh(mesh: Mesh): void{}\n\thandleViewport(viewport: Viewport): void{}\n}\n\nexport function mainCamera(): Camera|null{\n\tif (World.main.has<RenderSystem>())\n\t\treturn World.main.get<RenderSystem>().cameraQuery.components[0]\n\treturn null\n}","import { ArrayUtils } from '../../utility'\nimport { StandardGeometry } from './Geometry'\n\n\n\n\n\nexport class CubeGeometry extends StandardGeometry{\n\tstatic default: StandardGeometry = CubeGeometry.new()\n\n\tstatic positions(width: f32 = .5, height: f32 = width, depth: f32 = width): StaticArray<f32>{\n\t\tconst w = width / 2, h = height / 2, d = depth / 2\n\t\tconst v0 = [-w, -h, +d]\n\t\tconst v1 = [+w, -h, +d]\n\t\tconst v2 = [-w, +h, +d]\n\t\tconst v3 = [+w, +h, +d]\n\t\tconst v4 = [-w, -h, -d]\n\t\tconst v5 = [+w, -h, -d]\n\t\tconst v6 = [-w, +h, -d]\n\t\tconst v7 = [+w, +h, -d]\n\t\treturn ArrayUtils.flatMap([\n\t\t\tv0, v1, v2, v3, //front\n\t\t\tv5, v4, v7, v6, //back\n\t\t\tv1, v5, v3, v7, //right\n\t\t\tv4, v0, v6, v2, //left\n\t\t\tv2, v3, v6, v7, //top\n\t\t\tv1, v0, v5, v4, //bottom\n\t\t])\n\t}\n\tstatic indices(): StaticArray<u16>{\n\t\tconst arr = new StaticArray<u16>(6 * 6)\n\t\tlet ai = 0\n\t\t// const arrs: u16[][] = []\n\t\tfor (let i = 0; i < 6; i++){\n\t\t\tconst o = <u16>i * 4\n\t\t\tarr[ai++] = o + 0\n\t\t\tarr[ai++] = o + 1\n\t\t\tarr[ai++] = o + 2\n\t\t\tarr[ai++] = o + 2\n\t\t\tarr[ai++] = o + 1\n\t\t\tarr[ai++] = o + 3\n\t\t}\n\t\treturn arr\n\t}\n\tstatic uvs(): StaticArray<f32>{\n\t\tconst uv0: f32[] = [1, 0]\n\t\tconst uv1: f32[] = [0, 0]\n\t\tconst uv2: f32[] = [0, 1]\n\t\tconst uv3: f32[] = [1, 1]\t\t\n\n\t\treturn ArrayUtils.flatMap([\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t\tuv0, uv1, uv2, uv3,\n\t\t])\n\t}\n\n\n\tstatic colors(depth: u8 = 127): StaticArray<u8>{\n\t\tconst blue1: u8[] = [0, 0, 255, 255]\n\t\tconst blue2: u8[] = [0, 0, depth, 255]\n\t\tconst red1: u8[] = [255, 0, 0, 255]\n\t\tconst red2: u8[] = [depth, 0, 0, 255]\n\t\tconst green1: u8[] = [0, 255, 0, 255]\n\t\tconst green2: u8[] = [0, depth, 0, 255]\n\t\treturn ArrayUtils.flatMap([\n\t\t\tblue1, blue1, blue1, blue1,\t\t\t\n\t\t\tblue2, blue2, blue2, blue2,\t\t\t\n\t\t\tred1, red1, red1, red1,\t\t\t\n\t\t\tred2, red2, red2, red2,\t\t\t\n\t\t\tgreen1, green1, green1, green1,\t\t\t\n\t\t\tgreen2, green2, green2, green2,\t\t\t\n\t\t])\n\t}\n\tstatic new(): StandardGeometry{\n\t\treturn StandardGeometry.fromStatic(\n\t\t\tCubeGeometry.positions(), \n\t\t\tCubeGeometry.indices(),\n\t\t\tCubeGeometry.uvs(),\n\t\t\tCubeGeometry.colors())\n\t}\n\t// constructor(){\n\n\t// \t// super()\n\t// }\n\n\t\n}","import { NormalUtils } from '../../utility'\nimport { toTyped_f32, toTyped_u16, toTyped_u8 } from '../../utility/_ArrayUtils'\nimport { gl } from '../../WebGL2'\nimport { AttributeName } from '../constants'\nimport { Attribute, Attribute_f32, Attribute_u8 } from './Attribute'\n\n\n\nexport class Geometry {\n\tvertexCount: u32 = 0\n\t//TODO decouple geometry from WebGL\n\tprimitiveType: gl.Primitive = gl.Primitive.TRIANGLES\n\tattributeMap: Map<string, Attribute> = new Map()\n\tattributeArr: Attribute[] = []\n\n\t//TODO move to index geometry\n\tdynamicIndices: bool = false\n\tindices: Uint16Array | null\n\n\tinstanceCount: u32 = 0\n\n\tstatic new(vertexCount: u32): Geometry{ return new Geometry(vertexCount) }\n\tconstructor(vertexCount: u32){\n\t\tthis.vertexCount = vertexCount\n\t}\n\taddAttribute(attr: Attribute): Geometry{\n\t\tthis.attributeMap.set(attr.name, attr)\n\t\tthis.attributeArr.push(attr)\n\t\treturn this\n\t}\n\n\tsetInstanceCount(instanceCount: u32): Geometry{\n\t\tthis.instanceCount = instanceCount\n\t\treturn this\n\t}\n\n\tsetPrimitiveType(type: gl.Primitive): Geometry{\n\t\tthis.primitiveType = type\n\t\treturn this\n\t}\n\n\tsetIndices(indices: Uint16Array): Geometry{\n\t\tthis.indices = indices\n\t\treturn this\n\t}\n\taddTexcoords(texcoords: Float32Array): Geometry{\n\t\tthis.addAttribute(Attribute.Vec2(AttributeName.Texcoord, texcoords))\n\t\treturn this\n\t}\n}\n\nexport class PositionGeometry extends Geometry{\n\n\tpositions: Float32Array\n\tconstructor(positions: Float32Array){\n\t\tsuper(positions.length / 3)\n\t\tthis.positions = positions\n\t\tthis.addAttribute(Attribute.Vec3(AttributeName.Position, positions))\n\t}\n}\n\n\n\nexport class IndexGeometry extends PositionGeometry{\n\t\n\tnormals: Float32Array\n\n\tconstructor(positions: Float32Array, indices: Uint16Array, normals: Float32Array | null = null){\n\t\tsuper(positions)\n\t\tthis.indices = indices\n\t\tif (normals == null)\n\t\t\tthis.normals = new Float32Array(positions.length)\n\t\telse\n\t\t\tthis.normals = normals\n\t\tthis.addAttribute(Attribute.Vec3(AttributeName.Normal, this.normals))\n\t\tif (normals == null)\n\t\t\tthis.calculateNormals()\n\t}\n\n\t\n\tcalculateNormals(): void{\n\t\tconst indices = this.indices\n\t\tif (this.primitiveType !== gl.Primitive.TRIANGLES || !indices)\n\t\t\tthrow new Error('currently only triangle normals can be calculated')\n\t\tNormalUtils.normalsFromTriangles(this.positions, indices, this.normals)\n\t}\n}\n\n\nexport class StandardGeometry extends IndexGeometry{\n\tcolors: Uint8Array\n\ttexcoords: Float32Array\n\n\tstatic fromStatic(positions: StaticArray<f32>, indices: StaticArray<u16>, texcoords: StaticArray<f32>, colors: StaticArray<u8>): StandardGeometry{\n\t\treturn new StandardGeometry(\n\t\t\ttoTyped_f32(positions),\n\t\t\ttoTyped_u16(indices),\n\t\t\ttoTyped_f32(texcoords),\n\t\t\ttoTyped_u8(colors)\n\t\t)\n\t}\n\n\tconstructor(positions: Float32Array, indices: Uint16Array, texcoords: Float32Array, colors: Uint8Array){\n\t\tsuper(positions, indices)\n\t\tthis.colors = colors\n\t\tthis.texcoords = texcoords\n\t\tthis.addAttribute(new Attribute_f32(AttributeName.Texcoord, 2, texcoords))\n\t\tthis.addAttribute(new Attribute_u8(AttributeName.Color, 4, colors))\n\t}\n}","import { gl } from '../../WebGL2'\n\nexport class Attribute{\n\n\tstatic Float(name: string, value: Float32Array, dynamic: bool = false): Attribute_f32{\n\t\treturn new Attribute_f32(name, 1, value, dynamic)\n\t}\n\tstatic Vec2(name: string, value: Float32Array, dynamic: bool = false): Attribute_f32{\n\t\treturn new Attribute_f32(name, 2, value, dynamic)\n\t}\n\tstatic Vec3(name: string, value: Float32Array, dynamic: bool = false): Attribute_f32{\n\t\treturn new Attribute_f32(name, 3, value, dynamic)\n\t}\n\tstatic Vec4(name: string, value: Float32Array, dynamic: bool = false): Attribute_f32{\n\t\treturn new Attribute_f32(name, 4, value, dynamic)\n\t}\n\n\tname: string\n\tvaryingName: string | null\n\tnormalize: bool = false\n\tdynamic: bool = false\n\t//TODO decouple attribute from webgl\n\ttype: gl.DataType = gl.DataType.FLOAT\n\telementSize: u8\n\tinstanceDivisor: u32 = 0\n\n\tconstructor(name: string, elementSize: u8, dynamic: bool = false){\n\t\tthis.name = name\n\t\tthis.elementSize = elementSize\n\t\tthis.dynamic = dynamic\n\t}\n\n\tasVarying(varyingName: string): Attribute{\n\t\tthis.dynamic = true\n\t\tthis.varyingName = varyingName\n\t\treturn this\n\t}\n\n\tasInstanced(divisor: u32 = 1): Attribute{\n\t\tthis.instanceDivisor = divisor\n\t\treturn this\n\t}\n}\n\nexport class TypedAttribute<T> extends Attribute{\n\tvalue: T\n\tnumElements: u32\n\tconstructor(name: string, elementSize: u8, value: T, dynamic: bool = false){\n\t\tsuper(name, elementSize, dynamic)\n\t\tthis.value = value\n\t\t//@ts-ignore\n\t\tthis.numElements = this.value.length / this.elementSize\n\t}\n}\nexport class Attribute_f32 extends TypedAttribute<Float32Array>{}\nexport class Attribute_u8 extends TypedAttribute<Uint8Array>{\n\ttype: gl.DataType = gl.DataType.UNSIGNED_BYTE\n\tnormalize: bool = true\n}","import { Vector3 } from '../math'\n\nexport function normalsFromTriangles(positions: Float32Array, indices: Uint16Array, normals: Float32Array): void{\n\n\tconst vec1 = new Vector3()\n\t\t, vec2 = new Vector3()\n\t\t, vec3 = new Vector3()\n\t\t, right = new Vector3()\n\t\t, up = new Vector3()\n\t\t, fwd = new Vector3()\n\n\t//https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal\n\tfor (let i = 0; i < indices.length; i += 3){\n\t\tconst vi1 = indices[i] * 3\n\t\tconst vi2 = indices[i + 1] * 3\n\t\tconst vi3 = indices[i + 2] * 3\n\t\tvec1.set(positions[vi1], positions[vi1 + 1], positions[vi1 + 2])\n\t\tvec2.set(positions[vi2], positions[vi2 + 1], positions[vi2 + 2])\n\t\tvec3.set(positions[vi3], positions[vi3 + 1], positions[vi3 + 2])\n\t\n\t\tVector3.sub(vec2, vec1, right)\n\t\tVector3.sub(vec3, vec1, up)\n\t\tVector3.crossNormalized(right, up, fwd)\n\t\n\t\tnormals[vi1] = fwd.x\n\t\tnormals[vi1 + 1] = fwd.y\n\t\tnormals[vi1 + 2] = fwd.z\n\t\n\t\tnormals[vi2] = fwd.x\n\t\tnormals[vi2 + 1] = fwd.y\n\t\tnormals[vi2 + 2] = fwd.z\n\t\n\t\tnormals[vi3] = fwd.x\n\t\tnormals[vi3 + 1] = fwd.y\n\t\tnormals[vi3 + 2] = fwd.z\n\t}\t\t\n}","import { arrayToTyped } from '../../utility/_ArrayUtils'\nimport { StandardGeometry } from './Geometry'\n\n\n// this.indices = ArrayUtils.toTyped_u16(indices)\n// this.positions = ArrayUtils.toTyped_f32(positions)\n// this.uvs = ArrayUtils.toTyped_f32(uvs)\n\nexport function createQuadPositions(width: f32 = 1, height: f32 = width): Float32Array{\n\tconst hw: f32 = width / 2\n\tconst hh: f32 = height / 2\n\treturn arrayToTyped<f32, Float32Array>([\n\t\t-hw, -hh, 0,\n\t\t+hw, -hh, 0,\n\t\t+hw, +hh, 0,\n\t\t-hw, +hh, 0,\n\t])\n}\n\n\nexport function createQuadIndices(): Uint16Array{\n\treturn arrayToTyped<u16, Uint16Array>([\n\t\t0, 1, 2, 2, 3, 0])\n}\n\nexport function createQuadUvs(): Float32Array{\n\treturn arrayToTyped<f32, Float32Array>([\n\t\t0, 0,\n\t\t1, 0,\n\t\t1, 1,\n\t\t0, 1,\n\t])\n}\n\nexport class QuadGeometry extends StandardGeometry{\n\tstatic default: QuadGeometry = new QuadGeometry()\n\tstatic new(width: f32 = 1): QuadGeometry{\n\t\treturn new QuadGeometry(width)\n\t}\n\tconstructor(width: f32 = <f32>1){\n\t\tconst positions = createQuadPositions(width)\n\t\tconst indices = createQuadIndices()\n\t\tconst colors = arrayToTyped<u8, Uint8Array>([\n\t\t\t255, 255, 255, 255,\n\t\t\t255, 255, 0, 255,\n\t\t\t225, 0, 255, 255,\n\t\t\t0, 255, 255, 255,\n\t\t])\n\t\tconst uvs = createQuadUvs()\n\t\tsuper(positions, indices, uvs, colors)\n\t}\n}\n\nexport const quadGeometry = new QuadGeometry()","import { ArrayUtils } from '../../utility'\nimport { flatMapStatic, arrayToStatic } from '../../utility/_ArrayUtils'\nimport { CubeGeometry } from './CubeGeometry'\nimport { StandardGeometry } from './Geometry'\n\nexport class TransformGeometry extends StandardGeometry{\n\n\tstatic default: StandardGeometry = TransformGeometry.new()\n\n\tstatic positions(width: f32 = 0.02, length: f32 = 1): StaticArray<f32>{\n\t\tconst right = CubeGeometry.positions(length, width, width)\n\t\tconst up = CubeGeometry.positions(width, length, width)\n\t\tconst fwd = CubeGeometry.positions(width, width, length)\n\t\tconst hLen = length / 2\n\t\tconst hWidth = width / 2\n\t\tfor (let i = 0; i < right.length; i += 3) {\n\t\t\tright[i] += hLen + hWidth\n\t\t\tup[i + 1] += hLen + hWidth\n\t\t\tfwd[i + 2] += hLen + hWidth\n\t\t}\n\t\treturn flatMapStatic(arrayToStatic([right, up, fwd]))\n\t}\n\n\tstatic indices(): StaticArray<u16>{\n\t\tconst right = CubeGeometry.indices()\n\t\tconst up = CubeGeometry.indices()\n\t\tconst fwd = CubeGeometry.indices()\n\t\tconst indicesPerCube = <u16>6 * 6\n\t\tconst verticesPerCube = <u16>4 * 6\n\t\tfor (let i = 0; i < up.length; i++){\n\t\t\tup[i] += verticesPerCube\n\t\t\tfwd[i] += verticesPerCube * 2\n\t\t}\n\t\t// return right\n\t\treturn flatMapStatic(arrayToStatic([right, up, fwd]))\n\t}\n\tstatic uvs(): StaticArray<f32>{\n\t\tconst right = CubeGeometry.uvs()\n\t\tconst up = CubeGeometry.uvs()\n\t\tconst fwd = CubeGeometry.uvs()\n\t\treturn flatMapStatic(arrayToStatic([right, up, fwd]))\n\t}\n\tstatic colors(): StaticArray<u8>{\n\t\tconst numVerts = 4 * 6\n\t\tconst right = new StaticArray<u8>(numVerts * 4)\n\t\tconst up = new StaticArray<u8>(numVerts * 4)\n\t\tconst fwd = new StaticArray<u8>(numVerts * 4)\n\t\tArrayUtils.fill(right, [<u8>255, 0, 0, 255])\n\t\tArrayUtils.fill(up, [<u8>0, 255, 0, 255])\n\t\tArrayUtils.fill(fwd, [<u8>0, 0, 255, 255])\n\t\treturn flatMapStatic(arrayToStatic([right, up, fwd]))\n\t}\n\n\tstatic new(): StandardGeometry{\n\t\treturn StandardGeometry.fromStatic(\n\t\t\tTransformGeometry.positions(), \n\t\t\tTransformGeometry.indices(), \n\t\t\tTransformGeometry.uvs(), \n\t\t\tTransformGeometry.colors())\n\t}\n}","import { AttributeName, Ubo, UniformName } from '../constants'\nimport { Shader } from './Shader'\n\nconst vert = /*glsl*/\n`#version 300 es\n${Ubo.camera.block}\n${Ubo.mesh.block}\n\nin vec3 ${AttributeName.Position};\nin vec4 ${AttributeName.InstancePosition};\nin vec3 ${AttributeName.InstanceTangent};\nin vec2 ${AttributeName.Texcoord};\nin vec3 ${AttributeName.Normal};\nout vec2 v_uv;\nout vec3 v_normal;\n\nvec3 matrixPosition(mat4 matrix){\n\treturn matrix[3].xyz;\n}\n\nvec3 modelSpaceCameraDirection(vec3 position){\n\treturn (${UniformName.InverseModel} * vec4(matrixPosition(${UniformName.CameraModel}),1)).xyz - position;\n}\n\nvoid main(void) {\n\tvec4 pos = ${AttributeName.InstancePosition} + vec4(${AttributeName.InstanceTangent} * max(0.,${AttributeName.Position}.x) * 8.,0);\n\t\n\tvec3 fwd = modelSpaceCameraDirection(pos.xyz);\n\tvec3 up = ${AttributeName.InstanceTangent};\n\tvec3 right = normalize(cross(fwd,up));\n\t\n\tgl_Position = ${UniformName.ModelViewProjection} * (pos + vec4(right * ${AttributeName.Position}.y,0));\n\tv_normal = ${AttributeName.InstanceTangent};\t\t\t\n}\n`\n\nconst frag = /*glsl*/\n`#version 300 es\nprecision mediump float;\nout vec4 o_color;\nin vec3 v_normal;\n\nvoid main(void) {\n\to_color = vec4(v_normal * 0.5 + 0.5,1);\n}\n`\n\n\n\n\nexport const debugNormalsShader = new Shader(vert, frag)\n","\nexport class Shader{\n\tvert: string\n\tfrag: string\n\tvaryings: string[]\n\tstatic new(vert: string, frag: string, varyings: string[] = []): Shader{\n\t\treturn new Shader(vert, frag, varyings)\n\t}\n\tconstructor(vert: string, frag: string, varyings: string[] = []){\n\t\tthis.vert = vert\n\t\tthis.frag = frag\n\t\tthis.varyings = varyings\n\t}\n}\n","import { UniformName } from '../../constants'\n\n\n\nexport const glslUtils = /*glsl*/`\n#ifndef MATH_UTILS\n#define MATH_UTILS\nconst float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n#endif\n`\nexport const lightConstants = /*glsl*/`\n#ifndef LIGHT_CONSTANTS\n#define LIGHT_CONSTANTS\n#define NUM_LIGHTS 8\n#endif\n`\nexport const lightUtils = /*glsl*/`\n#ifndef LIGHT_UTILS\n#define LIGHT_UTILS\nvec3 calculateDirectionalLightAtIndex(vec3 diffuse,vec3 normal,int index){\n\tfloat strength = max(dot(normal,-${UniformName.DirectionalLights_direction}[index]),0.);\n\treturn \n\tdiffuse * strength + \n\tdiffuse * ${UniformName.DirectionalLights_ambientIntensity}[index];\n\t// return vec3(0.,0.,0.);\n}\n\nvec3 calculateLighting(vec3 diffuse,vec3 normal){\n\tnormal = normalize(normal);\n\tvec3 outputColor = vec3(0.,0.,0.);\n\t//TODO only iterate instantiated lights\n\tfor(int i = 0; i < NUM_LIGHTS; i++){\n\t\toutputColor += calculateDirectionalLightAtIndex(diffuse,normal,i);\n\t}\n\treturn outputColor;\n}\n\n#endif\n`","// import { Mesh } from '../../components'\nimport { UniformName, AttributeName, Ubo } from '../../constants'\nimport { StandardMaterial } from '../../material'\nimport { lightConstants, lightUtils } from '../glsl'\nimport { Shader } from '../Shader'\n\n// ${Mesh.ubo.block}\nconst vert = /*glsl*/\n`#version 300 es\n${Ubo.mesh.block}\n${Ubo.camera.block}\n\nin vec4 ${AttributeName.Position};\nin vec3 ${AttributeName.Normal};\nin vec2 ${AttributeName.Texcoord};\n\nout vec3 v_normal;\nout vec2 v_texcoord;\n\nvoid main(void) {\n\tgl_Position = ${UniformName.ModelViewProjection} * ${AttributeName.Position};\n\tv_normal = mat3(${UniformName.InverseTransposeModel}) * ${AttributeName.Normal};\n\tv_texcoord = ${AttributeName.Texcoord};\n}\n`\n\nconst frag = /*glsl*/\n`#version 300 es\nprecision mediump float;\n${lightConstants}\n${Ubo.directionalLight.block}\n\nuniform vec4 ${UniformName.Color};\nuniform sampler2D ${UniformName.Texture};\n\n${lightUtils}\n\nin vec3 v_normal;\nin vec2 v_texcoord;\nout vec4 o_color;\n\nvoid main(void) {\n\t//TODO input color for lighting first\n\tvec4 diffuse = (${UniformName.Color} * texture(${UniformName.Texture}, v_texcoord));\n\tvec3 outputColor = calculateLighting(diffuse.xyz, v_normal);\n\to_color = vec4(outputColor,${UniformName.Color}.a);\n}\n`\n\nexport const litShader = new Shader(vert, frag)","import { AttributeName, Ubo, UniformName } from '../constants'\nimport { Shader } from './Shader'\nimport { glslUtils } from './glsl'\n\nconst a_pos = AttributeName.Position\nconst a_iPos = AttributeName.InstancePosition\nconst a_texcoord = AttributeName.Texcoord\n// const u_mvp = UniformName.ModelViewProjection\nconst u_m = UniformName.Model\nconst u_v = UniformName.View\nconst u_p = UniformName.Projection\n// const u_mv = UniformName.ModelView\n\nconst vert = /*glsl*/`#version 300 es\n\n${glslUtils}\n${Ubo.mesh.block}\n${Ubo.camera.block}\n\nin vec3 ${a_pos};\nin vec3 ${a_iPos};\nin vec2 ${a_texcoord};\nout vec2 v_uv;\nout float v_col;\n\nvoid main() {\n\tvec4 modelPos = vec4(${u_m}[3].xyz + ${a_iPos},1);\n\tvec4 modelViewPos = ${u_v} * modelPos;\n\tvec3 vertModelPos = ${a_pos};\n\tvec4 vertPos = vec4(modelViewPos.xyz + vertModelPos,1);\n\tgl_Position = ${u_p} * vertPos;\n\tv_uv = \t${a_texcoord};\n\tv_col = rand(vec2(gl_InstanceID,0));\n\t// vec4 vertPos = vec4(${a_iPos} + ${a_pos},1);\n\t// gl_Position = u_mvp * vertPos;\n}\n`\n\nconst frag = /*glsl*/`#version 300 es\nprecision mediump float;\n\n\nin vec2 v_uv;\nin float v_col;\n\nout vec4 o_color;\nvoid main() {\n\tvec2 signedUV = v_uv * 2. - 1.;\n\tfloat len = min(length(signedUV),1.);\n\to_color = vec4(0.,v_col,1.,1. - len);\n}\n`\n\nexport const particleRenderShader = new Shader(vert, frag)","import { AttributeName, UniformName, VaryingName } from '../constants'\nimport { Shader } from './Shader'\nimport { glslUtils } from './glsl'\n\nconst a_pos = AttributeName.InstancePosition\nconst a_vel = AttributeName.InstanceVelocity\n\nconst v_vel = VaryingName.InstanceVelocity\nconst v_pos = VaryingName.InstancePosition\n\nconst u_acc = UniformName.Acceleration\nconst u_dt = UniformName.DeltaTime\n\nconst vert = /*glsl*/`#version 300 es\n\n${glslUtils}\n\nuniform float ${u_dt};\nuniform vec3 ${u_acc};\n\nin vec3 ${a_pos};\nin vec3 ${a_vel};\nout vec3 ${v_pos};\nout vec3 ${v_vel};\n\n\nvoid main() {\n\t${v_vel} = ${a_vel} + ${u_acc} * ${u_dt};\n\t${v_pos} = ${a_pos} + ${v_vel} * ${u_dt};\n\tif(${v_pos}.y < 0.){\n\t\tfloat rnd = rand(vec2(gl_VertexID,0));\n\t\tfloat rnd2 = rand(vec2(0,gl_VertexID));\n\t\t${v_vel} = vec3(0.,rnd2,1.);\n\t\t// ${v_pos} = vec3((rnd * 2. - 1.) * 50.,100., 0.);\n\t\t${v_pos} = vec3((rnd * 2. - 1.) * 5.,10., 0.);\n\t}\n}\n`\nconst frag = /*glsl*/`#version 300 es\nprecision highp float;\nvoid main() {}\n`\nexport const transformFeedbackShader = new Shader(vert, frag, [v_pos, v_vel])\n\n","import { AttributeName, VaryingName } from '../constants'\nimport { Shader } from './Shader'\n\nconst vert = /*glsl*/`#version 300 es\nin vec3 ${AttributeName.InstancePosition};\n// in vec3 a_velocity; \nout vec3 ${VaryingName.InstancePosition};\n \nvoid main() {\n\t${VaryingName.InstancePosition} = ${AttributeName.InstancePosition} + vec3(0.01,0.01,0.01);\n}\n`\nconst frag = /*glsl*/`#version 300 es\nprecision highp float;\nvoid main() {}\n`\nexport const transformFeedbackSimpleShader = new Shader(vert, frag, [VaryingName.InstancePosition])\n\n","// import { Mesh } from '../../components'\n// import { imports } from '../../glue'\nimport { UniformName, AttributeName, Ubo } from '../../constants'\nimport { StandardMaterial } from '../../material'\nimport { Shader } from '../Shader'\n// ${Mesh.ubo.block}\nconst vert = /*glsl*/\n`#version 300 es\n${Ubo.mesh.block}\nin vec4 ${AttributeName.Position};\n\nvoid main(void) {\n\tgl_Position = ${UniformName.ModelViewProjection} * ${AttributeName.Position};\n}\n`\n\nconst frag = /*glsl*/\n`#version 300 es\nprecision mediump float;\n\nuniform vec4 u_color;\nout vec4 o_color;\n\nvoid main(void) {\n\to_color = u_color;\n}\n`\n\nexport const unlitShader = new Shader(vert, frag)\n","// import { Mesh } from '../../components'\n// import { imports } from '../../glue'\nimport { UniformName, AttributeName, Ubo } from '../../constants'\nimport { StandardMaterial } from '../../material'\nimport { Shader } from '../Shader'\n// ${Mesh.ubo.block}\nconst vert = /*glsl*/\n`#version 300 es\n${Ubo.mesh.block}\n${Ubo.camera.block}\n\nin vec4 ${AttributeName.Position};\nin vec4 a_color;\n\nout vec4 v_color;\n\nvoid main(void) {\n\tgl_Position = ${UniformName.ModelViewProjection} * ${AttributeName.Position};\n\tv_color = a_color;\n}\n`\n\nconst frag = /*glsl*/\n`#version 300 es\nprecision mediump float;\n\nuniform vec4 u_color;\nin vec4 v_color;\nout vec4 o_color;\n\nvoid main(void) {\n\to_color = u_color * v_color;\n}\n`\n\nexport const unlitVertexColorShader = new Shader(vert, frag)\n","import { Material } from '../material'\nimport { Shader } from './Shader'\n\nconst vert = /*glsl*/\n`#version 300 es\n\nin vec4 a_position;\nin vec2 a_texcoord;\n\nout vec2 v_uv;\n\nvoid main(void) {\n\tgl_Position = a_position;\n\tv_uv = a_texcoord;\n}\n`\n\nconst frag = /*glsl*/\n`#version 300 es\nprecision mediump float;\nout vec4 o_color;\nin vec2 v_uv;\n\nvoid main(void) {\n\to_color = vec4(v_uv.xy,1,1);\n}\n`\n\nexport const uvDebugShader = new Shader(vert, frag)\n// export const uvDebugMaterial = new Material(uvDebugShader)","import { System, SystemPriority, renderSystemPriority } from '../../base'\nimport { KeyboardCode } from '../../constants'\nimport { Vector2 } from '../../math'\n\nexport class InputSystem extends System{\n\tstatic id: u32 = idof<InputSystem>()\n\n\tmousePos: Vector2 = new Vector2()\n\tmouseDeltaPos: Vector2 = new Vector2()\n\n\tmouseWheelDeltaPos: Vector2 = new Vector2()\n\n\tmouseDown: bool\n\tmouseUp: bool\n\tmouseIsDown: bool\n\n\tkeysDown: Set<KeyboardCode> = new Set()\n\tkeysIsDown: Set<KeyboardCode> = new Set()\n\tkeysUp: Set<KeyboardCode> = new Set()\n\n\tconstructor(){\n\t\tsuper(SystemPriority.after(renderSystemPriority))\n\t}\n\n\n\thandleMouseDown(): void{\n\t\tthis.mouseIsDown = true\n\t\tthis.mouseDown = true\n\t}\n\thandleMouseUp(): void{\n\t\tthis.mouseUp = true\n\t\tthis.mouseIsDown = false\n\t}\n\n\thandleKeyDown(code: KeyboardCode): void{\n\t\tthis.keysDown.add(code)\n\t\tthis.keysIsDown.add(code)\n\t}\n\thandleKeyUp(code: KeyboardCode): void{\n\t\tthis.keysDown.delete(code)\n\t\tthis.keysIsDown.delete(code)\n\t}\n\n\thandleMouseMove(x: f32, y: f32): void{\n\t\tthis.mouseDeltaPos.set(x - this.mousePos.x, y - this.mousePos.y)\n\t\tthis.mousePos.set(x, y)\n\t}\n\thandleMouseWheel(x: f32, y: f32): void{\n\t\tthis.mouseWheelDeltaPos.set(x, y)\n\t}\n\n\tupdate(): void {\n\t\tthis.mouseDown = false\n\t\tthis.mouseUp = false\n\t\tthis.mouseDeltaPos.set(0, 0)\n\t\tthis.mouseWheelDeltaPos.set(0, 0)\n\t\t\n\t\tthis.keysDown.clear()\n\t\tthis.keysUp.clear()\n\t}\n\t\n}\n","import { ListenerSystem, TypedQuery, transformSystemPriority, Entity } from '../../base'\nimport { Transform } from '../components'\n\nexport class TransformSystem extends ListenerSystem{\n\tstatic id: u32 = idof<TransformSystem>()\n\ttransformQuery: TypedQuery<Transform>\n\n\troot: Transform\n\tconstructor(){\n\t\tsuper([idof<Transform>()], transformSystemPriority)\n\t\tthis.transformQuery = this.world.createQuery<Transform>()\n\t\tthis.root = this.world\n\t\t\t.createEntity()\n\t\t\t.getOrAdd<Transform>()\n\t}\n\tonAdd(entity: Entity): void {\n\t\tconst transform = entity.get<Transform>()\n\t\tif (transform != this.root && transform.parent == null)\n\t\t\ttransform.setParent(this.root)\n\t}\n\tonRemove(entity: Entity): void {\n\t\tconst transform = entity.get<Transform>()\n\t\tif (transform.parent === this.root)\n\t\t\ttransform.setParent(null)\n\t}\n\tupdate(): void {\n\t\tthis.root.updateWorldMatrix(false, true)\n\t}\n}","import { Vector1 } from './Vector1'\nimport { Vector3 } from './Vector3'\n\n\n\nexport class SharedBuffer_f32<T>{\n\tarr: Float32Array\n\tinstances: T[] = []\n\tstride: u16\n\tget strideBytes(): u16 { return this.stride * <u16>Float32Array.BYTES_PER_ELEMENT }\n\tconstructor(stride: u16){\n\t\tthis.stride = stride\n\t\tthis.arr = new Float32Array(0)\n\t}\n\n\tadd(): T{\n\t\tconst instance = instantiate<T>()\n\t\tthis.instances.push(instance)\n\t\tthis.resizeArray()\n\t\treturn instance\n\t}\n\tresizeArray(): void{\n\t\tconst newArray = new Float32Array(this.instances.length * this.stride)\n\t\tfor (let i = 0; i < this.arr.length; i++){\n\t\t\tnewArray[i] = this.arr[i]\n\t\t}\n\t\tthis.arr = newArray\n\t\tthis.updateInstanceBuffers()\n\t}\n\tupdateInstanceBuffers(): void{\n\t\tfor (let i = 0; i < this.instances.length; i++){\n\t\t\t//@ts-ignore\n\t\t\tthis.instances[i].m = Float32Array.wrap(this.arr.buffer, this.strideBytes * i, this.stride)\n\t\t}\n\t}\n}\n\nexport class SharedBufferVector1 extends SharedBuffer_f32<Vector1>{\n\tconstructor(){ super(1) }}\nexport class SharedBufferVector3 extends SharedBuffer_f32<Vector3>{\n\tconstructor(){ super(3) }}","import { Vector1, SharedBufferVector1, SharedBufferVector3, Vector3 } from '../../math'\nimport { Ubo, UniformName, Uniform_f32 } from '../../rendering'\nimport { Component } from '../../base'\n\nexport class DirectionalLight extends Component{\n\n\t\n\tstatic directionBuffer: SharedBufferVector3 = new SharedBufferVector3()\n\tstatic ambientIntensityBuffer: SharedBufferVector1 = new SharedBufferVector1()\n\t// intensity: SharedBufferView_f32\n\tambientIntensity: Vector1\n\tdirection: Vector3\n\n\tconstructor(){\n\t\tsuper()\n\t\tthis.direction = DirectionalLight.directionBuffer.add().set(-1, -1, -1)\n\t\tthis.ambientIntensity = DirectionalLight.ambientIntensityBuffer.add().set(0.2) as Vector1\n\t}\n\n\tsetDirection(x: f32, y: f32, z: f32): DirectionalLight{\n\t\tthis.direction.set(x, y, z)\n\t\treturn this\n\t}\n\tsetIntensity(value: f32): DirectionalLight{\n\t\tthis.ambientIntensity.set(value)\n\t\treturn this\n\t}\n\n\tstatic applyUbo(): void{\n\t\t(Ubo.directionalLight.uniformMap.get(UniformName.DirectionalLights_direction) as Uniform_f32).value = DirectionalLight.directionBuffer.arr;\n\t\t(Ubo.directionalLight.uniformMap.get(UniformName.DirectionalLights_ambientIntensity) as Uniform_f32).value = DirectionalLight.ambientIntensityBuffer.arr\n\t}\n}","import { Entity, World } from '../base'\nimport { MouseKeyboardController, Transform, Camera } from '../core/components'\nimport { Vector3, TAU } from '../math'\nimport { RenderSystem, TransformSystem } from '../core'\n\nexport function createDefaultCamera(keyboardControls: bool = true, mouseControls: bool = true): Entity{\n\t\t\n\tconst parentEntity = World.main.createEntity()\n\t\t.add<Transform>()\t\n\t\t.add<MouseKeyboardController>()\n\n\tconst controller = parentEntity.get<MouseKeyboardController>()\n\tif (!keyboardControls){\n\t\tcontroller.keyRotationScalar = 0\n\t\tcontroller.keyTranslationScalar = 0\n\t}\n\tif (!mouseControls){\n\t\tcontroller.wheelTranslationScalar = 0\n\t\tcontroller.mouseRotationScalar = 0\n\t}\n\n\tconst parent = parentEntity.get<Transform>()\n\t\t\n\t\t\n\tconst backAngle = new Vector3(0, TAU * .5, 0)\n\t// parent.rotation.lookAt(Vector3._back)\n\tparent.rotation.fromEulerAngles(backAngle)\n\tparent.position.z = 3\n\tparent.position.y = 1\n\t\t\n\t// const \n\tconst cameraEntity =  World.main.createEntity()\n\t\t.attach(new Transform(parent))\n\t\t.add<Camera>()\n\t\n\tconst child = cameraEntity.get<Transform>()\n\tchild.rotation.fromEulerAngles(backAngle)\n\t// parent.rotation.lookAt(Vector3._back)\n\n\treturn cameraEntity\n}\n\nexport function removeAllCameras(): void{\n\tconst renderSystem = World.main.get<RenderSystem>()\n\tconst root = World.main.get<TransformSystem>().root\n\tconst cameras = renderSystem.cameraQuery.components\n\tfor (let i = 0; i < cameras.length; i++){\n\t\tconst camera = cameras[i]\n\t\tconst parent = camera.entity.get<Transform>().parent\n\t\tif (parent != null && parent != root)\n\t\t\tparent.entity.dispose()\n\t\tcamera.entity.dispose()\n\t}\n}","import { CID, Component } from './Component'\nimport { EID, Entity } from './Entity'\nimport { ListenerSystemManager } from './ListenerSystemManager'\nimport { ObjectBase } from './Object'\nimport { Query, TypedQuery } from './Query'\nimport { QueryManager } from './QueryManager'\nimport { ListenerSystem, System } from './System'\nimport { SystemPriority } from './SystemPriority'\n\n\nexport class World{\n\tstatic _main: World|null\n\tstatic get main(): World{ \n\t\tconst world = World._main\n\t\treturn world ? world : new World() \n\t}\n\tstatic set main(world: World){ World._main = world }\n\t_entity: Entity |null\n\tget entity(): Entity{ \n\t\tconst entity = this._entity\n\t\treturn entity ? entity : this.createEntity() \n\t}\n\tset entity(entity: Entity){ this._entity = entity }\n\tsystems: System[] = []\n\teidIncr: EID = 0\n\tisRunning: bool = false\n\n\tentityMap: Map<EID, Entity> = new Map()\n\tworldMap: Map<u32, ObjectBase> = new Map()\n\n\tqueryManager: QueryManager = new QueryManager()\n\tlistenerSystemManager: ListenerSystemManager = new ListenerSystemManager()\n\tconstructor(){\n\t\tthis.bind()\n\t}\n\t\n\tbind(): World{\n\t\tWorld.main = this\n\t\treturn this\n\t}\n\t//TODO iterate and return first instanceof instead of map\n\tget<T extends ObjectBase>(): T{ return this.worldMap.get(idof<T>()) as T }\n\tgetById(id: u32): ObjectBase { return this.worldMap.get(id) }\n\tgetOrAdd<T extends ObjectBase>(): T{ \n\t\tif (this.has<T>())\n\t\t\treturn this.get<T>()\n\t\tconst val = instantiate<T>()\n\t\tthis.set(val)\n\t\treturn val\t\n\t}\n\thas<T extends ObjectBase>(): bool{ return this.worldMap.has(idof<T>()) }\n\tset<T extends ObjectBase>(obj: T): World{ this.worldMap.set(idof<T>(), obj); return this }\n\n\tcreateEntity(): Entity{\n\t\tconst eid = this.eidIncr++\n\t\tconst entity = new Entity(this, eid)\n\t\tthis.entityMap.set(eid, entity)\n\t\tthis.entity = entity\n\t\treturn entity\n\t}\n\t\n\tcreateQuery<T extends Component>(): TypedQuery<T>{\n\t\tconst query = new TypedQuery<T>()\n\t\tthis.queryManager.addQuery(query)\n\t\treturn query\n\t}\n\taddQuery(query: Query): World{\n\t\tthis.queryManager.addQuery(query)\n\t\treturn this\t\n\t}\n\t\n\taddSystem<T extends System>(): World{\n\t\tif (this.has<T>())\n\t\t\treturn this\n\t\tthis.bind()\n\t\tconst system = instantiate<T>()\n\t\treturn this.attachSystem(system)\n\t}\n\t\n\tgetOrAddSystem<T extends System>(): T{\n\t\tif (this.has<T>())\n\t\t\treturn this.get<T>()\n\t\tthis.bind()\n\t\tconst system = instantiate<T>()\n\t\tthis.attachSystem(system)\n\t\treturn system\n\t}\n\t\n\n\tattachSystem<T extends System>(system: T): World{\n\t\tif (this.has<T>()){\n\t\t\t// throw new Error('system already exists!')\n\t\t\treturn this\n\t\t}\n\t\tif (system.world !== this)\n\t\t\tthrow new Error('systems was created with a different world, please call world.bind() first')\n\n\t\tif (system instanceof ListenerSystem)\n\t\t\tthis.listenerSystemManager.addListenerSystem(system as ListenerSystem)\n\t\tthis.systems.push(system)\n\t\tthis.worldMap.set(idof<T>(), system)\n\t\tSystemPriority.sortSystems(this.systems)\n\t\treturn this\n\t}\n\n\tonAddComponent(entity: Entity, cid: CID, component: Component): World{\n\t\tthis.queryManager.onAddComponent(entity, cid)\n\t\tthis.listenerSystemManager.onAddEntity(entity, cid)\n\t\treturn this\n\t}\n\tonRemoveComponent(entity: Entity, cid: CID, component: Component): World{\n\t\tthis.queryManager.onRemoveComponent(entity, cid)\n\t\tthis.listenerSystemManager.onRemoveEntity(entity, cid)\n\t\treturn this\n\t}\n\tonDisposeEntity(entity: Entity): World{\n\t\tthis.entityMap.delete(entity.id)\n\t\treturn this\n\t}\n\tstart(): World{\n\t\tthis.isRunning = true\n\t\tfor (let i = 0; i < this.systems.length; i++){\n\t\t\tthis.systems[i].start()\n\t\t}\n\t\treturn this\n\t}\n\tupdate(): World{\n\t\tfor (let i = 0; i < this.systems.length; i++){\n\t\t\tthis.systems[i].update()\n\t\t}\n\t\treturn this\n\t}\n}","import { CID, Component } from './Component'\nimport { Entity } from './Entity'\nimport { Query } from './Query'\n\n\n\n\n\nexport class QueryManager{\n\n\n\tqueryMap: Map<CID, Query[]> = new Map()\n\tcurrentSystem: u32 = -1\n\n\taddQuery(query: Query): QueryManager{\n\t\tfor (let i = 0; i < query.componentIds.length; i++){\n\t\t\tconst cid = query.componentIds[i]\n\t\t\tif (!this.queryMap.has(cid))\n\t\t\t\tthis.queryMap.set(cid, [])\n\t\t\tconst queries = this.queryMap.get(cid)\n\t\t\tqueries.push(query)\n\t\t\t// SystemPriority.sortSystems(queries)\n\t\t}\n\t\treturn this\n\t}\n\n\tonAddComponent(entity: Entity, cid: CID): void{\n\t\tif (!this.queryMap.has(cid))\n\t\t\treturn\n\t\tconst queries = this.queryMap.get(cid)\n\t\tfor (let i = 0; i < queries.length; i++){\n\t\t\tconst queryCids = queries[i].componentIds\n\t\t\tlet pass = true\n\t\t\tfor (let j = 0; j < queryCids.length; j++){\n\t\t\t\tif (!entity.components.has(queryCids[j]))\n\t\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif (pass)\n\t\t\t\tqueries[i].addEntity(entity)\n\t\t}\n\t}\n\t\n\tonRemoveComponent(entity: Entity, cid: CID): void{\n\t\tif (!this.queryMap.has(cid))\n\t\t\treturn\n\t\tconst queries = this.queryMap.get(cid)\n\t\tfor (let i = 0; i < queries.length; i++){\n\t\t\tif (queries[i].entities.has(entity))\n\t\t\t\tqueries[i].removeEntity(entity)\n\t\t}\n\t}\n\n}","import { CID } from './Component'\nimport { Entity } from './Entity'\nimport { ListenerSystem } from './System'\nimport { SystemPriority } from './SystemPriority'\n\n\n\nexport class ListenerSystemManager{\n\n\tlistenerSystemMap: Map<CID, ListenerSystem[]> = new Map()\n\n\taddListenerSystem(system: ListenerSystem): void{\n\t\tfor (let i = 0; i < system.components.length; i++){\n\t\t\tconst cid = system.components[i]\n\t\t\tif (!this.listenerSystemMap.has(cid))\n\t\t\t\tthis.listenerSystemMap.set(cid, [])\n\t\t\tconst componentSystems = this.listenerSystemMap.get(cid)\n\t\t\tcomponentSystems.push(system)\n\t\t\tSystemPriority.sortSystems(componentSystems)\n\t\t}\n\t}\n\n\tonAddEntity(entity: Entity, cid: CID): void{\n\t\tif (!this.listenerSystemMap.has(cid))\n\t\t\treturn\n\t\tconst systems = this.listenerSystemMap.get(cid)\n\t\tfor (let i = 0; i < systems.length; i++){\n\t\t\tconst systemCids = systems[i].components\n\t\t\tlet pass = true\n\t\t\tfor (let j = 0; j < systemCids.length; j++){\n\t\t\t\tif (!entity.components.has(systemCids[j]))\n\t\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif (pass)\n\t\t\t\tsystems[i].addEntity(entity)\n\t\t}\n\t}\n\t\n\tonRemoveEntity(entity: Entity, cid: CID): void{\n\t\tif (!this.listenerSystemMap.has(cid))\n\t\t\treturn\n\t\tconst systems = this.listenerSystemMap.get(cid)\n\t\tfor (let i = 0; i < systems.length; i++){\n\t\t\tif (!systems[i].entities.has(entity))\n\t\t\t\tcontinue\n\t\t\tsystems[i].removeEntity(entity)\n\t\t}\n\t}\n\n}","import { CID, Component } from './Component'\nimport { World } from './World'\n\nexport type EID = u32\n\nexport class Entity{\n\tworld: World\n\tid: EID\n\tcomponents: Map<CID, Component> = new Map()\n\tconstructor(world: World, id: u32){\n\t\tthis.world = world\n\t\tthis.id = id\n\t\tthis.bind()\n\t}\n\tbind(): Entity{\n\t\tthis.world.entity = this\n\t\treturn this\n\t}\n\thas<T extends Component>(): bool{\n\t\treturn this.components.has(idof<T>())\n\t}\n\tadd<T extends Component>(): Entity{\n\t\treturn this.attach(instantiate<T>())\n\t}\n\tattach<T extends Component>(component: T): Entity{\n\t\tif (component.entity !== this)\n\t\t\tthrow new Error('component was instantiated with a different entity, please call entity.bind() first')\n\t\tconst cid = idof<T>()\n\t\tthis.components.set(cid, component)\n\t\tthis.world.onAddComponent(this, cid, component)\n\t\treturn this\n\t}\n\tremove<T extends Component = Component>(cid: u32 = idof<T>()): Entity{\n\t\tthis.world.onRemoveComponent(this, cid, this.components.get(cid))\n\t\tthis.components.delete(cid)\n\t\treturn this\n\t}\n\tget<T extends Component>(): T{\n\t\treturn this.components.get(idof<T>()) as T\n\t}\n\tgetOrAdd<T extends Component>(): T{\n\t\tconst cid = idof<T>()\n\t\tif (!this.components.has(cid))\n\t\t\tthis.add<T>()\n\t\treturn this.components.get(cid) as T\n\t}\n\tdispose(): void{\n\t\tconst componentIds = this.components.keys()\n\t\tconst components = this.components.values()\n\t\tfor (let i = 0; i < components.length; i++){\n\t\t\tthis.remove(componentIds[i])\n\t\t}\n\t\tthis.world.onDisposeEntity(this)\n\t}\n}","import { Entity } from './Entity'\nimport { ObjectBase } from './Object'\nimport { World } from './World'\n\n\nexport type CID = u32\n\n\nexport class Component extends ObjectBase{\n\tentity: Entity\n\tworld: World\n\tconstructor(){\n\t\tsuper()\n\t\tthis.entity = World.main.entity\n\t\tthis.world = this.entity.world\n\t}\n}\n","import { mat4 } from '../../glMatrix'\nimport { Matrix, Vector3, Quaternion } from '../../math'\nimport { Component } from '../../base'\n\nexport class Transform extends Component{\n\tmatrix: Matrix\n\tworldMatrix: Matrix\n\tinverseWorldMatrix: Matrix\n\tposition: Vector3\n\tscale: Vector3\n\trotation: Quaternion\n\n\tchildren: Set<Transform>\n\tparent: Transform|null\n\n\tmatrixAutoUpdate: bool = true\n\n\tstatic fromMatrix(matrix: Matrix, parent: Transform | null = null): Transform{\n\t\tconst transform = new Transform(parent)\n\t\ttransform.matrix = matrix\n\t\treturn transform\n\t}\n\n\tconstructor(parent: Transform | null = null){\n\t\tsuper()\n\t\tthis.matrix = new Matrix()\n\t\tthis.worldMatrix = new Matrix()\n\t\tthis.inverseWorldMatrix = new Matrix()\n\t\tthis.position = new Vector3()\n\t\t//fromMatrix has weird behaviour, ie matrix updated before updateMatrix()\n\t\t// this.position = Vector3.fromMatrix(this.matrix)\n\t\tthis.scale = new Vector3(1, 1, 1)\n\t\tthis.rotation = new Quaternion()\n\n\t\tthis.children = new Set()\n\t\tif (parent)\n\t\t\tthis.setParent(parent)\n\t}\n\tsetParent(parent: Transform | null, keepWorldPosition: bool = false): Transform{\n\t\tconst thisParent = this.parent\n\t\tthisParent && thisParent.children.delete(this)\n\t\tparent && parent.children.add(this)\n\t\tthis.parent = parent\n\t\tif (keepWorldPosition)\n\t\t\tthrow new Error('keep world position not yet implemented')\n\t\treturn this\n\t}\n\tupdateMatrix(): Transform {\n\t\tthis.matrix.compose(this.position, this.rotation, this.scale)\n\t\t// this.matrixWorldNeedsUpdate = true\n\t\treturn this\n\t}\n\tlookAt(target: Vector3, up: Vector3 = Vector3._up): Transform{\n\t\t//should be quaternion lookat\n\t\tmat4.fromTranslation(Matrix._tmp0.m, this.position.m)\n\t\tMatrix._tmp0.lookAt(target, up)\n\t\tmat4.getRotation(this.rotation.m, Matrix._tmp0.m)\n\t\treturn this\n\t}\n\tlookAway(target: Vector3, up: Vector3 = Vector3._up): Transform{\n\t\t//should be quaternion lookat\n\t\tmat4.fromTranslation(Matrix._tmp0.m, this.position.m)\n\t\tMatrix._tmp0.lookAway(target, up)\n\t\tmat4.getRotation(this.rotation.m, Matrix._tmp0.m)\n\t\treturn this\n\t}\n\ttranslateX(translation: f32): Transform{\n\t\tthis.position.add(this.rotation.right().scale(translation))\n\t\treturn this\n\t}\n\ttranslateY(translation: f32): Transform{\n\t\tthis.position.add(this.rotation.up().scale(translation))\n\t\treturn this\n\t}\n\ttranslateZ(translation: f32): Transform{\n\t\tthis.position.add(this.rotation.forward().scale(translation))\n\t\treturn this\n\t}\n\n\treset(): Transform{\n\t\tthis.position.set(0, 0, 0)\n\t\tthis.scale.set(1, 1, 1)\n\t\tthis.rotation.set(0, 0, 0, 1)\n\t\treturn this\n\t}\n\n\tupdateWorldMatrix(updateParents: boolean = false, updateChildren: boolean = false): Transform {\n\t\tconst parent = this.parent\n\t\tif (parent && updateParents)\n\t\t\tparent.updateWorldMatrix(true, false)\n\t\tif (this.matrixAutoUpdate) this.updateMatrix()\n\t\tif (parent)\n\t\t\t// Matrix.multiply(this.worldMatrix, this.matrix, parent.worldMatrix)\n\t\t\tMatrix.multiply(this.worldMatrix, parent.worldMatrix, this.matrix)\n\t\t\t// Matrix.multiply(parent.worldMatrix, this.matrix, this.worldMatrix)\n\t\telse\n\t\t\tthis.worldMatrix.copy(this.matrix)\n\t\tmat4.invert(this.inverseWorldMatrix.m, this.worldMatrix.m)\n\t\tif (updateChildren) {\n\t\t\tconst children = this.children.values()\n\t\t\t//@ts-ignore\n\t\t\tfor (let i = 0, l = children.length; i < l; i ++) {\n\t\t\t\tchildren[ i ].updateWorldMatrix(false, true)\n\t\t\t}\t\n\t\t}\n\t\treturn this\n\t}\n\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    var entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) != null;\n  }\n\n  add(key: T): this {\n    var hashCode = HASH<T>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    var entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<T>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.key;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { CID, Component } from './Component'\nimport { EID, Entity } from './Entity'\n\nexport class Query{\n\t\n\tcomponentIds: CID[]\n\t\n\tentities: Set<Entity> = new Set<Entity>()\n\tconstructor(componentIds: CID[]){\n\t\tthis.componentIds = componentIds\n\t}\n\n\taddEntity(entity: Entity): void{\n\t\tthis.entities.add(entity)\n\t}\n\t\n\tremoveEntity(entity: Entity): void{\n\t\tthis.entities.delete(entity)\n\t}\n}\n\n\nexport class TypedQuery<T1 extends Component> extends Query{\n\n\tcomponents: T1[] = []\n\n\tconstructor(){\n\t\tsuper([idof<T1>()])\n\t}\n\n\taddEntity(entity: Entity): void {\n\t\tsuper.addEntity(entity)\n\t\tthis.components.push(entity.get<T1>())\n\t}\n\tremoveEntity(entity: Entity): void {\n\t\tsuper.removeEntity(entity)\n\t\tthis.components.splice(this.components.indexOf(entity.get<T1>()), 1)\n\t}\n}","import { CID } from './Component'\nimport { Entity } from './Entity'\nimport { ObjectBase } from './Object'\nimport { SystemPriority, defaultSystemPriority } from './SystemPriority'\nimport { World } from './World'\n\nexport class System extends ObjectBase {\n\tpriority: SystemPriority\n\tworld: World\n\tconstructor(priority: SystemPriority = defaultSystemPriority){\n\t\tsuper()\n\t\tthis.world = World.main\n\t\tthis.priority = priority\n\t}\n\tstart(): void{}\n\tupdate(): void{}\n\tdispose(): void{}\n\t\n}\n\nexport class ListenerSystem extends System{\n\tentities: Set<Entity> = new Set()\t\n\tcomponents: CID[]\n\tconstructor(components: CID[], priority: SystemPriority = defaultSystemPriority){\n\t\tsuper(priority)\n\t\tthis.components = components\n\t}\n\t\n\taddEntity(entity: Entity): void{\n\t\tthis.entities.add(entity)\n\t\t//insert magical casting here\n\t\tthis.onAdd(entity)\n\t}\n\tremoveEntity(entity: Entity): void{\n\t\tthis.entities.delete(entity)\n\t\tthis.onRemove(entity)\n\t}\n\tupdate(): void{\n\t\tsuper.update()\n\t\tconst entities = this.entities.values()\n\t\t//@ts-ignore\n\t\tfor (let i = 0; i < entities.length; i++){\n\t\t\tthis.onUpdate(entities[i])\n\t\t}\n\t}\n\tonAdd(entity: Entity): void{}\n\tonUpdate(entity: Entity): void{}\n\tonRemove(entity: Entity): void{}\t\t\n\n}","import { Component } from '../../base'\nimport { Transform } from './Transform'\n\nexport class MouseKeyboardController extends Component{\n\tconstructor(){\n\t\tsuper()\n\t\tthis.entity.getOrAdd<Transform>()\n\t}\n\tmouseRotationScalar: f32 = 1\n\tkeyRotationScalar: f32 = 0.03\n\tkeyTranslationScalar: f32 = 0.1\t\n\twheelTranslationScalar: f32 = 0.01\n}","import { Matrix, TAU } from '../../math'\nimport { Ubo, UniformName, Uniform_f32 } from '../../rendering'\nimport { Viewport } from '../../utility'\nimport { Component } from '../../base'\nimport { Transform } from './Transform'\nimport { RenderSystem } from '../systems'\n\nexport class Camera extends Component{\n\n\tviewport: Viewport\n\tview: Matrix\n\tprojection: Matrix\n\tviewProjection: Matrix\n\tfillCanvas: bool = true\n\tprivate _fov: f32\n\tprivate _aspect: f32\n\tprivate _near: f32\n\tprivate _far: f32\n\tget fov(): f32{ return this._fov } set fov(val: f32){ this._fov = val; this._updatePerspective() }\n\tget aspect(): f32{ return this._aspect } set aspect(val: f32){ this._aspect = val; this._updatePerspective() }\n\tget nearClipPlane(): f32{ return this._near } set nearClipPlane(val: f32){ this._near = val; this._updatePerspective() }\n\tget farClipPlane(): f32{ return this._far } set farClipPlane(val: f32){ this._far = val; this._updatePerspective() }\n\t\n\tstatic fromProjectionMatrix(projectionMatrix: Matrix): Camera{\n\t\tconst camera = new Camera()\n\t\tcamera.projection = projectionMatrix\n\t\t//TODO calculate fov etc from matrix\n\t\treturn camera\n\t}\n\n\tconstructor(fov: f32 = TAU / 4, aspect: f32 = 16 / 9, near: f32 = 0.01, far: f32 = 1000){\n\t\tsuper()\n\t\tthis._fov = fov; this._aspect = aspect; this._near = near; this._far = far\n\t\tthis.view = new Matrix()\n\t\t//TODO components shouldnt depend on systems\n\t\tthis.viewport = new Viewport(0, 0, RenderSystem.canvasWidth, RenderSystem.canvasHeight)\n\t\tthis.projection = new Matrix()\n\t\tthis.viewProjection = new Matrix()\n\t\tthis.entity.getOrAdd<Transform>()\n\t\tthis._updatePerspective()\n\t}\n\n\tsetFillCanvas(fillCanvas: bool): Camera{\n\t\tthis.fillCanvas = fillCanvas\n\t\treturn this\n\t}\n\n\tsetViewport(x: u32, y: u32, width: u32, height: u32, aspect: f32 = <f32>width / <f32>height): Camera{\n\t\tthis.viewport.x = x\n\t\tthis.viewport.y = y\n\t\tthis.viewport.width = width\n\t\tthis.viewport.height = height\n\t\tthis.aspect = aspect\n\t\t//TODO update projection matrix etc\n\t\treturn this\n\t}\n\t\n\t_updatePerspective(): Camera{\n\t\tthis.projection.perspective(this._fov, this._aspect, this._near, this._far)\n\t\treturn this\n\t}\n\n\t//TODO put this in system\n\tupdate(): void{\n\t\tthis.view.invert(this.entity.get<Transform>().worldMatrix)\n\t\tMatrix.multiply(this.viewProjection, this.projection, this.view)\n\t}\n\n\n\tapplyUbo(): void{\n\t\t\n\t\t(Ubo.camera.uniformMap.get(UniformName.View) as Uniform_f32).value = this.view.m;\n\t\t(Ubo.camera.uniformMap.get(UniformName.Projection) as Uniform_f32).value = this.projection.m;\n\t\t(Ubo.camera.uniformMap.get(UniformName.ViewProjection) as Uniform_f32).value = this.viewProjection.m;\n\t\t(Ubo.camera.uniformMap.get(UniformName.CameraModel) as Uniform_f32).value = this.entity.get<Transform>().worldMatrix.m\n\t}\n}","\n\n\nexport class Viewport{\n\n\tx: u32\n\ty: u32\n\twidth: u32\n\theight: u32\n\n\tconstructor(x: u32, y: u32, width: u32, height: u32){\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.width = width\n\t\tthis.height = height\n\t}\n\n}","import { Color, Texture } from '../../math'\nimport { Culling, Ubo, UniformName } from '../constants'\nimport { Shader } from '../shader'\nimport { Uniform, Uniform_texture } from './Uniform'\nimport { UniformBufferObject } from './UniformBufferObject'\n\nexport class Material{\n\tuniformMap: Map<string, Uniform> = new Map()\n\tuniformArr: Uniform[] = []\n\tuniformBufferObjects: UniformBufferObject[] = []\n\ttransparent: bool = false\n\tculling: Culling = Culling.Back\n\n\tstatic new(shader: Shader): Material{ return new Material(shader) }\n\tshader: Shader\n\tconstructor(shader: Shader){\n\t\tthis.shader = shader\n\t}\n\taddUniform(uniform: Uniform): Material{\n\t\tthis.uniformMap.set(uniform.name, uniform)\n\t\tthis.uniformArr.push(uniform)\n\t\treturn this\n\t}\n\taddUniformBufferObject(ubo: UniformBufferObject): Material{\n\t\tthis.uniformBufferObjects.push(ubo)\n\t\treturn this\n\t}\n\tgetUniform<T extends Uniform>(name: string): T{\n\t\treturn this.uniformMap.get(name) as T\n\t}\n\tsetCulling(culling: Culling): Material{\n\t\tthis.culling = culling\n\t\treturn this\n\t}\n\tsetTransparent(transparent: bool = true): Material{\n\t\tthis.transparent = transparent\n\t\treturn this\n\t}\n}\n\nexport class SpatialMaterial extends Material{\n\n\tconstructor(shader: Shader){\n\t\tsuper(shader)\n\t\tthis\n\t\t\t.addUniformBufferObject(Ubo.camera)\n\t\t\t.addUniformBufferObject(Ubo.mesh)\n\t\t\t.addUniformBufferObject(Ubo.directionalLight)\n\t}\n}\n\n\nexport class StandardMaterial extends SpatialMaterial{\n\n\tcolor: Color\n\ttexture: Texture = Texture.white\n\tstatic new(shader: Shader): StandardMaterial{ return new StandardMaterial(shader) }\n\tconstructor(shader: Shader){\n\t\tsuper(shader)\n\t\tthis.color = new Color()\n\t\tthis.addUniform(Uniform.Float(UniformName.Time))\n\t\tthis.addUniform(Uniform.Vec4(UniformName.Color, this.color.m))\n\t\tthis.addUniform(Uniform.Texture(UniformName.Texture, this.texture))\n\t}\n\tsetColor(r: f32, g: f32, b: f32): StandardMaterial{\n\t\tthis.color.set(r, g, b)\n\t\treturn this\n\t}\n\t//untested\n\t// setTexture(texture: Texture): StandardMaterial{\n\t// \tthis.texture = texture;\n\t// \t(this.getUniform(UniformName.Texture) as Uniform_texture).value = texture\n\t// \treturn this\n\t// }\n\t// setBitmap(bitmap: Bitmap): StandardMaterial{\n\t// \tthis.addUniform(Uniform.Bitmap(UniformName.Texture, bitmap))\n\t// \treturn this\n\t// }\n}","import { World } from '../base'\nimport { Mesh, Transform } from '../core/components'\nimport { Vector3, TAU } from '../math'\nimport { StandardMaterial, unlitVertexColorShader, GridGeometry, TransformGeometry } from '../rendering'\n\nexport function createDebugGizmos(): void{\n\tconst material = new StandardMaterial(unlitVertexColorShader)\n\t// material.setTransparent()\n\tmaterial.color.set(.5, .5, .5, 1)\n\t// material.uniformMap.get(uniform_Color)\n\tconst grid = World.main.createEntity()\n\t\t.add<Transform>()\n\t\t.attach(new Mesh(new GridGeometry(21, 20), material))\n\tgrid.get<Transform>().rotation.fromEulerAngles(new Vector3(TAU / 4, 0, 0))\n\n\tconst trans = World.main.createEntity()\n\n\t// \t// .attach(new Mesh(CubeGeometry.default, unlitMaterial))\n\t\t// .attach(new Mesh(TransformGeometry.default, material))\n\t\t.attach(new Mesh(TransformGeometry.default, new StandardMaterial(unlitVertexColorShader)))\n}","import { Matrix, } from '../../math'\nimport { Geometry, Material, Shader, Ubo, UniformName, Uniform_f32 } from '../../rendering'\nimport { Component } from '../../base'\nimport { Transform } from './Transform'\n\nexport class Mesh extends Component{\n\tgeometry: Geometry\n\tmaterial: Material\n\tshader: Shader\n\tmodelView: Matrix = new Matrix()\n\tmodelViewProjection: Matrix = new Matrix()\n\tinverseTransposeModel: Matrix = new Matrix() //used for normals/lighting only\n\tstatic new(geometry: Geometry, material: Material): Mesh{\n\t\treturn new Mesh(geometry, material)\n\t}\n\t\n\tconstructor(geometry: Geometry, material: Material){\n\t\tsuper()\n\t\tthis.entity.getOrAdd<Transform>()\n\t\tthis.geometry = geometry\n\t\tthis.material = material\n\t\tthis.shader = this.material.shader\n\t}\n\n\n\tapplyUbo(): void{\n\t\tconst transform = this.entity.get<Transform>();\n\t\t(Ubo.mesh.uniformMap.get(UniformName.Model) as Uniform_f32).value = transform.worldMatrix.m;\n\t\t(Ubo.mesh.uniformMap.get(UniformName.ModelView) as Uniform_f32).value = this.modelView.m;\n\t\t(Ubo.mesh.uniformMap.get(UniformName.ModelViewProjection) as Uniform_f32).value = this.modelViewProjection.m;\n\t\t(Ubo.mesh.uniformMap.get(UniformName.InverseModel) as Uniform_f32).value = transform.inverseWorldMatrix.m;\n\t\t(Ubo.mesh.uniformMap.get(UniformName.InverseTransposeModel) as Uniform_f32).value = this.inverseTransposeModel.m\n\t}\n}","import { gl } from '../../WebGL2'\nimport { AttributeName } from '../constants'\nimport { Attribute_u8 } from './Attribute'\nimport { PositionGeometry } from './Geometry'\n\nexport class GridGeometry extends PositionGeometry{\n\n\n\tconstructor(divisions: u32 = 10, size: f32 = 10){\n\t\tif (divisions <= 1)\n\t\t\tdivisions = 2\n\t\tconst hSize = size / 2\n\n\n\t\tconst numPositions = divisions * 4\n\t\tconst positions = new Float32Array(numPositions * 3)\n\t\t//set row positions\n\t\tconst deltaPos = size / (<f32>divisions - 1)\n\t\tfor (let i: u32 = 0; i < divisions; i++){\n\t\t\tconst i_f = <f32>i\n\t\t\t//row - bottom\n\t\t\tconst vi = i * 12\n\t\t\tpositions[vi + 0] = -hSize + i_f * deltaPos\n\t\t\tpositions[vi + 1] = -hSize\n\t\t\tpositions[vi + 2] = 0\n\t\t\t//row - top\n\t\t\tpositions[vi + 3] = -hSize + i_f * deltaPos\n\t\t\tpositions[vi + 4] = +hSize\n\t\t\tpositions[vi + 5] = 0\n\t\t\t//column - left\n\t\t\tpositions[vi + 6] = -hSize \n\t\t\tpositions[vi + 7] = -hSize + i_f * deltaPos\n\t\t\tpositions[vi + 8] = 0\n\t\t\t//column - right\n\t\t\tpositions[vi + 9] = +hSize \n\t\t\tpositions[vi + 10] = -hSize + i_f * deltaPos\n\t\t\tpositions[vi + 11] = 0\n\t\t}\n\t\tsuper(positions)\n\t\tconst colors = new Uint8Array(numPositions * 4)\n\t\tfor (let i = 0; i < colors.length; i++){\n\t\t\tcolors[i] = 127\n\t\t}\n\n\n\t\tthis.addAttribute(new Attribute_u8(AttributeName.Color, 4, colors))\n\t\tthis.primitiveType = gl.Primitive.LINES\n\t}\n}","import { World } from '../base'\nimport { TimeSystem, TransformSystem, InputSystem, RotatorSystem, MouseKeyboardControllerSystem } from '../core'\nimport { litShader } from '../rendering'\nimport { WebGLRenderSystem } from '../WebGL2'\nimport { createDefaultCamera } from './camera'\nimport { createDebugGizmos } from './debug'\nimport { rotatingCube } from './demos'\nimport { createDefaultLights } from './light'\n\nexport function main(): void{}\nexport function update(): void{\n\tWorld.main.update()\n}\n\n\nclass DefaultWorldOptions{\n\tcamera: bool\n\tcameraKeyboardController: bool\n\tcameraMouseController: bool\t\n\tlights: bool\n\tgizmos: bool\n\thelloCube: bool\n}\n\nexport function defaultWorld(options: DefaultWorldOptions): World{\n\tWorld.main\n\t\t.addSystem<TimeSystem>()\n\t\t.addSystem<TransformSystem>()\n\t\t.addSystem<InputSystem>()\n\t\t.addSystem<RotatorSystem>()\n\t\t.addSystem<WebGLRenderSystem>()\n\t\t.addSystem<MouseKeyboardControllerSystem>()\n\t\t\n\t// // renderSystem.clear()\n\tif (options.lights)\n\t\tcreateDefaultLights()\n\tif (options.camera)\n\t\tcreateDefaultCamera(options.cameraKeyboardController, options.cameraMouseController)\n\tif (options.gizmos)\n\t\tcreateDebugGizmos()\n\tif (options.helloCube)\n\t\trotatingCube(litShader)\n\treturn World.main\n}","import { Time } from '../components'\nimport { host } from '../../imports'\nimport { System, timeSystemPriority } from '../../base'\n\nexport class TimeSystem extends System{\n\ttime: Time\n\tconstructor(){\n\t\tsuper(timeSystemPriority)\n\t\tthis.time = new Time()\n\t\tthis.world.set<Time>(this.time)\n\t}\n\n\tstart(): void {\n\t\tconst t = this.time\n\t\t//maintain 64 bit until after millis2secs\n\t\tt.now = host.elapsed() * 0.001\n\t\tt.start = t.now\n\t\tt.last = t.now\n\t}\n\t\n\tupdate(): void {\n\t\tconst t = this.time\n\t\tt.last = t.now\t\t\t\n\t\tt.now = host.elapsed() * 0.001\n\t\tt.elapsed = t.now - t.start\n\t\tt.delta = t.now - t.last\n\t\tt.frame++\n\t}\n}\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { PolarCoords } from './PolarCoords'\nimport { Vector3 } from './Vector3'\n\n\n\nexport class Vector2{\n\t\n\tstatic fromPolar(polar: PolarCoords, target: Vector2 = new Vector2()): Vector2{\n\t\ttarget.x = Mathf.cos(polar.angle) * polar.radius\n\t\ttarget.y = Mathf.sin(polar.angle) * polar.radius\n\t\treturn target\n\t}\n\tget x(): f32{ return this.m[0] } set x(val: f32){ this.m[0] = val }\n\tget y(): f32{ return this.m[1] } set y(val: f32){ this.m[1] = val }\n\n\tm: Float32Array\n\tconstructor(x: f32 = 0, y: f32 = 0){\n\t\tthis.m = new Float32Array(2)\n\t\tthis.m[0] = x\n\t\tthis.m[1] = y\n\t}\n\tclone(ref: Vector2 = new Vector2()): Vector2{\n\t\tref.x = this.x; ref.y = this.y; return ref }\n\tset(x: f32, y: f32): Vector2 { \n\t\tthis.x = x; this.y = y; return this }\n\n\tlengthSquared(): f32 {\t\n\t\treturn this.x * this.x + this.y * this.y }\n\tlength(): f32{\n\t\treturn Mathf.sqrt(this.x * this.x + this.y * this.y)\n\t}\n\ttoPolar (): PolarCoords {\n\t\treturn new PolarCoords(\n\t\t\tMathf.atan2(this.y, this.x),\n\t\t\tthis.length())\n\t}\n\ttoVector3(target: Vector3 = new Vector3()): Vector3{\n\t\ttarget.x = this.x\n\t\ttarget.y = this.y\n\t\ttarget.z = 0\n\t\treturn target\n\t}\n\ttoVector3XZ(target: Vector3 = new Vector3()): Vector3{\n\t\ttarget.x = this.x\n\t\ttarget.y = 0\n\t\ttarget.z = this.y\n\t\treturn target\n\t}\n\t// @operator('+')\n\taddRef (b: Vector2, o: Vector2 = new Vector2()): Vector2\n\t{ o.x = this.x + b.x; o.y = this.y + b.y; return o }\n\t// @operator('-')\n\tsubRef (b: Vector2, o: Vector2 = new Vector2()): Vector2 \n\t{ o.x = this.x - b.x; o.y = this.y - b.y; return o }\n\t// @operator('*')\n\tmultRef (b: Vector2, o: Vector2 = new Vector2()): Vector2 \n\t{ o.x = this.x * b.x; o.y = this.y * b.y; return o }\n\t// @operator('/')\n\tdivRef (b: Vector2, o: Vector2 = new Vector2()): Vector2 \n\t{ o.x = this.x / b.x; o.y = this.y / b.y; return o }\n\t//TODO make all sets static\n\tstatic add (a: Vector2, b: Vector2, ref: Vector2 = new Vector2()): Vector2\n\t{ ref.x = a.x + b.x; ref.y = a.y + b.y; return ref }\n\tstatic sub (a: Vector2, b: Vector2, ref: Vector2 = new Vector2()): Vector2 \n\t{ ref.x = a.x - b.x; ref.y = a.y - b.y; return ref }\n\tstatic mult (a: Vector2, b: Vector2, ref: Vector2 = new Vector2()): Vector2 \n\t{ ref.x = a.x * b.x; ref.y = a.y * b.y; return ref }\n\tstatic div (a: Vector2, b: Vector2, ref: Vector2 = new Vector2()): Vector2 \n\t{ ref.x = a.x / b.x; ref.y = a.y / b.y; return ref }\n\tadd (b: Vector2): Vector2\n\t{ this.x += b.x; this.y += b.y; return this }\n\tsub (b: Vector2): Vector2 \n\t{ this.x -= b.x; this.y -= b.y; return this }\n\tmult (b: Vector2): Vector2 \n\t{ this.x *= b.x; this.y *= b.y; return this }\n\tdiv (b: Vector2): Vector2 \n\t{ this.x /= b.x; this.y /= b.y; return this }\n\taddValue (b: f32): Vector2\n\t{ this.x += b;\tthis.y += b; return this }\n\tsubValue (b: f32): Vector2\n\t{ this.x -= b;\tthis.y -= b; return this }\n\tscale (b: f32): Vector2\n\t{ this.x *= b;\tthis.y *= b; return this }\n\tscaleDiv (b: f32): Vector2\n\t{ this.x /= b; this.y /= b; return this }\n\t\n}","import { Rotator, Time, Transform } from '../components'\nimport { Vector2, PolarCoords, Vector3 } from '../../math'\nimport { ListenerSystem, Entity } from '../../base'\nimport { host } from '../../imports'\n\nexport class RotatorSystem extends ListenerSystem{\n\tconstructor(){\n\t\tsuper([idof<Rotator>()])\n\t}\n\n\tonAdd(entity: Entity): void {\n\t\tentity.get<Rotator>().startTime = this.world.get<Time>().elapsed\n\t}\n\n\tonUpdate(entity: Entity): void {\t\t\n\t\tconst transform = entity.get<Transform>()\n\t\tconst rotator = entity.get<Rotator>()\n\t\tconst time = this.world.get<Time>()\n\t\tconst timeOffset = rotator.startTime + time.elapsed\n\t\tVector2\n\t\t\t.fromPolar(new PolarCoords(timeOffset * 0.4, 1))\n\t\t\t.toVector3(transform.position)\n\t\ttransform.position.add(rotator.offset)\n\t\t// transform.position.x += 0.001\n\t\t// transform.rotation.lookAt(target)\n\t\t// transform.rotation.angleAxis(timeOffset, Vector3._up)\n\t\ttransform.rotation.fromEulerAngles(new Vector3(0.3 * timeOffset, 0.5 * timeOffset, 0))\n\t}\n}\n","import { UniformBufferObjectSystem } from '../../core/systems/UniformBufferObjectSystem'\nimport { host } from '../../imports'\nimport { UniformBufferObject, UniformType, Uniform_f32 } from '../../rendering'\nimport { WebGLShader, WebGLUniformBufferObject } from '../components'\nimport { gl } from '../imports'\nimport { bufferUsage } from './utility'\n\nexport class WebGLUniformBufferObjectSystem extends UniformBufferObjectSystem{\n\n\tuboMap: Map<UniformBufferObject, WebGLUniformBufferObject> = new Map()\n\tuboIndexIncr: u32 = 0\n\t\n\tassignToShader(ubo: UniformBufferObject, shader: WebGLShader): WebGLUniformBufferObject | null{\n\t\tconst program = host.get(shader.programId)\n\t\tconst shaderIndex = gl.getUniformBlockIndex(program, ubo.name)\t\t\n\t\tif (shaderIndex === -1 || shaderIndex === 4294967295)//where does this number come from?\n\t\t\treturn null\n\t\tconst glUbo = this.getOrCreate(ubo, shader)\n\t\tgl.uniformBlockBinding(program, shaderIndex, glUbo.index)\n\t\treturn glUbo\n\t}\n\t\t\n\tgetOrCreate(ubo: UniformBufferObject, shader: WebGLShader): WebGLUniformBufferObject{\n\t\tif (this.uboMap.has(ubo))\n\t\t\treturn this.uboMap.get(ubo)\n\t\tconst glUbo = this.create(ubo, shader)\n\t\tthis.uboMap.set(ubo, glUbo)\n\t\treturn glUbo\n\t}\n\n\tcreate(ubo: UniformBufferObject, shader: WebGLShader): WebGLUniformBufferObject{\n\t\tconst program = host.get(shader.programId)\n\t\tconst uniformNames = new Array<string>(ubo.uniformArr.length)\n\t\tfor (let i = 0; i < ubo.uniformArr.length; i++){\n\t\t\tuniformNames[i] = ubo.uniformArr[i].name\n\t\t}\n\t\n\t\tconst uboIndex = this.uboIndexIncr++\t\n\t\n\t\tconst blockIndex = gl.getUniformBlockIndex(program, ubo.name)\n\t\tconst blockSize = gl.getActiveUniformBlockParameter__1(program, blockIndex, gl.Uniform.UNIFORM_BLOCK_DATA_SIZE)\n\t\tconst uboBuffer = gl.createBuffer()\n\t\tgl.bindBuffer(gl.BufferType.UNIFORM_BUFFER, uboBuffer)\n\t\tgl.bufferData__1(gl.BufferType.UNIFORM_BUFFER, blockSize, bufferUsage(ubo.dynamic))\n\t\tgl.bindBuffer(gl.BufferType.UNIFORM_BUFFER, null)\t\t\n\t\t\n\t\tgl.bindBufferBase(gl.BufferType.UNIFORM_BUFFER, uboIndex, uboBuffer)\n\t\tconst uniformIndices = gl.getUniformIndices(program, uniformNames)\n\t\tconst uniformOffsets = gl.getActiveUniforms__1(program, uniformIndices, gl.Uniform.UNIFORM_OFFSET)\t\t\n\t\t\n\t\t// if (uniformOffsets === null)//we should never reach here, we check its legit on line 16\n\t\t// \treturn null\n\t\tconst instance: WebGLUniformBufferObject = {\t\t\t\n\t\t\tname: ubo.name,\n\t\t\tindex: uboIndex,\n\t\t\tbufferId: host.set(uboBuffer),\n\t\t\tuniforms: ubo.uniformArr,\n\t\t\tuniformOffsets\n\t\t}\n\t\treturn instance\n\t}\n\t\n\tapply(ubo: UniformBufferObject): void{\n\t\tif (!this.uboMap.has(ubo))\n\t\t\treturn //no materials are using this ubo\n\t\t\t// throw new Error(`UBO not found - ${ubo.name}`)\n\t\tconst glUbo = this.uboMap.get(ubo)\n\t\tconst buffer = host.get(glUbo.bufferId)\t\t\n\t\tgl.bindBuffer(gl.BufferType.UNIFORM_BUFFER, buffer)\n\t\t\n\t\tfor (let i = 0; i < glUbo.uniforms.length; i++){\n\t\t\tswitch (glUbo.uniforms[i].type){\n\t\t\tdefault:\n\t\t\tcase UniformType.FLOAT:\n\t\t\tcase UniformType.FLOAT_VEC2:\n\t\t\tcase UniformType.FLOAT_VEC3:\n\t\t\tcase UniformType.FLOAT_VEC4:\n\t\t\tcase UniformType.FLOAT_MAT4:{\n\t\t\t\tconst arr = (glUbo.uniforms[i] as Uniform_f32).value\n\t\t\t\tconst offset = glUbo.uniformOffsets[i]\n\t\t\t\tgl.bufferSubData__2(gl.BufferType.UNIFORM_BUFFER, offset, arr, 0)\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgl.bindBuffer(gl.BufferType.UNIFORM_BUFFER, null)\n\t}\n\t\t\n}\n\t\n\t\n\t\n\t","import { RenderSystem } from '../../core/systems/RenderSystem'\nimport { Mesh } from '../../core/components'\nimport { Color } from '../../math'\nimport { Viewport } from '../../utility'\nimport { gl } from '../imports'\nimport { WebGLMeshSystem } from './WebGLMeshSystem'\nimport { WebGLUniformBufferObjectSystem } from './WebGLUniformBufferObjectSystem'\n\nexport class WebGLRenderSystem extends RenderSystem{\n\n\tmeshSystem: WebGLMeshSystem\n\t// uboSystem: WebGLUniformBufferObjectSystem\n\n\tconstructor(){\n\t\tconst uboSystem = new WebGLUniformBufferObjectSystem()\n\t\tsuper(uboSystem)\n\t\tthis.meshSystem = new WebGLMeshSystem(uboSystem)\n\t\tthis.clearColor(Color.clear)\n\t}\n\tclearColor(color: Color): void{\n\t\tgl.clearColor(color.r, color.g, color.b, color.a)\n\t}\n\tclear(): void{\n\t\tgl.clear(gl.ClearingBuffer.COLOR_BUFFER_BIT | gl.ClearingBuffer.DEPTH_BUFFER_BIT)\n\t}\n\thandleViewport(viewport: Viewport): void {\n\t\tgl.viewport(viewport.x, viewport.y, viewport.width, viewport.height)\n\t}\n\tupdate(): void{\n\t\tthis.clear()\n\t\tsuper.update()\n\t}\n\thandlePrepareOpaque(): void{\n\t\tgl.enable(gl.Toggle.DEPTH_TEST)\n\t\tgl.depthFunc(gl.Test.LEQUAL)\n\t\tgl.disable(gl.Toggle.BLEND)\n\t}\n\thandlePrepareTransparent(): void{\n\t\tgl.enable(gl.Toggle.BLEND)\n\t\tgl.blendFunc(gl.Blend.SRC_ALPHA, gl.Blend.ONE_MINUS_SRC_ALPHA)\n\t\tgl.disable(gl.Toggle.DEPTH_TEST)\t\t\n\t}\n\n\thandleCreateMesh(mesh: Mesh): void {\n\t\tthis.meshSystem.create(mesh)\n\t}\n\thandleRenderMesh(mesh: Mesh): void{\n\t\tthis.meshSystem.render(mesh)\n\t}\n}","import { host } from '../../imports'\nimport { Culling, Material, Uniform, UniformType, Uniform_bitmap, Uniform_f32, Uniform_texture } from '../../rendering'\nimport { WebGLMaterial, WebGLShader, WebGLTextureUniform, WebGLUniform, WebGLUniformBufferObject, WebGLUniform_float, WebGLUniform_mat4, WebGLUniform_vec2, WebGLUniform_vec3, WebGLUniform_vec4 } from '../components'\nimport { gl } from '../imports'\nimport { WebGLUniformBufferObjectSystem } from './WebGLUniformBufferObjectSystem'\n\n\nexport class WebGLMaterialSystem{\n\t\n\tmaterialMap: Map<Material, WebGLMaterial> = new Map()\n\tuboSystem: WebGLUniformBufferObjectSystem\n\t// imageGlue: LoaderGlue\n\ttextureIndex: u32 = 0\n\n\tconstructor(uboSystem: WebGLUniformBufferObjectSystem){\n\t\tthis.uboSystem = uboSystem\n\t\t// this.imageGlue = imageGlue\n\t}\n\n\tgetOrCreate(material: Material, shader: WebGLShader): WebGLMaterial{\n\t\tif (this.materialMap.has(material))\n\t\t\treturn this.materialMap.get(material)\n\n\t\tconst ubos: WebGLUniformBufferObject[] = []\n\t\tfor (let i = 0; i < material.uniformBufferObjects.length; i++){\n\t\t\tconst ubo = this.uboSystem.assignToShader(material.uniformBufferObjects[i], shader)\n\t\t\tif (ubo)\n\t\t\t\tubos.push(ubo)\n\t\t}\n\t\tconst uniforms: WebGLUniform[] = []\n\t\tfor (let i = 0; i < material.uniformArr.length; i++){\n\t\t\tconst uniform = this.createUniform(material.uniformArr[i], shader)\n\t\t\tif (uniform)\n\t\t\t\tuniforms.push(uniform)\n\t\t}\n\n\t\tconst glMaterial: WebGLMaterial = {\n\t\t\ttransparent: !!material.transparent,\n\t\t\tculling: material.culling,\n\t\t\tuniforms,\n\t\t\tubos\n\t\t}\n\n\t\tthis.materialMap.set(material, glMaterial)\n\t\treturn glMaterial\n\t}\n\n\tcreateUniform(uniform: Uniform, shader: WebGLShader): WebGLUniform | null {\n\t\tconst program = host.get(shader.programId)\n\t\tconst location = gl.getUniformLocation(program, uniform.name)\n\t\t//TODO handle null\n\t\t// if (location == -1)\n\t\t// \treturn null\n\t\t//TODO share textures\n\t\tif (uniform.type === UniformType.TEXTURE || uniform.type === UniformType.BITMAP){\n\t\t\tconst texIndex = this.textureIndex++\n\t\t\tif (texIndex >= 32)\n\t\t\t\tthrow new Error('Maximum texture count reached - 32')\n\t\t\tconst glTexture = gl.createTexture()\n\t\t\tgl.activeTexture(gl.Texture.TEXTURE0 + texIndex)\n\t\t\tgl.bindTexture(gl.Texture.TEXTURE_2D, glTexture)\n\t\t\tif (uniform.type === UniformType.TEXTURE)\n\t\t\t\tthis.setTextureUniform(uniform)\n\t\t\telse\n\t\t\t\tthis.setBitmapUniform(uniform)\n\t\t\t//options\n\t\t\t//https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n\t\t\tgl.generateMipmap(gl.Texture.TEXTURE_2D)\n\t\t\t//REPEAT, MIRRORED_REPEAT, CLAMP_TO_EDGE\n\t\t\tgl.texParameteri(gl.Texture.TEXTURE_2D, gl.Texture.TEXTURE_WRAP_S, gl.Texture.REPEAT)\n\t\t\tgl.texParameteri(gl.Texture.TEXTURE_2D, gl.Texture.TEXTURE_WRAP_T, gl.Texture.REPEAT)\n\t\t\t//only use without mip maps, linear or nearest\n\t\t\tgl.texParameteri(gl.Texture.TEXTURE_2D, gl.Texture.TEXTURE_MAG_FILTER, gl.Texture.LINEAR)\n\t\t\t//only use with mip maps\n\t\t\tgl.texParameteri(gl.Texture.TEXTURE_2D, gl.Texture.TEXTURE_MIN_FILTER, gl.Texture.LINEAR_MIPMAP_LINEAR)\n\t\t\t//end options\n\t\t\treturn new WebGLTextureUniform(location, texIndex)\n\t\t} else {\n\t\t\t//TODO \n\t\t\tswitch (uniform.type){\n\t\t\tcase UniformType.FLOAT:\n\t\t\t\treturn new WebGLUniform_float(location, (uniform as Uniform_f32).value)\n\t\t\tcase UniformType.FLOAT_VEC2:\n\t\t\t\treturn new WebGLUniform_vec2(location, (uniform as Uniform_f32).value)\n\t\t\tcase UniformType.FLOAT_VEC3:\n\t\t\t\treturn new WebGLUniform_vec3(location, (uniform as Uniform_f32).value)\n\t\t\tcase UniformType.FLOAT_VEC4:\n\t\t\t\treturn new WebGLUniform_vec4(location, (uniform as Uniform_f32).value)\n\t\t\tcase UniformType.FLOAT_MAT4:\n\t\t\t\treturn new WebGLUniform_mat4(location, (uniform as Uniform_f32).value)\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unimplemented uniform type: ${uniform.type}`)\n\t\t\t}\n\t\t}\n\t}\n\n\tsetBitmapUniform(_uniform: Uniform): void{\n\t\tconst uniform = _uniform as Uniform_bitmap\n\t\t// const bitmap = uniform.value\n\t\t// const image = this.imageGlue.bitmaps.get(bitmap.ptr)\n\t\t// gl.texImage2D__2(gl.Texture.TEXTURE_2D, 0, gl.PixelFormat.RGBA, bitmap.width, bitmap.height, \n\t\t// \t0, gl.PixelFormat.RGBA, image)\n\t}\n\tsetTextureUniform(_uniform: Uniform): void{\n\t\tconst uniform = _uniform as Uniform_texture\n\t\tconst tex = uniform.value\n\t\tgl.texImage2D__6(gl.Texture.TEXTURE_2D, 0, gl.PixelFormat.RGBA, tex.width, tex.height, \n\t\t\t0, gl.PixelFormat.RGBA, gl.PixelType.UNSIGNED_BYTE, tex.pixels)\n\t}\n\n\tbeforeRender(material: WebGLMaterial): void{\n\t\tif (material.culling === Culling.Off){\n\t\t\tgl.disable(gl.Culling.CULL_FACE)\n\t\t} else if (material.culling === Culling.Back){\n\t\t\tgl.enable(gl.Culling.CULL_FACE)\t\t\t\n\t\t\tgl.cullFace(gl.Culling.BACK)\n\t\t} else if (material.culling === Culling.Front){\n\t\t\tgl.cullFace(gl.Culling.FRONT)\n\t\t} else if (material.culling === Culling.Both){\n\t\t\tgl.cullFace(gl.Culling.FRONT_AND_BACK)\n\t\t}\t\n\t\tfor (let i = 0; i < material.uniforms.length; i++){\n\t\t\tmaterial.uniforms[i].apply()\t\t\t\n\t\t}\n\t}\n}","import { Mesh } from '../../core/components/Mesh'\nimport { host } from '../../imports'\nimport { WebGLMesh } from '../components'\nimport { gl } from '../imports'\nimport { WebGLGeometrySystem } from './WebGLGeometrySystem'\nimport { WebGLMaterialSystem } from './WebGLMaterialSystem'\nimport { WebGLShaderSystem } from './WebGLShaderSystem'\nimport { WebGLUniformBufferObjectSystem } from './WebGLUniformBufferObjectSystem'\n\n\nexport class WebGLMeshSystem{\n\n\tshaderSystem: WebGLShaderSystem\n\tgeometrySystem: WebGLGeometrySystem\n\tmaterialSystem: WebGLMaterialSystem\n\n\tmeshMap: Map<Mesh, WebGLMesh> = new Map()\n\n\tconstructor(uboSystem: WebGLUniformBufferObjectSystem){\n\t\tthis.materialSystem = new WebGLMaterialSystem(uboSystem)\n\t\tthis.geometrySystem = new WebGLGeometrySystem()\n\t\tthis.shaderSystem = new WebGLShaderSystem()\n\t}\n\tcreate(mesh: Mesh): void{\n\t\tconst shader = this.shaderSystem.getOrCreate(mesh.material.shader)\n\t\tconst geometry = this.geometrySystem.getOrCreate(mesh.geometry, shader)\n\t\tconst material = this.materialSystem.getOrCreate(mesh.material, shader)\n\t\tthis.meshMap.set(mesh, { shader, material, geometry })\n\t}\n\trender(mesh: Mesh): void{\n\t\tconst glMesh = this.meshMap.get(mesh)\n\t\tconst program = host.get(glMesh.shader.programId)\n\t\tgl.useProgram(program)\n\t\tthis.materialSystem.beforeRender(glMesh.material)\n\t\tthis.geometrySystem.render(glMesh.geometry)\n\t\tgl.useProgram(null)\n\t}\t\n}","import { host } from '../../imports'\nimport { Attribute, Attribute_f32, Attribute_u8, Geometry } from '../../rendering'\nimport { WebGLAttribute, WebGLBindAttributeOptions, WebGLGeometry, WebGLShader, WebGLVAOOptions } from '../components'\nimport { gl } from '../imports'\nimport { attributeArrayBuffer, bufferUsage } from './utility'\n\n\n\n\nexport class WebGLGeometrySystem{\t\n\t\n\tgeometryMap: Map<Geometry, WebGLGeometry> = new Map()\n\tattributeMap: Map<Attribute, WebGLAttribute> = new Map()\n\n\tgetOrCreate(geometry: Geometry, shader: WebGLShader): WebGLGeometry{\t\t\n\t\tif (this.geometryMap.has(geometry))\n\t\t\treturn this.geometryMap.get(geometry)\n\t\tconst glGeometry = this.create(geometry, shader)\n\t\tthis.geometryMap.set(geometry, glGeometry)\n\t\treturn glGeometry\n\t}\n\n\tcreate(geometry: Geometry, shader: WebGLShader): WebGLGeometry{\t\t\n\t\tconst attributes: WebGLAttribute[] = new Array(geometry.attributeArr.length)\n\t\tfor (let i = 0; i < attributes.length; i++)\n\t\t\tattributes[i] = this.getOrCreateAttribute(geometry.attributeArr[i])\n\t\t\n\t\tconst indices = geometry.indices\n\t\tconst indicesUsage = bufferUsage(geometry.dynamicIndices)\n\t\tconst instanceGeometry = geometry.instanceCount > 0\n\n\t\tconst vao = this.createVAO(attributes, shader, {\n\t\t\tuseSwap: false, indices, indicesUsage, instanceGeometry,\n\t\t})\n\t\tconst swappable = attributes.some(attr => !!attr.bufferSwap)\n\t\t\n\t\tif (shader.useFeedback && !swappable)\n\t\t\tthrow new Error('Geometry Glue - Shader uses Transform Feedback but no attributes found marked as varying. Did you for get to new Attribute().asVarying()')\n\n\t\tconst vaoSwap = swappable\n\t\t\t? this.createVAO(attributes, shader, { \n\t\t\t\tuseSwap: true, indices, indicesUsage, instanceGeometry\n\t\t\t})\n\t\t\t: null\n\t\t\n\t\t//vao1->feedback2, vao2->feedback1\n\t\tconst feedback = shader.useFeedback\n\t\t\t? this.createFeedback(attributes, true)\n\t\t\t: null\n\t\tconst feedbackSwap = shader.useFeedback\n\t\t\t? this.createFeedback(attributes, false)\n\t\t\t: null\n\t\t\n\t\tconst instance: WebGLGeometry = {\n\t\t\tvao: host.set(vao),\n\t\t\tvaoSwap: vaoSwap ? host.set(vaoSwap) : 0,\n\t\t\tfeedback: host.set(feedback),\n\t\t\tfeedbackSwap: feedbackSwap ? host.set(feedbackSwap) : 0,\n\t\t\tattributes,\n\t\t\tinstanceCount: geometry.instanceCount,\n\t\t\tprimitiveType: geometry.primitiveType,\n\t\t\tuseIndices: !!indices,\n\t\t\tdrawCount: indices \n\t\t\t\t? indices.length\n\t\t\t\t: geometry.vertexCount\n\t\t}\n\t\t\n\t\tgl.bindBuffer(gl.BufferType.ARRAY_BUFFER, null)\n\t\treturn instance\n\t}\n\t\n\tcreateVAO(attributes: WebGLAttribute[], shader: WebGLShader, options: WebGLVAOOptions): gl.WebGLVertexArrayObject{\n\t\n\t\tconst vao = gl.createVertexArray()\n\t\tgl.bindVertexArray(vao)\n\t\tfor (let i = 0; i < attributes.length; i++)\n\t\t\tthis.bindAttribute(attributes[i], shader, options)\n\n\t\tconst indices = options.indices\n\t\tif (indices){\n\t\t\tconst indexBuffer = gl.createBuffer()\n\t\t\tgl.bindBuffer(gl.BufferType.ELEMENT_ARRAY_BUFFER, indexBuffer)\n\t\t\tgl.bufferData__5(gl.BufferType.ELEMENT_ARRAY_BUFFER, indices, options.indicesUsage)\n\t\t}\n\t\tgl.bindVertexArray(null)\n\t\t// gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n\t\tgl.bindBuffer(gl.BufferType.ARRAY_BUFFER, null)\n\t\treturn vao\t\t\n\t}\n\n\tcreateFeedback(attributes: WebGLAttribute[], useSwap: bool = false): gl.WebGLTransformFeedback{\n\t\tconst feedback = gl.createTransformFeedback()\n\t\tgl.bindTransformFeedback(gl.TransformFeedback.TRANSFORM_FEEDBACK, feedback)\t\t\n\t\tconst varyings = attributes.filter(attribute => attribute.bufferSwap !== 0)\n\t\t\n\t\tfor (let i = 0; i < varyings.length; i++){\n\t\t\tconst bufferId = useSwap ? varyings[i].bufferSwap : varyings[i].buffer\n\t\t\tconst buffer = host.get(bufferId)\n\t\t\tgl.bindBufferBase(gl.BufferType.TRANSFORM_FEEDBACK_BUFFER, i, buffer)\n\t\t}\n\t\tgl.bindBuffer(gl.BufferType.ARRAY_BUFFER, null)\n\t\tgl.bindBuffer(gl.BufferType.TRANSFORM_FEEDBACK_BUFFER, null)\n\t\treturn feedback\n\t}\n\t\n\tbindAttribute(attr: WebGLAttribute, shader: WebGLShader, options: WebGLBindAttributeOptions): void{\n\t\tconst program = host.get(shader.programId)\n\t\tconst loc = gl.getAttribLocation(program, attr.name)\n\t\t\n\t\tif (loc === -1)//attribute not used by shader\n\t\t\treturn\n\t\tconst bufferId = attr.bufferSwap && options.useSwap \n\t\t\t? attr.bufferSwap\n\t\t\t: attr.buffer\n\t\tconst buffer = host.get(bufferId)\n\t\tgl.bindBuffer(gl.BufferType.ARRAY_BUFFER, buffer)\n\t\tgl.enableVertexAttribArray(loc)\n\t\tgl.vertexAttribPointer(loc, attr.elementSize, attr.type, attr.normalize, 0, 0)\n\t\t\n\t\tif (options.instanceGeometry && attr.instanceDivisor > 0)\n\t\t\tgl.vertexAttribDivisor(loc, attr.instanceDivisor)\n\t}\n\n\tgetOrCreateAttribute(attr: Attribute): WebGLAttribute{\n\t\tif (this.attributeMap.has(attr))\n\t\t\treturn this.attributeMap.get(attr)\n\t\tconst glAttr = this.createAttribute(attr)\n\t\tthis.attributeMap.set(attr, glAttr)\n\t\treturn glAttr\n\t}\n\t\t\n\tcreateAttribute(attr: Attribute): WebGLAttribute{\n\t\tconst buffer = this.createBuffer(attr)\n\t\tconst bufferSwap = attr.varyingName\n\t\t\t? this.createBuffer(attr)\n\t\t\t: null\n\t\treturn {\n\t\t\tname: attr.name,\n\t\t\tbuffer: host.set(buffer),\n\t\t\tbufferSwap: bufferSwap ? host.set(bufferSwap) : 0,\n\t\t\ttype: attr.type,\n\t\t\tnormalize: !!attr.normalize,\n\t\t\telementSize: attr.elementSize,\n\t\t\tinstanceDivisor: attr.instanceDivisor\n\t\t}\n\t}\n\t\n\tcreateBuffer(attr: Attribute): gl.WebGLBuffer{\n\t\tconst buffer = gl.createBuffer()\n\t\tgl.bindBuffer(gl.BufferType.ARRAY_BUFFER, buffer)\n\t\tswitch (attr.type){\n\t\tdefault:\n\t\tcase gl.DataType.FLOAT:\n\t\t\tgl.bufferData__3(gl.BufferType.ARRAY_BUFFER, (attr as Attribute_f32).value, bufferUsage(attr.dynamic))\n\t\t\tbreak\n\t\tcase gl.DataType.UNSIGNED_BYTE:\n\t\t\tgl.bufferData__4(gl.BufferType.ARRAY_BUFFER, (attr as Attribute_u8).value, bufferUsage(attr.dynamic))\n\t\t\tbreak\n\t\t}\n\t\treturn buffer\n\t}\n\n\trender(geometry: WebGLGeometry): void{\n\t\t\n\t\tconst vao = host.get(geometry.vao)\n\t\t// domUtils.log_externref(vao)\n\t\t// console.log(`${geometry.vao}`)\n\t\tgl.bindVertexArray(vao)\n\t\t// domUtils.log_externref(vao)\n\t\t//TODO webgl geometries should know how to draw themselves\n\t\tif (geometry.feedback){\n\t\t\t// console.log(next)\n\t\t\t//read from 1\n\t\t\tgl.enable(gl.Parameter.RASTERIZER_DISCARD)\n\t\t\t//write to next\n\t\t\tgl.bindTransformFeedback(gl.TransformFeedback.TRANSFORM_FEEDBACK, host.get(geometry.feedback))\n\t\t\tgl.beginTransformFeedback(gl.Primitive.POINTS)\n\t\t\tgl.drawArrays(gl.Primitive.POINTS, 0, geometry.drawCount)\n\t\t\tgl.disable(gl.Parameter.RASTERIZER_DISCARD)\n\t\t\tgl.endTransformFeedback()\n\t\t\tgl.bindTransformFeedback(gl.TransformFeedback.TRANSFORM_FEEDBACK, null)\n\t\t} else if (geometry.instanceCount > 0 && geometry.useIndices)\n\t\t\tgl.drawElementsInstanced(geometry.primitiveType, geometry.drawCount, gl.DataType.UNSIGNED_SHORT, 0, geometry.instanceCount)\n\t\telse if (geometry.instanceCount > 0)\n\t\t\tgl.drawArraysInstanced(geometry.primitiveType, 0, geometry.drawCount, geometry.instanceCount)\n\t\telse if (geometry.useIndices)\n\t\t\tgl.drawElements(geometry.primitiveType, geometry.drawCount, gl.DataType.UNSIGNED_SHORT, 0)\n\t\telse\n\t\t\tgl.drawArrays(geometry.primitiveType, 0, geometry.drawCount)\n\t\tgl.bindVertexArray(null)\n\n\t\tif (geometry.vaoSwap){\n\t\t\tconst temp = geometry.vao\n\t\t\tgeometry.vao = geometry.vaoSwap\n\t\t\tgeometry.vaoSwap = temp\n\t\t}\n\t\tif (geometry.feedbackSwap){\n\t\t\tconst temp = geometry.feedback\n\t\t\tgeometry.feedback = geometry.feedbackSwap\n\t\t\tgeometry.feedbackSwap = temp\n\t\t}\n\t}\n\t\n}","import { host } from '../../imports'\nimport { Shader } from '../../rendering'\nimport { stringOrEmpty } from '../../utility/stringUtils'\nimport { WebGLShader } from '../components'\nimport { gl } from '../imports'\n\n\n\n\nexport class WebGLShaderSystem{\n\tvalidate: bool = true\n\tshaderMap: Map<Shader, WebGLShader> = new Map()\n\n\tgetOrCreate(shader: Shader): WebGLShader{\n\t\tif (this.shaderMap.has(shader))\n\t\t\treturn this.shaderMap.get(shader)\n\t\tconst instance = this.create(shader)\n\t\tthis.shaderMap.set(shader, instance)\n\t\treturn instance\n\t}\n\t\n\tcompileShader(src: string, type: gl.ShaderType): gl.WebGLProgram{\n\t\tconst shader = gl.createShader(type)\n\t\tgl.shaderSource(shader, src)\n\t\tgl.compileShader(shader)\n\t\t\n\t\tif (!gl.getShaderParameter__1(shader, gl.ShaderStatus.COMPILE_STATUS)){\n\t\t\tgl.deleteShader(shader)\n\t\t\tthrow new Error('Error compiling shader : ' + src + '\\n' + stringOrEmpty(gl.getShaderInfoLog(shader)))\n\t\t}\n\t\treturn shader\n\t}\n\tcreate(shader: Shader): WebGLShader{\n\t\tconst vShader = this.compileShader(shader.vert, gl.ShaderType.VERTEX_SHADER)\n\t\tconst fShader = this.compileShader(shader.frag, gl.ShaderType.FRAGMENT_SHADER)\n\t\tconst program = gl.createProgram()\n\t\tgl.attachShader(program, vShader)\n\t\tgl.attachShader(program, fShader)\n\t\n\n\t\tconst useFeedback = shader.varyings.length > 0\n\t\tif (useFeedback)\n\t\t\tgl.transformFeedbackVaryings(program, shader.varyings, gl.TransformFeedback.SEPARATE_ATTRIBS)\n\t\n\t\tgl.linkProgram(program)\n\t\n\t\tif (!gl.getProgramParameter__1(program, gl.ShaderStatus.LINK_STATUS)){\n\t\t\tgl.deleteProgram(program)\n\t\t\tthrow new Error('Error creating shader program.\\n' + stringOrEmpty(gl.getProgramInfoLog(program)))\n\t\t}\n\t\n\t\tif (this.validate){\n\t\t\tgl.validateProgram(program)\n\t\t\tif (!gl.getProgramParameter__1(program, gl.ShaderStatus.VALIDATE_STATUS)){\n\t\t\t\tgl.deleteProgram(program)\n\t\t\t\tthrow new Error('Error validating program\\n' + stringOrEmpty(gl.getProgramInfoLog(program)))\n\t\t\t}\n\t\t}\n\n\t\t// is this nessecary?\n\t\tgl.detachShader(program, vShader) \n\t\tgl.detachShader(program, fShader)\n\t\tgl.deleteShader(fShader)\n\t\tgl.deleteShader(vShader)\n\n\t\tconst programId = host.set(program)\n\n\t\treturn {\n\t\t\tprogramId,\n\t\t\tuseFeedback\n\t\t}\n\t}\n}","import { ListenerSystem, Entity } from '../../base'\nimport { KeyboardCode } from '../../constants'\nimport { MouseKeyboardController, Transform } from '../components'\nimport { InputSystem } from './InputSystem'\n\n\n\n\nexport class MouseKeyboardControllerSystem extends ListenerSystem{\n\n\tconstructor(){\n\t\tsuper([idof<MouseKeyboardController>()])\n\t}\n\t\n\tonUpdate(entity: Entity): void {\n\t\tconst inputSystem = this.world.getOrAdd<InputSystem>()\n\t\tconst controller = entity.get<MouseKeyboardController>()\n\t\tconst transform = entity.get<Transform>()\n\t\tif (inputSystem.mouseIsDown){\n\t\t\tconst angles = transform.rotation.toEulerAngles()\n\t\t\t//roll = mouseY\n\t\t\tangles.x += inputSystem.mouseDeltaPos.y * controller.mouseRotationScalar * -1\n\t\t\t//yaw = mouseX\n\t\t\tangles.y += inputSystem.mouseDeltaPos.x * controller.mouseRotationScalar\n\t\t\ttransform.rotation.fromEulerAngles(angles)\n\t\t}\n\t\t// imports.utils.log(`${inputSystem.mouseDeltaPos.y}`)\n\t\tif (inputSystem.mouseWheelDeltaPos.y !== 0)\n\t\t\ttransform.translateY(controller.wheelTranslationScalar * inputSystem.mouseWheelDeltaPos.y)\n\t\n\t\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyW) || inputSystem.keysIsDown.has(KeyboardCode.ArrowUp))\n\t\t\ttransform.translateZ(controller.keyTranslationScalar)\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyS) || inputSystem.keysIsDown.has(KeyboardCode.ArrowDown))\n\t\t\ttransform.translateZ(-controller.keyTranslationScalar)\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyA) || inputSystem.keysIsDown.has(KeyboardCode.ArrowLeft))\n\t\t\ttransform.translateX(controller.keyTranslationScalar)\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyD) || inputSystem.keysIsDown.has(KeyboardCode.ArrowRight))\n\t\t\ttransform.translateX(-controller.keyTranslationScalar)\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyQ))\n\t\t\ttransform.rotation.rotate(0, controller.keyRotationScalar, 0)\n\t\tif (inputSystem.keysIsDown.has(KeyboardCode.KeyE))\n\t\t\ttransform.rotation.rotate(0, -controller.keyRotationScalar, 0)\n\t}\n\t\n}","import { World } from '../base'\nimport { DirectionalLight } from '../core/components'\n\nexport function createDefaultLights(): void{\n\t// World.main.createEntity()\n\t// \t.attach(new DirectionalLight().setDirection(0, 1, 0))\n\tWorld.main.createEntity()\n\t\t.attach(new DirectionalLight().setDirection(-1, -1, -1))\n}\n","\n\n\n\n\n\n\n\nexport class Vector1Base<T1, T2>{\n\tm: T1\n\t//@ts-ignore\n\tget value(): T2{ return this.m[0] }\n\t//@ts-ignore\n\tset value(value: T2){ this.m[0] = value }\n\t\n\tconstructor(m: T1 = instantiate<T1>(1)){\n\t\tthis.m = m\n\t}\n\tset(value: T2): Vector1Base<T1, T2>{\n\t\tthis.value = value\n\t\treturn this\n\t}\n}\nexport class Vector1 extends Vector1Base<Float32Array, f32>{}","import { Entity, World } from '../base'\nimport { Mesh, Rotator } from '../core/components'\nimport { CubeGeometry, Shader, StandardMaterial, unlitVertexColorShader } from '../rendering'\n\nexport function rotatingCube(_shader: Shader | null): Entity{\n\tconst shader = _shader == null ? unlitVertexColorShader : _shader\n\t\n\tconst entity = World.main.createEntity()\n\n\tconst material = new StandardMaterial(shader)\n\t// .setColor(0.25, 0.4, 0.25)\n\t// .setColor(0.25, 0.4, 0.25)\n\tconst mesh = new Mesh(CubeGeometry.default, material)\n\n\tconst rotator = new Rotator()\n\trotator.offset.set(0, 1, 0)\n\t\n\tentity.attach(mesh)\n\t\t.attach(rotator)\n\treturn entity\n}\n\n","import { Vector3 } from '../../math'\nimport { Component } from '../../base'\nimport { Transform } from './Transform'\n\nexport class Rotator extends Component{\n\tconstructor(){\n\t\tsuper()\n\t\tthis.entity.getOrAdd<Transform>()\n\t}\n\n\tstartTime: f32\n\toffset: Vector3 = new Vector3()\n}","import { World } from '../base'\nimport { KeyboardCode } from '../constants'\nimport { InputSystem } from '../core'\n\n\nexport function handleMouseDown(): void{\n\tWorld.main.get<InputSystem>().handleMouseDown()\n}\nexport function handleMouseUp(): void{\n\tWorld.main.get<InputSystem>().handleMouseUp()\n}\n\nexport function handleMouseWheel(x: f32, y: f32): void{\n\tWorld.main.get<InputSystem>().handleMouseWheel(x, y)\n}\n\nexport function handleMouseMove(x: f32, y: f32): void{\n\tWorld.main.get<InputSystem>().handleMouseMove(x, y)\n}\nexport function handleKeyDown(key: KeyboardCode): void{\n\tWorld.main.get<InputSystem>().handleKeyDown(key)\n}\nexport function handleKeyUp(key: KeyboardCode): void{\n\tWorld.main.get<InputSystem>().handleKeyUp(key)\n}\n","import { World } from '../base'\nimport { RenderSystem } from '../core'\nimport { WebGLRenderSystem } from '../WebGL2'\n\n\n\n\n\nexport function handleResize(width: u32, height: u32): void{\n\tRenderSystem.canvasWidth = width\n\tRenderSystem.canvasHeight = height\n\tconst aspect = <f32>width / <f32>height\n\t//TODO get parent class can return child, ie get<RenderSystem>\n\tconst renderSystem = World.main.get<WebGLRenderSystem>()\n\tconst cameras = renderSystem.cameraQuery.components\n\tfor (let i = 0; i < cameras.length; i++){\n\t\tif (cameras[i].fillCanvas){\n\t\t\tcameras[i].setViewport(0, 0, width, height, aspect)\n\t\t}\n\t}\n}\n","\n\nexport function stringOrEmpty(val: string | null): string{\n\treturn val == null ? '' : val\n}","import { Attribute, Attribute_f32, Attribute_u8, Uniform, UniformType, Uniform_f32 } from '../../rendering'\nimport { gl } from '../imports'\n\nexport function bufferUsage(dynamic: bool): gl.BufferUsage{\n\treturn dynamic ? gl.BufferUsage.DYNAMIC_DRAW : gl.BufferUsage.STATIC_DRAW\n}\n\n\n//These are wrong, some typed arrays have a byte offset\nexport function attributeArrayBuffer(attr: Attribute): ArrayBuffer{\n\tswitch (attr.type){\n\tdefault:\n\tcase gl.DataType.FLOAT:\n\t\treturn (attr as Attribute_f32).value.buffer\n\tcase gl.DataType.UNSIGNED_BYTE:\n\t\treturn (attr as Attribute_u8).value.buffer\n\t}\n}\nexport function uniformArrayBuffer(uni: Uniform): ArrayBuffer{\n\tswitch (uni.type){\n\tdefault:\n\tcase UniformType.FLOAT:\n\tcase UniformType.FLOAT_VEC2:\n\tcase UniformType.FLOAT_VEC3:\n\tcase UniformType.FLOAT_VEC4:\n\tcase UniformType.FLOAT_MAT4:\n\t\treturn (uni as Uniform_f32).value.buffer\n\t// case gl.DataType.UNSIGNED_BYTE:\n\t// \treturn (attr as Attribute_u8).value.buffer\n\t}\n}","import { host, ExternID } from '../../imports'\nimport { Culling, Uniform } from '../../rendering'\nimport { gl } from '../imports'\n\n\n\n\nexport class WebGLMaterial{\n\t// uniforms: WebGLUniform[]\n\tuniforms: WebGLUniform[]\n\tubos: WebGLUniformBufferObject[]\n\ttransparent: boolean\n\tculling: Culling\n}\n\n\nexport class WebGLUniformBufferObject{\n\tname: string\n\tindex: u32\n\tbufferId: ExternID\n\tuniforms: Uniform[]\n\tuniformOffsets: u32[]\n\t// uniforms: {\n\t// \tapply: () => void\n\t// \t// index: number\n\t// \t// offset: number\n\t// \t// arr: TypedArray\n\t// }[]\n}\n\nexport class WebGLUniform{\n\tlocationId: ExternID\n\tconstructor(location: gl.WebGLUniformLocation){\n\t\tthis.locationId = host.set(location)\n\t}\n\t// location:u32\n\t// arr: TypedArray\n\tapply(): void{}\n}\nexport class WebGLUniform_typed<T> extends WebGLUniform{\n\tvalue: T\n\tconstructor(location: gl.WebGLUniformLocation, value: T){\n\t\tsuper(location)\n\t\tthis.value = value\n\t}\n}\nexport class WebGLUniform_float extends WebGLUniform_typed<Float32Array>{\n\tapply(): void { gl.uniform1fv(host.get(this.locationId), this.value) }\n}\nexport class WebGLUniform_vec2 extends WebGLUniform_typed<Float32Array>{\n\tapply(): void { gl.uniform2fv(host.get(this.locationId), this.value) }\n}\nexport class WebGLUniform_vec3 extends WebGLUniform_typed<Float32Array>{\n\tapply(): void { gl.uniform3fv(host.get(this.locationId), this.value) }\n}\nexport class WebGLUniform_vec4 extends WebGLUniform_typed<Float32Array>{\n\tapply(): void { gl.uniform4fv(host.get(this.locationId), this.value) }\n}\nexport class WebGLUniform_mat4 extends WebGLUniform_typed<Float32Array>{\n\tapply(): void { gl.uniformMatrix4fv(host.get(this.locationId), false, this.value) }\n}\n\n\n\n\nexport class WebGLTextureUniform extends WebGLUniform{\n\ttexIndex: u32\n\tconstructor(location: gl.WebGLUniformLocation, texIndex: u32){\n\t\tsuper(location)\n\t\tthis.texIndex = texIndex\n\t}\n\n\tapply(): void{\n\t\tgl.uniform1i(host.get(this.locationId), this.texIndex)\n\t}\n}","\n\n\nexport class PolarCoords{\n\tangle: f32\n\tradius: f32\n\tconstructor(angle: f32 = 0, radius: f32 = 1){\n\t\tthis.radius = radius\n\t\tthis.angle = angle\n\t}\n}","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}